// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hu.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_hu_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_hu_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_hu_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_hu_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[84]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_hu_2eproto;
namespace HU {
class AbsoluteInputEvent;
class AbsoluteInputEventDefaultTypeInternal;
extern AbsoluteInputEventDefaultTypeInternal _AbsoluteInputEvent_default_instance_;
class AbsoluteInputEventWrapper;
class AbsoluteInputEventWrapperDefaultTypeInternal;
extern AbsoluteInputEventWrapperDefaultTypeInternal _AbsoluteInputEventWrapper_default_instance_;
class AudioCofig;
class AudioCofigDefaultTypeInternal;
extern AudioCofigDefaultTypeInternal _AudioCofig_default_instance_;
class AudioFocusRequest;
class AudioFocusRequestDefaultTypeInternal;
extern AudioFocusRequestDefaultTypeInternal _AudioFocusRequest_default_instance_;
class AudioFocusResponse;
class AudioFocusResponseDefaultTypeInternal;
extern AudioFocusResponseDefaultTypeInternal _AudioFocusResponse_default_instance_;
class AuthCompleteResponse;
class AuthCompleteResponseDefaultTypeInternal;
extern AuthCompleteResponseDefaultTypeInternal _AuthCompleteResponse_default_instance_;
class BindingRequest;
class BindingRequestDefaultTypeInternal;
extern BindingRequestDefaultTypeInternal _BindingRequest_default_instance_;
class BindingResponse;
class BindingResponseDefaultTypeInternal;
extern BindingResponseDefaultTypeInternal _BindingResponse_default_instance_;
class BluetoothAuthData;
class BluetoothAuthDataDefaultTypeInternal;
extern BluetoothAuthDataDefaultTypeInternal _BluetoothAuthData_default_instance_;
class BluetoothPairingRequest;
class BluetoothPairingRequestDefaultTypeInternal;
extern BluetoothPairingRequestDefaultTypeInternal _BluetoothPairingRequest_default_instance_;
class BluetoothPairingResponse;
class BluetoothPairingResponseDefaultTypeInternal;
extern BluetoothPairingResponseDefaultTypeInternal _BluetoothPairingResponse_default_instance_;
class ButtonInfo;
class ButtonInfoDefaultTypeInternal;
extern ButtonInfoDefaultTypeInternal _ButtonInfo_default_instance_;
class ButtonInfoWrapper;
class ButtonInfoWrapperDefaultTypeInternal;
extern ButtonInfoWrapperDefaultTypeInternal _ButtonInfoWrapper_default_instance_;
class ChannelDescriptor;
class ChannelDescriptorDefaultTypeInternal;
extern ChannelDescriptorDefaultTypeInternal _ChannelDescriptor_default_instance_;
class ChannelDescriptor_BluetoothService;
class ChannelDescriptor_BluetoothServiceDefaultTypeInternal;
extern ChannelDescriptor_BluetoothServiceDefaultTypeInternal _ChannelDescriptor_BluetoothService_default_instance_;
class ChannelDescriptor_GenericNotificationService;
class ChannelDescriptor_GenericNotificationServiceDefaultTypeInternal;
extern ChannelDescriptor_GenericNotificationServiceDefaultTypeInternal _ChannelDescriptor_GenericNotificationService_default_instance_;
class ChannelDescriptor_InputEventChannel;
class ChannelDescriptor_InputEventChannelDefaultTypeInternal;
extern ChannelDescriptor_InputEventChannelDefaultTypeInternal _ChannelDescriptor_InputEventChannel_default_instance_;
class ChannelDescriptor_InputEventChannel_TouchScreenConfig;
class ChannelDescriptor_InputEventChannel_TouchScreenConfigDefaultTypeInternal;
extern ChannelDescriptor_InputEventChannel_TouchScreenConfigDefaultTypeInternal _ChannelDescriptor_InputEventChannel_TouchScreenConfig_default_instance_;
class ChannelDescriptor_InputStreamChannel;
class ChannelDescriptor_InputStreamChannelDefaultTypeInternal;
extern ChannelDescriptor_InputStreamChannelDefaultTypeInternal _ChannelDescriptor_InputStreamChannel_default_instance_;
class ChannelDescriptor_NavigationStatusService;
class ChannelDescriptor_NavigationStatusServiceDefaultTypeInternal;
extern ChannelDescriptor_NavigationStatusServiceDefaultTypeInternal _ChannelDescriptor_NavigationStatusService_default_instance_;
class ChannelDescriptor_NavigationStatusService_ImageOptions;
class ChannelDescriptor_NavigationStatusService_ImageOptionsDefaultTypeInternal;
extern ChannelDescriptor_NavigationStatusService_ImageOptionsDefaultTypeInternal _ChannelDescriptor_NavigationStatusService_ImageOptions_default_instance_;
class ChannelDescriptor_OutputStreamChannel;
class ChannelDescriptor_OutputStreamChannelDefaultTypeInternal;
extern ChannelDescriptor_OutputStreamChannelDefaultTypeInternal _ChannelDescriptor_OutputStreamChannel_default_instance_;
class ChannelDescriptor_OutputStreamChannel_VideoConfig;
class ChannelDescriptor_OutputStreamChannel_VideoConfigDefaultTypeInternal;
extern ChannelDescriptor_OutputStreamChannel_VideoConfigDefaultTypeInternal _ChannelDescriptor_OutputStreamChannel_VideoConfig_default_instance_;
class ChannelDescriptor_PhoneStatusService;
class ChannelDescriptor_PhoneStatusServiceDefaultTypeInternal;
extern ChannelDescriptor_PhoneStatusServiceDefaultTypeInternal _ChannelDescriptor_PhoneStatusService_default_instance_;
class ChannelDescriptor_SensorChannel;
class ChannelDescriptor_SensorChannelDefaultTypeInternal;
extern ChannelDescriptor_SensorChannelDefaultTypeInternal _ChannelDescriptor_SensorChannel_default_instance_;
class ChannelDescriptor_SensorChannel_Sensor;
class ChannelDescriptor_SensorChannel_SensorDefaultTypeInternal;
extern ChannelDescriptor_SensorChannel_SensorDefaultTypeInternal _ChannelDescriptor_SensorChannel_Sensor_default_instance_;
class ChannelDescriptor_VendorExtensionService;
class ChannelDescriptor_VendorExtensionServiceDefaultTypeInternal;
extern ChannelDescriptor_VendorExtensionServiceDefaultTypeInternal _ChannelDescriptor_VendorExtensionService_default_instance_;
class ChannelOpenRequest;
class ChannelOpenRequestDefaultTypeInternal;
extern ChannelOpenRequestDefaultTypeInternal _ChannelOpenRequest_default_instance_;
class ChannelOpenResponse;
class ChannelOpenResponseDefaultTypeInternal;
extern ChannelOpenResponseDefaultTypeInternal _ChannelOpenResponse_default_instance_;
class GenericNotificationRequest;
class GenericNotificationRequestDefaultTypeInternal;
extern GenericNotificationRequestDefaultTypeInternal _GenericNotificationRequest_default_instance_;
class GenericNotificationResponse;
class GenericNotificationResponseDefaultTypeInternal;
extern GenericNotificationResponseDefaultTypeInternal _GenericNotificationResponse_default_instance_;
class InputEvent;
class InputEventDefaultTypeInternal;
extern InputEventDefaultTypeInternal _InputEvent_default_instance_;
class MediaAck;
class MediaAckDefaultTypeInternal;
extern MediaAckDefaultTypeInternal _MediaAck_default_instance_;
class MediaSetupRequest;
class MediaSetupRequestDefaultTypeInternal;
extern MediaSetupRequestDefaultTypeInternal _MediaSetupRequest_default_instance_;
class MediaSetupResponse;
class MediaSetupResponseDefaultTypeInternal;
extern MediaSetupResponseDefaultTypeInternal _MediaSetupResponse_default_instance_;
class MediaStartRequest;
class MediaStartRequestDefaultTypeInternal;
extern MediaStartRequestDefaultTypeInternal _MediaStartRequest_default_instance_;
class MediaStopRequest;
class MediaStopRequestDefaultTypeInternal;
extern MediaStopRequestDefaultTypeInternal _MediaStopRequest_default_instance_;
class MicRequest;
class MicRequestDefaultTypeInternal;
extern MicRequestDefaultTypeInternal _MicRequest_default_instance_;
class MicResponse;
class MicResponseDefaultTypeInternal;
extern MicResponseDefaultTypeInternal _MicResponse_default_instance_;
class NAVDistanceMessage;
class NAVDistanceMessageDefaultTypeInternal;
extern NAVDistanceMessageDefaultTypeInternal _NAVDistanceMessage_default_instance_;
class NAVMessagesStatus;
class NAVMessagesStatusDefaultTypeInternal;
extern NAVMessagesStatusDefaultTypeInternal _NAVMessagesStatus_default_instance_;
class NAVTurnMessage;
class NAVTurnMessageDefaultTypeInternal;
extern NAVTurnMessageDefaultTypeInternal _NAVTurnMessage_default_instance_;
class NavigationFocusRequest;
class NavigationFocusRequestDefaultTypeInternal;
extern NavigationFocusRequestDefaultTypeInternal _NavigationFocusRequest_default_instance_;
class NavigationFocusResponse;
class NavigationFocusResponseDefaultTypeInternal;
extern NavigationFocusResponseDefaultTypeInternal _NavigationFocusResponse_default_instance_;
class PhoneStatus;
class PhoneStatusDefaultTypeInternal;
extern PhoneStatusDefaultTypeInternal _PhoneStatus_default_instance_;
class PhoneStatusInput;
class PhoneStatusInputDefaultTypeInternal;
extern PhoneStatusInputDefaultTypeInternal _PhoneStatusInput_default_instance_;
class PhoneStatus_Call;
class PhoneStatus_CallDefaultTypeInternal;
extern PhoneStatus_CallDefaultTypeInternal _PhoneStatus_Call_default_instance_;
class PingRequest;
class PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
class PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class RelativeInputEvent;
class RelativeInputEventDefaultTypeInternal;
extern RelativeInputEventDefaultTypeInternal _RelativeInputEvent_default_instance_;
class RelativeInputEventWrapper;
class RelativeInputEventWrapperDefaultTypeInternal;
extern RelativeInputEventWrapperDefaultTypeInternal _RelativeInputEventWrapper_default_instance_;
class SensorEvent;
class SensorEventDefaultTypeInternal;
extern SensorEventDefaultTypeInternal _SensorEvent_default_instance_;
class SensorEvent_Accel;
class SensorEvent_AccelDefaultTypeInternal;
extern SensorEvent_AccelDefaultTypeInternal _SensorEvent_Accel_default_instance_;
class SensorEvent_CompassData;
class SensorEvent_CompassDataDefaultTypeInternal;
extern SensorEvent_CompassDataDefaultTypeInternal _SensorEvent_CompassData_default_instance_;
class SensorEvent_DeadReckoning;
class SensorEvent_DeadReckoningDefaultTypeInternal;
extern SensorEvent_DeadReckoningDefaultTypeInternal _SensorEvent_DeadReckoning_default_instance_;
class SensorEvent_Diagnostics;
class SensorEvent_DiagnosticsDefaultTypeInternal;
extern SensorEvent_DiagnosticsDefaultTypeInternal _SensorEvent_Diagnostics_default_instance_;
class SensorEvent_Door;
class SensorEvent_DoorDefaultTypeInternal;
extern SensorEvent_DoorDefaultTypeInternal _SensorEvent_Door_default_instance_;
class SensorEvent_DrivingStatus;
class SensorEvent_DrivingStatusDefaultTypeInternal;
extern SensorEvent_DrivingStatusDefaultTypeInternal _SensorEvent_DrivingStatus_default_instance_;
class SensorEvent_Environment;
class SensorEvent_EnvironmentDefaultTypeInternal;
extern SensorEvent_EnvironmentDefaultTypeInternal _SensorEvent_Environment_default_instance_;
class SensorEvent_FuelLevel;
class SensorEvent_FuelLevelDefaultTypeInternal;
extern SensorEvent_FuelLevelDefaultTypeInternal _SensorEvent_FuelLevel_default_instance_;
class SensorEvent_GearData;
class SensorEvent_GearDataDefaultTypeInternal;
extern SensorEvent_GearDataDefaultTypeInternal _SensorEvent_GearData_default_instance_;
class SensorEvent_Gyro;
class SensorEvent_GyroDefaultTypeInternal;
extern SensorEvent_GyroDefaultTypeInternal _SensorEvent_Gyro_default_instance_;
class SensorEvent_HVAC;
class SensorEvent_HVACDefaultTypeInternal;
extern SensorEvent_HVACDefaultTypeInternal _SensorEvent_HVAC_default_instance_;
class SensorEvent_Light;
class SensorEvent_LightDefaultTypeInternal;
extern SensorEvent_LightDefaultTypeInternal _SensorEvent_Light_default_instance_;
class SensorEvent_LocationData;
class SensorEvent_LocationDataDefaultTypeInternal;
extern SensorEvent_LocationDataDefaultTypeInternal _SensorEvent_LocationData_default_instance_;
class SensorEvent_NightMode;
class SensorEvent_NightModeDefaultTypeInternal;
extern SensorEvent_NightModeDefaultTypeInternal _SensorEvent_NightMode_default_instance_;
class SensorEvent_OdometerData;
class SensorEvent_OdometerDataDefaultTypeInternal;
extern SensorEvent_OdometerDataDefaultTypeInternal _SensorEvent_OdometerData_default_instance_;
class SensorEvent_ParkingBreak;
class SensorEvent_ParkingBreakDefaultTypeInternal;
extern SensorEvent_ParkingBreakDefaultTypeInternal _SensorEvent_ParkingBreak_default_instance_;
class SensorEvent_Passenger;
class SensorEvent_PassengerDefaultTypeInternal;
extern SensorEvent_PassengerDefaultTypeInternal _SensorEvent_Passenger_default_instance_;
class SensorEvent_RPM;
class SensorEvent_RPMDefaultTypeInternal;
extern SensorEvent_RPMDefaultTypeInternal _SensorEvent_RPM_default_instance_;
class SensorEvent_SpeedData;
class SensorEvent_SpeedDataDefaultTypeInternal;
extern SensorEvent_SpeedDataDefaultTypeInternal _SensorEvent_SpeedData_default_instance_;
class SensorStartRequest;
class SensorStartRequestDefaultTypeInternal;
extern SensorStartRequestDefaultTypeInternal _SensorStartRequest_default_instance_;
class SensorStartResponse;
class SensorStartResponseDefaultTypeInternal;
extern SensorStartResponseDefaultTypeInternal _SensorStartResponse_default_instance_;
class ServiceDiscoveryRequest;
class ServiceDiscoveryRequestDefaultTypeInternal;
extern ServiceDiscoveryRequestDefaultTypeInternal _ServiceDiscoveryRequest_default_instance_;
class ServiceDiscoveryResponse;
class ServiceDiscoveryResponseDefaultTypeInternal;
extern ServiceDiscoveryResponseDefaultTypeInternal _ServiceDiscoveryResponse_default_instance_;
class ShutdownRequest;
class ShutdownRequestDefaultTypeInternal;
extern ShutdownRequestDefaultTypeInternal _ShutdownRequest_default_instance_;
class ShutdownResponse;
class ShutdownResponseDefaultTypeInternal;
extern ShutdownResponseDefaultTypeInternal _ShutdownResponse_default_instance_;
class StartGenericNotifications;
class StartGenericNotificationsDefaultTypeInternal;
extern StartGenericNotificationsDefaultTypeInternal _StartGenericNotifications_default_instance_;
class StopGenericNotifications;
class StopGenericNotificationsDefaultTypeInternal;
extern StopGenericNotificationsDefaultTypeInternal _StopGenericNotifications_default_instance_;
class TouchInfo;
class TouchInfoDefaultTypeInternal;
extern TouchInfoDefaultTypeInternal _TouchInfo_default_instance_;
class TouchInfo_Location;
class TouchInfo_LocationDefaultTypeInternal;
extern TouchInfo_LocationDefaultTypeInternal _TouchInfo_Location_default_instance_;
class VideoFocus;
class VideoFocusDefaultTypeInternal;
extern VideoFocusDefaultTypeInternal _VideoFocus_default_instance_;
class VideoFocusRequest;
class VideoFocusRequestDefaultTypeInternal;
extern VideoFocusRequestDefaultTypeInternal _VideoFocusRequest_default_instance_;
class VoiceSessionRequest;
class VoiceSessionRequestDefaultTypeInternal;
extern VoiceSessionRequestDefaultTypeInternal _VoiceSessionRequest_default_instance_;
}  // namespace HU
PROTOBUF_NAMESPACE_OPEN
template<> ::HU::AbsoluteInputEvent* Arena::CreateMaybeMessage<::HU::AbsoluteInputEvent>(Arena*);
template<> ::HU::AbsoluteInputEventWrapper* Arena::CreateMaybeMessage<::HU::AbsoluteInputEventWrapper>(Arena*);
template<> ::HU::AudioCofig* Arena::CreateMaybeMessage<::HU::AudioCofig>(Arena*);
template<> ::HU::AudioFocusRequest* Arena::CreateMaybeMessage<::HU::AudioFocusRequest>(Arena*);
template<> ::HU::AudioFocusResponse* Arena::CreateMaybeMessage<::HU::AudioFocusResponse>(Arena*);
template<> ::HU::AuthCompleteResponse* Arena::CreateMaybeMessage<::HU::AuthCompleteResponse>(Arena*);
template<> ::HU::BindingRequest* Arena::CreateMaybeMessage<::HU::BindingRequest>(Arena*);
template<> ::HU::BindingResponse* Arena::CreateMaybeMessage<::HU::BindingResponse>(Arena*);
template<> ::HU::BluetoothAuthData* Arena::CreateMaybeMessage<::HU::BluetoothAuthData>(Arena*);
template<> ::HU::BluetoothPairingRequest* Arena::CreateMaybeMessage<::HU::BluetoothPairingRequest>(Arena*);
template<> ::HU::BluetoothPairingResponse* Arena::CreateMaybeMessage<::HU::BluetoothPairingResponse>(Arena*);
template<> ::HU::ButtonInfo* Arena::CreateMaybeMessage<::HU::ButtonInfo>(Arena*);
template<> ::HU::ButtonInfoWrapper* Arena::CreateMaybeMessage<::HU::ButtonInfoWrapper>(Arena*);
template<> ::HU::ChannelDescriptor* Arena::CreateMaybeMessage<::HU::ChannelDescriptor>(Arena*);
template<> ::HU::ChannelDescriptor_BluetoothService* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_BluetoothService>(Arena*);
template<> ::HU::ChannelDescriptor_GenericNotificationService* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_GenericNotificationService>(Arena*);
template<> ::HU::ChannelDescriptor_InputEventChannel* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_InputEventChannel>(Arena*);
template<> ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig>(Arena*);
template<> ::HU::ChannelDescriptor_InputStreamChannel* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_InputStreamChannel>(Arena*);
template<> ::HU::ChannelDescriptor_NavigationStatusService* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_NavigationStatusService>(Arena*);
template<> ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_NavigationStatusService_ImageOptions>(Arena*);
template<> ::HU::ChannelDescriptor_OutputStreamChannel* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_OutputStreamChannel>(Arena*);
template<> ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig>(Arena*);
template<> ::HU::ChannelDescriptor_PhoneStatusService* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_PhoneStatusService>(Arena*);
template<> ::HU::ChannelDescriptor_SensorChannel* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_SensorChannel>(Arena*);
template<> ::HU::ChannelDescriptor_SensorChannel_Sensor* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_SensorChannel_Sensor>(Arena*);
template<> ::HU::ChannelDescriptor_VendorExtensionService* Arena::CreateMaybeMessage<::HU::ChannelDescriptor_VendorExtensionService>(Arena*);
template<> ::HU::ChannelOpenRequest* Arena::CreateMaybeMessage<::HU::ChannelOpenRequest>(Arena*);
template<> ::HU::ChannelOpenResponse* Arena::CreateMaybeMessage<::HU::ChannelOpenResponse>(Arena*);
template<> ::HU::GenericNotificationRequest* Arena::CreateMaybeMessage<::HU::GenericNotificationRequest>(Arena*);
template<> ::HU::GenericNotificationResponse* Arena::CreateMaybeMessage<::HU::GenericNotificationResponse>(Arena*);
template<> ::HU::InputEvent* Arena::CreateMaybeMessage<::HU::InputEvent>(Arena*);
template<> ::HU::MediaAck* Arena::CreateMaybeMessage<::HU::MediaAck>(Arena*);
template<> ::HU::MediaSetupRequest* Arena::CreateMaybeMessage<::HU::MediaSetupRequest>(Arena*);
template<> ::HU::MediaSetupResponse* Arena::CreateMaybeMessage<::HU::MediaSetupResponse>(Arena*);
template<> ::HU::MediaStartRequest* Arena::CreateMaybeMessage<::HU::MediaStartRequest>(Arena*);
template<> ::HU::MediaStopRequest* Arena::CreateMaybeMessage<::HU::MediaStopRequest>(Arena*);
template<> ::HU::MicRequest* Arena::CreateMaybeMessage<::HU::MicRequest>(Arena*);
template<> ::HU::MicResponse* Arena::CreateMaybeMessage<::HU::MicResponse>(Arena*);
template<> ::HU::NAVDistanceMessage* Arena::CreateMaybeMessage<::HU::NAVDistanceMessage>(Arena*);
template<> ::HU::NAVMessagesStatus* Arena::CreateMaybeMessage<::HU::NAVMessagesStatus>(Arena*);
template<> ::HU::NAVTurnMessage* Arena::CreateMaybeMessage<::HU::NAVTurnMessage>(Arena*);
template<> ::HU::NavigationFocusRequest* Arena::CreateMaybeMessage<::HU::NavigationFocusRequest>(Arena*);
template<> ::HU::NavigationFocusResponse* Arena::CreateMaybeMessage<::HU::NavigationFocusResponse>(Arena*);
template<> ::HU::PhoneStatus* Arena::CreateMaybeMessage<::HU::PhoneStatus>(Arena*);
template<> ::HU::PhoneStatusInput* Arena::CreateMaybeMessage<::HU::PhoneStatusInput>(Arena*);
template<> ::HU::PhoneStatus_Call* Arena::CreateMaybeMessage<::HU::PhoneStatus_Call>(Arena*);
template<> ::HU::PingRequest* Arena::CreateMaybeMessage<::HU::PingRequest>(Arena*);
template<> ::HU::PingResponse* Arena::CreateMaybeMessage<::HU::PingResponse>(Arena*);
template<> ::HU::RelativeInputEvent* Arena::CreateMaybeMessage<::HU::RelativeInputEvent>(Arena*);
template<> ::HU::RelativeInputEventWrapper* Arena::CreateMaybeMessage<::HU::RelativeInputEventWrapper>(Arena*);
template<> ::HU::SensorEvent* Arena::CreateMaybeMessage<::HU::SensorEvent>(Arena*);
template<> ::HU::SensorEvent_Accel* Arena::CreateMaybeMessage<::HU::SensorEvent_Accel>(Arena*);
template<> ::HU::SensorEvent_CompassData* Arena::CreateMaybeMessage<::HU::SensorEvent_CompassData>(Arena*);
template<> ::HU::SensorEvent_DeadReckoning* Arena::CreateMaybeMessage<::HU::SensorEvent_DeadReckoning>(Arena*);
template<> ::HU::SensorEvent_Diagnostics* Arena::CreateMaybeMessage<::HU::SensorEvent_Diagnostics>(Arena*);
template<> ::HU::SensorEvent_Door* Arena::CreateMaybeMessage<::HU::SensorEvent_Door>(Arena*);
template<> ::HU::SensorEvent_DrivingStatus* Arena::CreateMaybeMessage<::HU::SensorEvent_DrivingStatus>(Arena*);
template<> ::HU::SensorEvent_Environment* Arena::CreateMaybeMessage<::HU::SensorEvent_Environment>(Arena*);
template<> ::HU::SensorEvent_FuelLevel* Arena::CreateMaybeMessage<::HU::SensorEvent_FuelLevel>(Arena*);
template<> ::HU::SensorEvent_GearData* Arena::CreateMaybeMessage<::HU::SensorEvent_GearData>(Arena*);
template<> ::HU::SensorEvent_Gyro* Arena::CreateMaybeMessage<::HU::SensorEvent_Gyro>(Arena*);
template<> ::HU::SensorEvent_HVAC* Arena::CreateMaybeMessage<::HU::SensorEvent_HVAC>(Arena*);
template<> ::HU::SensorEvent_Light* Arena::CreateMaybeMessage<::HU::SensorEvent_Light>(Arena*);
template<> ::HU::SensorEvent_LocationData* Arena::CreateMaybeMessage<::HU::SensorEvent_LocationData>(Arena*);
template<> ::HU::SensorEvent_NightMode* Arena::CreateMaybeMessage<::HU::SensorEvent_NightMode>(Arena*);
template<> ::HU::SensorEvent_OdometerData* Arena::CreateMaybeMessage<::HU::SensorEvent_OdometerData>(Arena*);
template<> ::HU::SensorEvent_ParkingBreak* Arena::CreateMaybeMessage<::HU::SensorEvent_ParkingBreak>(Arena*);
template<> ::HU::SensorEvent_Passenger* Arena::CreateMaybeMessage<::HU::SensorEvent_Passenger>(Arena*);
template<> ::HU::SensorEvent_RPM* Arena::CreateMaybeMessage<::HU::SensorEvent_RPM>(Arena*);
template<> ::HU::SensorEvent_SpeedData* Arena::CreateMaybeMessage<::HU::SensorEvent_SpeedData>(Arena*);
template<> ::HU::SensorStartRequest* Arena::CreateMaybeMessage<::HU::SensorStartRequest>(Arena*);
template<> ::HU::SensorStartResponse* Arena::CreateMaybeMessage<::HU::SensorStartResponse>(Arena*);
template<> ::HU::ServiceDiscoveryRequest* Arena::CreateMaybeMessage<::HU::ServiceDiscoveryRequest>(Arena*);
template<> ::HU::ServiceDiscoveryResponse* Arena::CreateMaybeMessage<::HU::ServiceDiscoveryResponse>(Arena*);
template<> ::HU::ShutdownRequest* Arena::CreateMaybeMessage<::HU::ShutdownRequest>(Arena*);
template<> ::HU::ShutdownResponse* Arena::CreateMaybeMessage<::HU::ShutdownResponse>(Arena*);
template<> ::HU::StartGenericNotifications* Arena::CreateMaybeMessage<::HU::StartGenericNotifications>(Arena*);
template<> ::HU::StopGenericNotifications* Arena::CreateMaybeMessage<::HU::StopGenericNotifications>(Arena*);
template<> ::HU::TouchInfo* Arena::CreateMaybeMessage<::HU::TouchInfo>(Arena*);
template<> ::HU::TouchInfo_Location* Arena::CreateMaybeMessage<::HU::TouchInfo_Location>(Arena*);
template<> ::HU::VideoFocus* Arena::CreateMaybeMessage<::HU::VideoFocus>(Arena*);
template<> ::HU::VideoFocusRequest* Arena::CreateMaybeMessage<::HU::VideoFocusRequest>(Arena*);
template<> ::HU::VoiceSessionRequest* Arena::CreateMaybeMessage<::HU::VoiceSessionRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace HU {

enum TouchInfo_TOUCH_ACTION : int {
  TouchInfo_TOUCH_ACTION_TOUCH_ACTION_PRESS = 0,
  TouchInfo_TOUCH_ACTION_TOUCH_ACTION_RELEASE = 1,
  TouchInfo_TOUCH_ACTION_TOUCH_ACTION_DRAG = 2
};
bool TouchInfo_TOUCH_ACTION_IsValid(int value);
constexpr TouchInfo_TOUCH_ACTION TouchInfo_TOUCH_ACTION_TOUCH_ACTION_MIN = TouchInfo_TOUCH_ACTION_TOUCH_ACTION_PRESS;
constexpr TouchInfo_TOUCH_ACTION TouchInfo_TOUCH_ACTION_TOUCH_ACTION_MAX = TouchInfo_TOUCH_ACTION_TOUCH_ACTION_DRAG;
constexpr int TouchInfo_TOUCH_ACTION_TOUCH_ACTION_ARRAYSIZE = TouchInfo_TOUCH_ACTION_TOUCH_ACTION_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TouchInfo_TOUCH_ACTION_descriptor();
template<typename T>
inline const std::string& TouchInfo_TOUCH_ACTION_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TouchInfo_TOUCH_ACTION>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TouchInfo_TOUCH_ACTION_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TouchInfo_TOUCH_ACTION_descriptor(), enum_t_value);
}
inline bool TouchInfo_TOUCH_ACTION_Parse(
    const std::string& name, TouchInfo_TOUCH_ACTION* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TouchInfo_TOUCH_ACTION>(
    TouchInfo_TOUCH_ACTION_descriptor(), name, value);
}
enum SensorEvent_DrivingStatus_STATUS : int {
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_FULLY_RESTRICTED = 31,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_LIMIT_MESSAGE_LEN = 16,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_CONFIG = 8,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_KEYBOARD_INPUT = 2,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_VIDEO = 1,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_VOICE_INPUT = 4,
  SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_UNRESTRICTED = 0
};
bool SensorEvent_DrivingStatus_STATUS_IsValid(int value);
constexpr SensorEvent_DrivingStatus_STATUS SensorEvent_DrivingStatus_STATUS_STATUS_MIN = SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_UNRESTRICTED;
constexpr SensorEvent_DrivingStatus_STATUS SensorEvent_DrivingStatus_STATUS_STATUS_MAX = SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_FULLY_RESTRICTED;
constexpr int SensorEvent_DrivingStatus_STATUS_STATUS_ARRAYSIZE = SensorEvent_DrivingStatus_STATUS_STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorEvent_DrivingStatus_STATUS_descriptor();
template<typename T>
inline const std::string& SensorEvent_DrivingStatus_STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorEvent_DrivingStatus_STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorEvent_DrivingStatus_STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorEvent_DrivingStatus_STATUS_descriptor(), enum_t_value);
}
inline bool SensorEvent_DrivingStatus_STATUS_Parse(
    const std::string& name, SensorEvent_DrivingStatus_STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorEvent_DrivingStatus_STATUS>(
    SensorEvent_DrivingStatus_STATUS_descriptor(), name, value);
}
enum SensorEvent_Light_HEADLIGHT_STATE : int {
  SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_0 = 0,
  SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_1 = 1,
  SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_2 = 2,
  SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_3 = 3
};
bool SensorEvent_Light_HEADLIGHT_STATE_IsValid(int value);
constexpr SensorEvent_Light_HEADLIGHT_STATE SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_MIN = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_0;
constexpr SensorEvent_Light_HEADLIGHT_STATE SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_MAX = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_3;
constexpr int SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_ARRAYSIZE = SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorEvent_Light_HEADLIGHT_STATE_descriptor();
template<typename T>
inline const std::string& SensorEvent_Light_HEADLIGHT_STATE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorEvent_Light_HEADLIGHT_STATE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorEvent_Light_HEADLIGHT_STATE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorEvent_Light_HEADLIGHT_STATE_descriptor(), enum_t_value);
}
inline bool SensorEvent_Light_HEADLIGHT_STATE_Parse(
    const std::string& name, SensorEvent_Light_HEADLIGHT_STATE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorEvent_Light_HEADLIGHT_STATE>(
    SensorEvent_Light_HEADLIGHT_STATE_descriptor(), name, value);
}
enum SensorEvent_Light_TURN_INDICATOR_STATE : int {
  SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_0 = 0,
  SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_1 = 1,
  SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_2 = 2,
  SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_3 = 3
};
bool SensorEvent_Light_TURN_INDICATOR_STATE_IsValid(int value);
constexpr SensorEvent_Light_TURN_INDICATOR_STATE SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_MIN = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_0;
constexpr SensorEvent_Light_TURN_INDICATOR_STATE SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_MAX = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_3;
constexpr int SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_ARRAYSIZE = SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorEvent_Light_TURN_INDICATOR_STATE_descriptor();
template<typename T>
inline const std::string& SensorEvent_Light_TURN_INDICATOR_STATE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorEvent_Light_TURN_INDICATOR_STATE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorEvent_Light_TURN_INDICATOR_STATE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorEvent_Light_TURN_INDICATOR_STATE_descriptor(), enum_t_value);
}
inline bool SensorEvent_Light_TURN_INDICATOR_STATE_Parse(
    const std::string& name, SensorEvent_Light_TURN_INDICATOR_STATE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorEvent_Light_TURN_INDICATOR_STATE>(
    SensorEvent_Light_TURN_INDICATOR_STATE_descriptor(), name, value);
}
enum SensorEvent_GearData_GEAR : int {
  SensorEvent_GearData_GEAR_GEAR_DRIVE = 100,
  SensorEvent_GearData_GEAR_GEAR_EIGHTH = 8,
  SensorEvent_GearData_GEAR_GEAR_FIFTH = 5,
  SensorEvent_GearData_GEAR_GEAR_FIRST = 1,
  SensorEvent_GearData_GEAR_GEAR_FOURTH = 4,
  SensorEvent_GearData_GEAR_GEAR_NEUTRAL = 0,
  SensorEvent_GearData_GEAR_GEAR_NINTH = 9,
  SensorEvent_GearData_GEAR_GEAR_PARK = 101,
  SensorEvent_GearData_GEAR_GEAR_REVERSE = 102,
  SensorEvent_GearData_GEAR_GEAR_SECOND = 2,
  SensorEvent_GearData_GEAR_GEAR_SEVENTH = 7,
  SensorEvent_GearData_GEAR_GEAR_SIXTH = 6,
  SensorEvent_GearData_GEAR_GEAR_TENTH = 10,
  SensorEvent_GearData_GEAR_GEAR_THIRD = 3
};
bool SensorEvent_GearData_GEAR_IsValid(int value);
constexpr SensorEvent_GearData_GEAR SensorEvent_GearData_GEAR_GEAR_MIN = SensorEvent_GearData_GEAR_GEAR_NEUTRAL;
constexpr SensorEvent_GearData_GEAR SensorEvent_GearData_GEAR_GEAR_MAX = SensorEvent_GearData_GEAR_GEAR_REVERSE;
constexpr int SensorEvent_GearData_GEAR_GEAR_ARRAYSIZE = SensorEvent_GearData_GEAR_GEAR_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorEvent_GearData_GEAR_descriptor();
template<typename T>
inline const std::string& SensorEvent_GearData_GEAR_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorEvent_GearData_GEAR>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorEvent_GearData_GEAR_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorEvent_GearData_GEAR_descriptor(), enum_t_value);
}
inline bool SensorEvent_GearData_GEAR_Parse(
    const std::string& name, SensorEvent_GearData_GEAR* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorEvent_GearData_GEAR>(
    SensorEvent_GearData_GEAR_descriptor(), name, value);
}
enum ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION : int {
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_800x480 = 1,
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_1280x720 = 2,
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_1920x1080 = 3
};
bool ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_IsValid(int value);
constexpr ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_MIN = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_800x480;
constexpr ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_MAX = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_1920x1080;
constexpr int ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_ARRAYSIZE = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor();
template<typename T>
inline const std::string& ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor(), enum_t_value);
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Parse(
    const std::string& name, ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>(
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor(), name, value);
}
enum ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS : int {
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_30 = 1,
  ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_60 = 2
};
bool ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_IsValid(int value);
constexpr ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_MIN = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_30;
constexpr ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_MAX = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_60;
constexpr int ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_ARRAYSIZE = ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor();
template<typename T>
inline const std::string& ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor(), enum_t_value);
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Parse(
    const std::string& name, ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>(
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor(), name, value);
}
enum ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE : int {
  ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CUSTOM_IMAGES_SUPPORTED = 1,
  ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IMAGE_CODES_ONLY = 2
};
bool ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IsValid(int value);
constexpr ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_MIN = ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CUSTOM_IMAGES_SUPPORTED;
constexpr ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_MAX = ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IMAGE_CODES_ONLY;
constexpr int ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_ARRAYSIZE = ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor();
template<typename T>
inline const std::string& ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor(), enum_t_value);
}
inline bool ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Parse(
    const std::string& name, ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>(
    ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor(), name, value);
}
enum ShutdownRequest_REASON : int {
  ShutdownRequest_REASON_REASON_QUIT = 1
};
bool ShutdownRequest_REASON_IsValid(int value);
constexpr ShutdownRequest_REASON ShutdownRequest_REASON_REASON_MIN = ShutdownRequest_REASON_REASON_QUIT;
constexpr ShutdownRequest_REASON ShutdownRequest_REASON_REASON_MAX = ShutdownRequest_REASON_REASON_QUIT;
constexpr int ShutdownRequest_REASON_REASON_ARRAYSIZE = ShutdownRequest_REASON_REASON_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShutdownRequest_REASON_descriptor();
template<typename T>
inline const std::string& ShutdownRequest_REASON_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShutdownRequest_REASON>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShutdownRequest_REASON_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShutdownRequest_REASON_descriptor(), enum_t_value);
}
inline bool ShutdownRequest_REASON_Parse(
    const std::string& name, ShutdownRequest_REASON* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShutdownRequest_REASON>(
    ShutdownRequest_REASON_descriptor(), name, value);
}
enum MediaSetupResponse_MEDIA_STATUS : int {
  MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_1 = 1,
  MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_2 = 2
};
bool MediaSetupResponse_MEDIA_STATUS_IsValid(int value);
constexpr MediaSetupResponse_MEDIA_STATUS MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_MIN = MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_1;
constexpr MediaSetupResponse_MEDIA_STATUS MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_MAX = MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_2;
constexpr int MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_ARRAYSIZE = MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MediaSetupResponse_MEDIA_STATUS_descriptor();
template<typename T>
inline const std::string& MediaSetupResponse_MEDIA_STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MediaSetupResponse_MEDIA_STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MediaSetupResponse_MEDIA_STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MediaSetupResponse_MEDIA_STATUS_descriptor(), enum_t_value);
}
inline bool MediaSetupResponse_MEDIA_STATUS_Parse(
    const std::string& name, MediaSetupResponse_MEDIA_STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MediaSetupResponse_MEDIA_STATUS>(
    MediaSetupResponse_MEDIA_STATUS_descriptor(), name, value);
}
enum VoiceSessionRequest_VOICE_STATUS : int {
  VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_START = 1,
  VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_STOP = 2
};
bool VoiceSessionRequest_VOICE_STATUS_IsValid(int value);
constexpr VoiceSessionRequest_VOICE_STATUS VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_MIN = VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_START;
constexpr VoiceSessionRequest_VOICE_STATUS VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_MAX = VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_STOP;
constexpr int VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_ARRAYSIZE = VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceSessionRequest_VOICE_STATUS_descriptor();
template<typename T>
inline const std::string& VoiceSessionRequest_VOICE_STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VoiceSessionRequest_VOICE_STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VoiceSessionRequest_VOICE_STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VoiceSessionRequest_VOICE_STATUS_descriptor(), enum_t_value);
}
inline bool VoiceSessionRequest_VOICE_STATUS_Parse(
    const std::string& name, VoiceSessionRequest_VOICE_STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VoiceSessionRequest_VOICE_STATUS>(
    VoiceSessionRequest_VOICE_STATUS_descriptor(), name, value);
}
enum AudioFocusRequest_AUDIO_FOCUS : int {
  AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN = 1,
  AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN_TRANSIENT = 2,
  AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN_NAVI = 3,
  AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_RELEASE = 4
};
bool AudioFocusRequest_AUDIO_FOCUS_IsValid(int value);
constexpr AudioFocusRequest_AUDIO_FOCUS AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_MIN = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN;
constexpr AudioFocusRequest_AUDIO_FOCUS AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_MAX = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_RELEASE;
constexpr int AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_ARRAYSIZE = AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioFocusRequest_AUDIO_FOCUS_descriptor();
template<typename T>
inline const std::string& AudioFocusRequest_AUDIO_FOCUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioFocusRequest_AUDIO_FOCUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioFocusRequest_AUDIO_FOCUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioFocusRequest_AUDIO_FOCUS_descriptor(), enum_t_value);
}
inline bool AudioFocusRequest_AUDIO_FOCUS_Parse(
    const std::string& name, AudioFocusRequest_AUDIO_FOCUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioFocusRequest_AUDIO_FOCUS>(
    AudioFocusRequest_AUDIO_FOCUS_descriptor(), name, value);
}
enum AudioFocusResponse_AUDIO_FOCUS_STATE : int {
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN = 1,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_TRANSIENT = 2,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS = 3,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK = 4,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS_TRANSIENT = 5,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY = 6,
  AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY = 7
};
bool AudioFocusResponse_AUDIO_FOCUS_STATE_IsValid(int value);
constexpr AudioFocusResponse_AUDIO_FOCUS_STATE AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_MIN = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN;
constexpr AudioFocusResponse_AUDIO_FOCUS_STATE AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_MAX = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY;
constexpr int AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_ARRAYSIZE = AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor();
template<typename T>
inline const std::string& AudioFocusResponse_AUDIO_FOCUS_STATE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioFocusResponse_AUDIO_FOCUS_STATE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioFocusResponse_AUDIO_FOCUS_STATE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor(), enum_t_value);
}
inline bool AudioFocusResponse_AUDIO_FOCUS_STATE_Parse(
    const std::string& name, AudioFocusResponse_AUDIO_FOCUS_STATE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AudioFocusResponse_AUDIO_FOCUS_STATE>(
    AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor(), name, value);
}
enum PhoneStatus_PHONE_STATE : int {
  PhoneStatus_PHONE_STATE_PHONE_STATE_IN_CALL = 1,
  PhoneStatus_PHONE_STATE_PHONE_STATE_ON_HOLD = 2,
  PhoneStatus_PHONE_STATE_PHONE_STATE_HANGINGUP = 3,
  PhoneStatus_PHONE_STATE_PHONE_STATE_INCOMING = 4,
  PhoneStatus_PHONE_STATE_PHONE_STATE_UNKNOWN_5 = 5,
  PhoneStatus_PHONE_STATE_PHONE_STATE_UNKNOWN_6 = 6
};
bool PhoneStatus_PHONE_STATE_IsValid(int value);
constexpr PhoneStatus_PHONE_STATE PhoneStatus_PHONE_STATE_PHONE_STATE_MIN = PhoneStatus_PHONE_STATE_PHONE_STATE_IN_CALL;
constexpr PhoneStatus_PHONE_STATE PhoneStatus_PHONE_STATE_PHONE_STATE_MAX = PhoneStatus_PHONE_STATE_PHONE_STATE_UNKNOWN_6;
constexpr int PhoneStatus_PHONE_STATE_PHONE_STATE_ARRAYSIZE = PhoneStatus_PHONE_STATE_PHONE_STATE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PhoneStatus_PHONE_STATE_descriptor();
template<typename T>
inline const std::string& PhoneStatus_PHONE_STATE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PhoneStatus_PHONE_STATE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PhoneStatus_PHONE_STATE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PhoneStatus_PHONE_STATE_descriptor(), enum_t_value);
}
inline bool PhoneStatus_PHONE_STATE_Parse(
    const std::string& name, PhoneStatus_PHONE_STATE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PhoneStatus_PHONE_STATE>(
    PhoneStatus_PHONE_STATE_descriptor(), name, value);
}
enum BluetoothPairingResponse_PAIRING_STATUS : int {
  BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_1 = 1,
  BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_2 = 2
};
bool BluetoothPairingResponse_PAIRING_STATUS_IsValid(int value);
constexpr BluetoothPairingResponse_PAIRING_STATUS BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_MIN = BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_1;
constexpr BluetoothPairingResponse_PAIRING_STATUS BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_MAX = BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_2;
constexpr int BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_ARRAYSIZE = BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BluetoothPairingResponse_PAIRING_STATUS_descriptor();
template<typename T>
inline const std::string& BluetoothPairingResponse_PAIRING_STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BluetoothPairingResponse_PAIRING_STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BluetoothPairingResponse_PAIRING_STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BluetoothPairingResponse_PAIRING_STATUS_descriptor(), enum_t_value);
}
inline bool BluetoothPairingResponse_PAIRING_STATUS_Parse(
    const std::string& name, BluetoothPairingResponse_PAIRING_STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BluetoothPairingResponse_PAIRING_STATUS>(
    BluetoothPairingResponse_PAIRING_STATUS_descriptor(), name, value);
}
enum NAVMessagesStatus_STATUS : int {
  NAVMessagesStatus_STATUS_START = 1,
  NAVMessagesStatus_STATUS_STOP = 2
};
bool NAVMessagesStatus_STATUS_IsValid(int value);
constexpr NAVMessagesStatus_STATUS NAVMessagesStatus_STATUS_STATUS_MIN = NAVMessagesStatus_STATUS_START;
constexpr NAVMessagesStatus_STATUS NAVMessagesStatus_STATUS_STATUS_MAX = NAVMessagesStatus_STATUS_STOP;
constexpr int NAVMessagesStatus_STATUS_STATUS_ARRAYSIZE = NAVMessagesStatus_STATUS_STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NAVMessagesStatus_STATUS_descriptor();
template<typename T>
inline const std::string& NAVMessagesStatus_STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NAVMessagesStatus_STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NAVMessagesStatus_STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NAVMessagesStatus_STATUS_descriptor(), enum_t_value);
}
inline bool NAVMessagesStatus_STATUS_Parse(
    const std::string& name, NAVMessagesStatus_STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NAVMessagesStatus_STATUS>(
    NAVMessagesStatus_STATUS_descriptor(), name, value);
}
enum NAVTurnMessage_TURN_SIDE : int {
  NAVTurnMessage_TURN_SIDE_TURN_LEFT = 1,
  NAVTurnMessage_TURN_SIDE_TURN_RIGHT = 2,
  NAVTurnMessage_TURN_SIDE_TURN_UNSPECIFIED = 3
};
bool NAVTurnMessage_TURN_SIDE_IsValid(int value);
constexpr NAVTurnMessage_TURN_SIDE NAVTurnMessage_TURN_SIDE_TURN_SIDE_MIN = NAVTurnMessage_TURN_SIDE_TURN_LEFT;
constexpr NAVTurnMessage_TURN_SIDE NAVTurnMessage_TURN_SIDE_TURN_SIDE_MAX = NAVTurnMessage_TURN_SIDE_TURN_UNSPECIFIED;
constexpr int NAVTurnMessage_TURN_SIDE_TURN_SIDE_ARRAYSIZE = NAVTurnMessage_TURN_SIDE_TURN_SIDE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NAVTurnMessage_TURN_SIDE_descriptor();
template<typename T>
inline const std::string& NAVTurnMessage_TURN_SIDE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NAVTurnMessage_TURN_SIDE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NAVTurnMessage_TURN_SIDE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NAVTurnMessage_TURN_SIDE_descriptor(), enum_t_value);
}
inline bool NAVTurnMessage_TURN_SIDE_Parse(
    const std::string& name, NAVTurnMessage_TURN_SIDE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NAVTurnMessage_TURN_SIDE>(
    NAVTurnMessage_TURN_SIDE_descriptor(), name, value);
}
enum NAVTurnMessage_TURN_EVENT : int {
  NAVTurnMessage_TURN_EVENT_TURN_UNKNOWN = 0,
  NAVTurnMessage_TURN_EVENT_TURN_DEPART = 1,
  NAVTurnMessage_TURN_EVENT_TURN_NAME_CHANGE = 2,
  NAVTurnMessage_TURN_EVENT_TURN_SLIGHT_TURN = 3,
  NAVTurnMessage_TURN_EVENT_TURN_TURN = 4,
  NAVTurnMessage_TURN_EVENT_TURN_SHARP_TURN = 5,
  NAVTurnMessage_TURN_EVENT_TURN_U_TURN = 6,
  NAVTurnMessage_TURN_EVENT_TURN_ON_RAMP = 7,
  NAVTurnMessage_TURN_EVENT_TURN_OFF_RAMP = 8,
  NAVTurnMessage_TURN_EVENT_TURN_FORK = 9,
  NAVTurnMessage_TURN_EVENT_TURN_MERGE = 10,
  NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_ENTER = 11,
  NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_EXIT = 12,
  NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_ENTER_AND_EXIT = 13,
  NAVTurnMessage_TURN_EVENT_TURN_STRAIGHT = 14,
  NAVTurnMessage_TURN_EVENT_TURN_FERRY_BOAT = 16,
  NAVTurnMessage_TURN_EVENT_TURN_FERRY_TRAIN = 17,
  NAVTurnMessage_TURN_EVENT_TURN_DESTINATION = 19
};
bool NAVTurnMessage_TURN_EVENT_IsValid(int value);
constexpr NAVTurnMessage_TURN_EVENT NAVTurnMessage_TURN_EVENT_TURN_EVENT_MIN = NAVTurnMessage_TURN_EVENT_TURN_UNKNOWN;
constexpr NAVTurnMessage_TURN_EVENT NAVTurnMessage_TURN_EVENT_TURN_EVENT_MAX = NAVTurnMessage_TURN_EVENT_TURN_DESTINATION;
constexpr int NAVTurnMessage_TURN_EVENT_TURN_EVENT_ARRAYSIZE = NAVTurnMessage_TURN_EVENT_TURN_EVENT_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NAVTurnMessage_TURN_EVENT_descriptor();
template<typename T>
inline const std::string& NAVTurnMessage_TURN_EVENT_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NAVTurnMessage_TURN_EVENT>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NAVTurnMessage_TURN_EVENT_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NAVTurnMessage_TURN_EVENT_descriptor(), enum_t_value);
}
inline bool NAVTurnMessage_TURN_EVENT_Parse(
    const std::string& name, NAVTurnMessage_TURN_EVENT* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NAVTurnMessage_TURN_EVENT>(
    NAVTurnMessage_TURN_EVENT_descriptor(), name, value);
}
enum NAVDistanceMessage_DISPLAY_DISTANCE_UNIT : int {
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_METERS = 1,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_KILOMETERS10 = 2,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_KILOMETERS = 3,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_MILES10 = 4,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_MILES = 5,
  NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_FEET = 6
};
bool NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_IsValid(int value);
constexpr NAVDistanceMessage_DISPLAY_DISTANCE_UNIT NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_MIN = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_METERS;
constexpr NAVDistanceMessage_DISPLAY_DISTANCE_UNIT NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_MAX = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_FEET;
constexpr int NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_ARRAYSIZE = NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor();
template<typename T>
inline const std::string& NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor(), enum_t_value);
}
inline bool NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Parse(
    const std::string& name, NAVDistanceMessage_DISPLAY_DISTANCE_UNIT* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>(
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor(), name, value);
}
enum STATUS : int {
  STATUS_OK = 0
};
bool STATUS_IsValid(int value);
constexpr STATUS STATUS_MIN = STATUS_OK;
constexpr STATUS STATUS_MAX = STATUS_OK;
constexpr int STATUS_ARRAYSIZE = STATUS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* STATUS_descriptor();
template<typename T>
inline const std::string& STATUS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, STATUS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function STATUS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    STATUS_descriptor(), enum_t_value);
}
inline bool STATUS_Parse(
    const std::string& name, STATUS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<STATUS>(
    STATUS_descriptor(), name, value);
}
enum SENSOR_TYPE : int {
  SENSOR_TYPE_LOCATION = 1,
  SENSOR_TYPE_COMPASS = 2,
  SENSOR_TYPE_CAR_SPEED = 3,
  SENSOR_TYPE_RPM = 4,
  SENSOR_TYPE_ODOMETER = 5,
  SENSOR_TYPE_FUEL_LEVEL = 6,
  SENSOR_TYPE_PARKING_BRAKE = 7,
  SENSOR_TYPE_GEAR = 8,
  SENSOR_TYPE_DIAGNOSTICS = 9,
  SENSOR_TYPE_NIGHT_DATA = 10,
  SENSOR_TYPE_ENVIRONMENT = 11,
  SENSOR_TYPE_HVAC = 12,
  SENSOR_TYPE_DRIVING_STATUS = 13,
  SENSOR_TYPE_DEAD_RECONING = 14,
  SENSOR_TYPE_PASSENGER = 15,
  SENSOR_TYPE_DOOR = 16,
  SENSOR_TYPE_LIGHT = 17,
  SENSOR_TYPE_TIRE = 18,
  SENSOR_TYPE_ACCEL = 19,
  SENSOR_TYPE_GYRO = 20,
  SENSOR_TYPE_GPS = 21
};
bool SENSOR_TYPE_IsValid(int value);
constexpr SENSOR_TYPE SENSOR_TYPE_MIN = SENSOR_TYPE_LOCATION;
constexpr SENSOR_TYPE SENSOR_TYPE_MAX = SENSOR_TYPE_GPS;
constexpr int SENSOR_TYPE_ARRAYSIZE = SENSOR_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SENSOR_TYPE_descriptor();
template<typename T>
inline const std::string& SENSOR_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SENSOR_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SENSOR_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SENSOR_TYPE_descriptor(), enum_t_value);
}
inline bool SENSOR_TYPE_Parse(
    const std::string& name, SENSOR_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SENSOR_TYPE>(
    SENSOR_TYPE_descriptor(), name, value);
}
enum AUDIO_TYPE : int {
  AUDIO_TYPE_SPEECH = 1,
  AUDIO_TYPE_SYSTEM = 2,
  AUDIO_TYPE_MEDIA = 3,
  AUDIO_TYPE_ALARM = 4
};
bool AUDIO_TYPE_IsValid(int value);
constexpr AUDIO_TYPE AUDIO_TYPE_MIN = AUDIO_TYPE_SPEECH;
constexpr AUDIO_TYPE AUDIO_TYPE_MAX = AUDIO_TYPE_ALARM;
constexpr int AUDIO_TYPE_ARRAYSIZE = AUDIO_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AUDIO_TYPE_descriptor();
template<typename T>
inline const std::string& AUDIO_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AUDIO_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AUDIO_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AUDIO_TYPE_descriptor(), enum_t_value);
}
inline bool AUDIO_TYPE_Parse(
    const std::string& name, AUDIO_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AUDIO_TYPE>(
    AUDIO_TYPE_descriptor(), name, value);
}
enum STREAM_TYPE : int {
  STREAM_TYPE_AUDIO = 1,
  STREAM_TYPE_VIDEO = 3
};
bool STREAM_TYPE_IsValid(int value);
constexpr STREAM_TYPE STREAM_TYPE_MIN = STREAM_TYPE_AUDIO;
constexpr STREAM_TYPE STREAM_TYPE_MAX = STREAM_TYPE_VIDEO;
constexpr int STREAM_TYPE_ARRAYSIZE = STREAM_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* STREAM_TYPE_descriptor();
template<typename T>
inline const std::string& STREAM_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, STREAM_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function STREAM_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    STREAM_TYPE_descriptor(), enum_t_value);
}
inline bool STREAM_TYPE_Parse(
    const std::string& name, STREAM_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<STREAM_TYPE>(
    STREAM_TYPE_descriptor(), name, value);
}
enum BluetoothPairingMethod : int {
  BLUETOOTH_PARING_METHOD_1 = 1,
  BLUETOOTH_PARING_METHOD_A2DP = 2,
  BLUETOOTH_PARING_METHOD_3 = 3,
  BLUETOOTH_PARING_METHOD_HFP = 4
};
bool BluetoothPairingMethod_IsValid(int value);
constexpr BluetoothPairingMethod BluetoothPairingMethod_MIN = BLUETOOTH_PARING_METHOD_1;
constexpr BluetoothPairingMethod BluetoothPairingMethod_MAX = BLUETOOTH_PARING_METHOD_HFP;
constexpr int BluetoothPairingMethod_ARRAYSIZE = BluetoothPairingMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BluetoothPairingMethod_descriptor();
template<typename T>
inline const std::string& BluetoothPairingMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BluetoothPairingMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BluetoothPairingMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BluetoothPairingMethod_descriptor(), enum_t_value);
}
inline bool BluetoothPairingMethod_Parse(
    const std::string& name, BluetoothPairingMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BluetoothPairingMethod>(
    BluetoothPairingMethod_descriptor(), name, value);
}
enum VIDEO_FOCUS_MODE : int {
  VIDEO_FOCUS_MODE_FOCUSED = 1,
  VIDEO_FOCUS_MODE_UNFOCUSED = 2
};
bool VIDEO_FOCUS_MODE_IsValid(int value);
constexpr VIDEO_FOCUS_MODE VIDEO_FOCUS_MODE_MIN = VIDEO_FOCUS_MODE_FOCUSED;
constexpr VIDEO_FOCUS_MODE VIDEO_FOCUS_MODE_MAX = VIDEO_FOCUS_MODE_UNFOCUSED;
constexpr int VIDEO_FOCUS_MODE_ARRAYSIZE = VIDEO_FOCUS_MODE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VIDEO_FOCUS_MODE_descriptor();
template<typename T>
inline const std::string& VIDEO_FOCUS_MODE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VIDEO_FOCUS_MODE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VIDEO_FOCUS_MODE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VIDEO_FOCUS_MODE_descriptor(), enum_t_value);
}
inline bool VIDEO_FOCUS_MODE_Parse(
    const std::string& name, VIDEO_FOCUS_MODE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VIDEO_FOCUS_MODE>(
    VIDEO_FOCUS_MODE_descriptor(), name, value);
}
enum VIDEO_FOCUS_REASON : int {
  VIDEO_FOCUS_REASON_1 = 1,
  VIDEO_FOCUS_REASON_2 = 2
};
bool VIDEO_FOCUS_REASON_IsValid(int value);
constexpr VIDEO_FOCUS_REASON VIDEO_FOCUS_REASON_MIN = VIDEO_FOCUS_REASON_1;
constexpr VIDEO_FOCUS_REASON VIDEO_FOCUS_REASON_MAX = VIDEO_FOCUS_REASON_2;
constexpr int VIDEO_FOCUS_REASON_ARRAYSIZE = VIDEO_FOCUS_REASON_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VIDEO_FOCUS_REASON_descriptor();
template<typename T>
inline const std::string& VIDEO_FOCUS_REASON_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VIDEO_FOCUS_REASON>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VIDEO_FOCUS_REASON_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VIDEO_FOCUS_REASON_descriptor(), enum_t_value);
}
inline bool VIDEO_FOCUS_REASON_Parse(
    const std::string& name, VIDEO_FOCUS_REASON* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VIDEO_FOCUS_REASON>(
    VIDEO_FOCUS_REASON_descriptor(), name, value);
}
// ===================================================================

class ButtonInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ButtonInfo) */ {
 public:
  inline ButtonInfo() : ButtonInfo(nullptr) {};
  virtual ~ButtonInfo();

  ButtonInfo(const ButtonInfo& from);
  ButtonInfo(ButtonInfo&& from) noexcept
    : ButtonInfo() {
    *this = ::std::move(from);
  }

  inline ButtonInfo& operator=(const ButtonInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonInfo& operator=(ButtonInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ButtonInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ButtonInfo* internal_default_instance() {
    return reinterpret_cast<const ButtonInfo*>(
               &_ButtonInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ButtonInfo& a, ButtonInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ButtonInfo* New() const final {
    return CreateMaybeMessage<ButtonInfo>(nullptr);
  }

  ButtonInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ButtonInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ButtonInfo& from);
  void MergeFrom(const ButtonInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ButtonInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ButtonInfo";
  }
  protected:
  explicit ButtonInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScanCodeFieldNumber = 1,
    kMetaFieldNumber = 3,
    kIsPressedFieldNumber = 2,
    kLongPressFieldNumber = 4,
  };
  // required uint32 scan_code = 1;
  bool has_scan_code() const;
  private:
  bool _internal_has_scan_code() const;
  public:
  void clear_scan_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 scan_code() const;
  void set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_scan_code() const;
  void _internal_set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 meta = 3;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  ::PROTOBUF_NAMESPACE_ID::uint32 meta() const;
  void set_meta(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_meta() const;
  void _internal_set_meta(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required bool is_pressed = 2;
  bool has_is_pressed() const;
  private:
  bool _internal_has_is_pressed() const;
  public:
  void clear_is_pressed();
  bool is_pressed() const;
  void set_is_pressed(bool value);
  private:
  bool _internal_is_pressed() const;
  void _internal_set_is_pressed(bool value);
  public:

  // required bool long_press = 4;
  bool has_long_press() const;
  private:
  bool _internal_has_long_press() const;
  public:
  void clear_long_press();
  bool long_press() const;
  void set_long_press(bool value);
  private:
  bool _internal_long_press() const;
  void _internal_set_long_press(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ButtonInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 scan_code_;
  ::PROTOBUF_NAMESPACE_ID::uint32 meta_;
  bool is_pressed_;
  bool long_press_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ButtonInfoWrapper PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ButtonInfoWrapper) */ {
 public:
  inline ButtonInfoWrapper() : ButtonInfoWrapper(nullptr) {};
  virtual ~ButtonInfoWrapper();

  ButtonInfoWrapper(const ButtonInfoWrapper& from);
  ButtonInfoWrapper(ButtonInfoWrapper&& from) noexcept
    : ButtonInfoWrapper() {
    *this = ::std::move(from);
  }

  inline ButtonInfoWrapper& operator=(const ButtonInfoWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline ButtonInfoWrapper& operator=(ButtonInfoWrapper&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ButtonInfoWrapper& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ButtonInfoWrapper* internal_default_instance() {
    return reinterpret_cast<const ButtonInfoWrapper*>(
               &_ButtonInfoWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ButtonInfoWrapper& a, ButtonInfoWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(ButtonInfoWrapper* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ButtonInfoWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ButtonInfoWrapper* New() const final {
    return CreateMaybeMessage<ButtonInfoWrapper>(nullptr);
  }

  ButtonInfoWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ButtonInfoWrapper>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ButtonInfoWrapper& from);
  void MergeFrom(const ButtonInfoWrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ButtonInfoWrapper* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ButtonInfoWrapper";
  }
  protected:
  explicit ButtonInfoWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kButtonFieldNumber = 1,
  };
  // repeated .HU.ButtonInfo button = 1;
  int button_size() const;
  private:
  int _internal_button_size() const;
  public:
  void clear_button();
  ::HU::ButtonInfo* mutable_button(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ButtonInfo >*
      mutable_button();
  private:
  const ::HU::ButtonInfo& _internal_button(int index) const;
  ::HU::ButtonInfo* _internal_add_button();
  public:
  const ::HU::ButtonInfo& button(int index) const;
  ::HU::ButtonInfo* add_button();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ButtonInfo >&
      button() const;

  // @@protoc_insertion_point(class_scope:HU.ButtonInfoWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ButtonInfo > button_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class TouchInfo_Location PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.TouchInfo.Location) */ {
 public:
  inline TouchInfo_Location() : TouchInfo_Location(nullptr) {};
  virtual ~TouchInfo_Location();

  TouchInfo_Location(const TouchInfo_Location& from);
  TouchInfo_Location(TouchInfo_Location&& from) noexcept
    : TouchInfo_Location() {
    *this = ::std::move(from);
  }

  inline TouchInfo_Location& operator=(const TouchInfo_Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline TouchInfo_Location& operator=(TouchInfo_Location&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TouchInfo_Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TouchInfo_Location* internal_default_instance() {
    return reinterpret_cast<const TouchInfo_Location*>(
               &_TouchInfo_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TouchInfo_Location& a, TouchInfo_Location& b) {
    a.Swap(&b);
  }
  inline void Swap(TouchInfo_Location* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TouchInfo_Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TouchInfo_Location* New() const final {
    return CreateMaybeMessage<TouchInfo_Location>(nullptr);
  }

  TouchInfo_Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TouchInfo_Location>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TouchInfo_Location& from);
  void MergeFrom(const TouchInfo_Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchInfo_Location* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.TouchInfo.Location";
  }
  protected:
  explicit TouchInfo_Location(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kPointerIdFieldNumber = 3,
  };
  // required uint32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::uint32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::uint32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 pointer_id = 3;
  bool has_pointer_id() const;
  private:
  bool _internal_has_pointer_id() const;
  public:
  void clear_pointer_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 pointer_id() const;
  void set_pointer_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_pointer_id() const;
  void _internal_set_pointer_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.TouchInfo.Location)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 x_;
  ::PROTOBUF_NAMESPACE_ID::uint32 y_;
  ::PROTOBUF_NAMESPACE_ID::uint32 pointer_id_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class TouchInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.TouchInfo) */ {
 public:
  inline TouchInfo() : TouchInfo(nullptr) {};
  virtual ~TouchInfo();

  TouchInfo(const TouchInfo& from);
  TouchInfo(TouchInfo&& from) noexcept
    : TouchInfo() {
    *this = ::std::move(from);
  }

  inline TouchInfo& operator=(const TouchInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TouchInfo& operator=(TouchInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TouchInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TouchInfo* internal_default_instance() {
    return reinterpret_cast<const TouchInfo*>(
               &_TouchInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TouchInfo& a, TouchInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TouchInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TouchInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TouchInfo* New() const final {
    return CreateMaybeMessage<TouchInfo>(nullptr);
  }

  TouchInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TouchInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TouchInfo& from);
  void MergeFrom(const TouchInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.TouchInfo";
  }
  protected:
  explicit TouchInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TouchInfo_Location Location;

  typedef TouchInfo_TOUCH_ACTION TOUCH_ACTION;
  static constexpr TOUCH_ACTION TOUCH_ACTION_PRESS =
    TouchInfo_TOUCH_ACTION_TOUCH_ACTION_PRESS;
  static constexpr TOUCH_ACTION TOUCH_ACTION_RELEASE =
    TouchInfo_TOUCH_ACTION_TOUCH_ACTION_RELEASE;
  static constexpr TOUCH_ACTION TOUCH_ACTION_DRAG =
    TouchInfo_TOUCH_ACTION_TOUCH_ACTION_DRAG;
  static inline bool TOUCH_ACTION_IsValid(int value) {
    return TouchInfo_TOUCH_ACTION_IsValid(value);
  }
  static constexpr TOUCH_ACTION TOUCH_ACTION_MIN =
    TouchInfo_TOUCH_ACTION_TOUCH_ACTION_MIN;
  static constexpr TOUCH_ACTION TOUCH_ACTION_MAX =
    TouchInfo_TOUCH_ACTION_TOUCH_ACTION_MAX;
  static constexpr int TOUCH_ACTION_ARRAYSIZE =
    TouchInfo_TOUCH_ACTION_TOUCH_ACTION_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TOUCH_ACTION_descriptor() {
    return TouchInfo_TOUCH_ACTION_descriptor();
  }
  template<typename T>
  static inline const std::string& TOUCH_ACTION_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TOUCH_ACTION>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TOUCH_ACTION_Name.");
    return TouchInfo_TOUCH_ACTION_Name(enum_t_value);
  }
  static inline bool TOUCH_ACTION_Parse(const std::string& name,
      TOUCH_ACTION* value) {
    return TouchInfo_TOUCH_ACTION_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kActionIndexFieldNumber = 2,
    kActionFieldNumber = 3,
  };
  // repeated .HU.TouchInfo.Location location = 1;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  ::HU::TouchInfo_Location* mutable_location(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::TouchInfo_Location >*
      mutable_location();
  private:
  const ::HU::TouchInfo_Location& _internal_location(int index) const;
  ::HU::TouchInfo_Location* _internal_add_location();
  public:
  const ::HU::TouchInfo_Location& location(int index) const;
  ::HU::TouchInfo_Location* add_location();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::TouchInfo_Location >&
      location() const;

  // optional uint32 action_index = 2;
  bool has_action_index() const;
  private:
  bool _internal_has_action_index() const;
  public:
  void clear_action_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 action_index() const;
  void set_action_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_action_index() const;
  void _internal_set_action_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .HU.TouchInfo.TOUCH_ACTION action = 3;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::HU::TouchInfo_TOUCH_ACTION action() const;
  void set_action(::HU::TouchInfo_TOUCH_ACTION value);
  private:
  ::HU::TouchInfo_TOUCH_ACTION _internal_action() const;
  void _internal_set_action(::HU::TouchInfo_TOUCH_ACTION value);
  public:

  // @@protoc_insertion_point(class_scope:HU.TouchInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::TouchInfo_Location > location_;
  ::PROTOBUF_NAMESPACE_ID::uint32 action_index_;
  int action_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class RelativeInputEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.RelativeInputEvent) */ {
 public:
  inline RelativeInputEvent() : RelativeInputEvent(nullptr) {};
  virtual ~RelativeInputEvent();

  RelativeInputEvent(const RelativeInputEvent& from);
  RelativeInputEvent(RelativeInputEvent&& from) noexcept
    : RelativeInputEvent() {
    *this = ::std::move(from);
  }

  inline RelativeInputEvent& operator=(const RelativeInputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelativeInputEvent& operator=(RelativeInputEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RelativeInputEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelativeInputEvent* internal_default_instance() {
    return reinterpret_cast<const RelativeInputEvent*>(
               &_RelativeInputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RelativeInputEvent& a, RelativeInputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RelativeInputEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelativeInputEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelativeInputEvent* New() const final {
    return CreateMaybeMessage<RelativeInputEvent>(nullptr);
  }

  RelativeInputEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelativeInputEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RelativeInputEvent& from);
  void MergeFrom(const RelativeInputEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelativeInputEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.RelativeInputEvent";
  }
  protected:
  explicit RelativeInputEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScanCodeFieldNumber = 1,
    kDeltaFieldNumber = 2,
  };
  // optional uint32 scan_code = 1;
  bool has_scan_code() const;
  private:
  bool _internal_has_scan_code() const;
  public:
  void clear_scan_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 scan_code() const;
  void set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_scan_code() const;
  void _internal_set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 delta = 2;
  bool has_delta() const;
  private:
  bool _internal_has_delta() const;
  public:
  void clear_delta();
  ::PROTOBUF_NAMESPACE_ID::int32 delta() const;
  void set_delta(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_delta() const;
  void _internal_set_delta(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.RelativeInputEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 scan_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 delta_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class AbsoluteInputEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.AbsoluteInputEvent) */ {
 public:
  inline AbsoluteInputEvent() : AbsoluteInputEvent(nullptr) {};
  virtual ~AbsoluteInputEvent();

  AbsoluteInputEvent(const AbsoluteInputEvent& from);
  AbsoluteInputEvent(AbsoluteInputEvent&& from) noexcept
    : AbsoluteInputEvent() {
    *this = ::std::move(from);
  }

  inline AbsoluteInputEvent& operator=(const AbsoluteInputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbsoluteInputEvent& operator=(AbsoluteInputEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AbsoluteInputEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbsoluteInputEvent* internal_default_instance() {
    return reinterpret_cast<const AbsoluteInputEvent*>(
               &_AbsoluteInputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AbsoluteInputEvent& a, AbsoluteInputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AbsoluteInputEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbsoluteInputEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AbsoluteInputEvent* New() const final {
    return CreateMaybeMessage<AbsoluteInputEvent>(nullptr);
  }

  AbsoluteInputEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AbsoluteInputEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AbsoluteInputEvent& from);
  void MergeFrom(const AbsoluteInputEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbsoluteInputEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.AbsoluteInputEvent";
  }
  protected:
  explicit AbsoluteInputEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScanCodeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional uint32 scan_code = 1;
  bool has_scan_code() const;
  private:
  bool _internal_has_scan_code() const;
  public:
  void clear_scan_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 scan_code() const;
  void set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_scan_code() const;
  void _internal_set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.AbsoluteInputEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 scan_code_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class AbsoluteInputEventWrapper PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.AbsoluteInputEventWrapper) */ {
 public:
  inline AbsoluteInputEventWrapper() : AbsoluteInputEventWrapper(nullptr) {};
  virtual ~AbsoluteInputEventWrapper();

  AbsoluteInputEventWrapper(const AbsoluteInputEventWrapper& from);
  AbsoluteInputEventWrapper(AbsoluteInputEventWrapper&& from) noexcept
    : AbsoluteInputEventWrapper() {
    *this = ::std::move(from);
  }

  inline AbsoluteInputEventWrapper& operator=(const AbsoluteInputEventWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbsoluteInputEventWrapper& operator=(AbsoluteInputEventWrapper&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AbsoluteInputEventWrapper& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbsoluteInputEventWrapper* internal_default_instance() {
    return reinterpret_cast<const AbsoluteInputEventWrapper*>(
               &_AbsoluteInputEventWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AbsoluteInputEventWrapper& a, AbsoluteInputEventWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(AbsoluteInputEventWrapper* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbsoluteInputEventWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AbsoluteInputEventWrapper* New() const final {
    return CreateMaybeMessage<AbsoluteInputEventWrapper>(nullptr);
  }

  AbsoluteInputEventWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AbsoluteInputEventWrapper>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AbsoluteInputEventWrapper& from);
  void MergeFrom(const AbsoluteInputEventWrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbsoluteInputEventWrapper* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.AbsoluteInputEventWrapper";
  }
  protected:
  explicit AbsoluteInputEventWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // required .HU.AbsoluteInputEvent event = 1;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::HU::AbsoluteInputEvent& event() const;
  ::HU::AbsoluteInputEvent* release_event();
  ::HU::AbsoluteInputEvent* mutable_event();
  void set_allocated_event(::HU::AbsoluteInputEvent* event);
  private:
  const ::HU::AbsoluteInputEvent& _internal_event() const;
  ::HU::AbsoluteInputEvent* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::HU::AbsoluteInputEvent* event);
  ::HU::AbsoluteInputEvent* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:HU.AbsoluteInputEventWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::HU::AbsoluteInputEvent* event_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class RelativeInputEventWrapper PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.RelativeInputEventWrapper) */ {
 public:
  inline RelativeInputEventWrapper() : RelativeInputEventWrapper(nullptr) {};
  virtual ~RelativeInputEventWrapper();

  RelativeInputEventWrapper(const RelativeInputEventWrapper& from);
  RelativeInputEventWrapper(RelativeInputEventWrapper&& from) noexcept
    : RelativeInputEventWrapper() {
    *this = ::std::move(from);
  }

  inline RelativeInputEventWrapper& operator=(const RelativeInputEventWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline RelativeInputEventWrapper& operator=(RelativeInputEventWrapper&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RelativeInputEventWrapper& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelativeInputEventWrapper* internal_default_instance() {
    return reinterpret_cast<const RelativeInputEventWrapper*>(
               &_RelativeInputEventWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RelativeInputEventWrapper& a, RelativeInputEventWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(RelativeInputEventWrapper* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RelativeInputEventWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RelativeInputEventWrapper* New() const final {
    return CreateMaybeMessage<RelativeInputEventWrapper>(nullptr);
  }

  RelativeInputEventWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RelativeInputEventWrapper>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RelativeInputEventWrapper& from);
  void MergeFrom(const RelativeInputEventWrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelativeInputEventWrapper* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.RelativeInputEventWrapper";
  }
  protected:
  explicit RelativeInputEventWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventFieldNumber = 1,
  };
  // required .HU.RelativeInputEvent event = 1;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::HU::RelativeInputEvent& event() const;
  ::HU::RelativeInputEvent* release_event();
  ::HU::RelativeInputEvent* mutable_event();
  void set_allocated_event(::HU::RelativeInputEvent* event);
  private:
  const ::HU::RelativeInputEvent& _internal_event() const;
  ::HU::RelativeInputEvent* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::HU::RelativeInputEvent* event);
  ::HU::RelativeInputEvent* unsafe_arena_release_event();

  // @@protoc_insertion_point(class_scope:HU.RelativeInputEventWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::HU::RelativeInputEvent* event_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class InputEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.InputEvent) */ {
 public:
  inline InputEvent() : InputEvent(nullptr) {};
  virtual ~InputEvent();

  InputEvent(const InputEvent& from);
  InputEvent(InputEvent&& from) noexcept
    : InputEvent() {
    *this = ::std::move(from);
  }

  inline InputEvent& operator=(const InputEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputEvent& operator=(InputEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InputEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputEvent* internal_default_instance() {
    return reinterpret_cast<const InputEvent*>(
               &_InputEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InputEvent& a, InputEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(InputEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InputEvent* New() const final {
    return CreateMaybeMessage<InputEvent>(nullptr);
  }

  InputEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InputEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InputEvent& from);
  void MergeFrom(const InputEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.InputEvent";
  }
  protected:
  explicit InputEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTouchFieldNumber = 3,
    kButtonFieldNumber = 4,
    kAbsEventFieldNumber = 5,
    kRelEventFieldNumber = 6,
    kTimestampFieldNumber = 1,
    kDispChannelFieldNumber = 2,
  };
  // optional .HU.TouchInfo touch = 3;
  bool has_touch() const;
  private:
  bool _internal_has_touch() const;
  public:
  void clear_touch();
  const ::HU::TouchInfo& touch() const;
  ::HU::TouchInfo* release_touch();
  ::HU::TouchInfo* mutable_touch();
  void set_allocated_touch(::HU::TouchInfo* touch);
  private:
  const ::HU::TouchInfo& _internal_touch() const;
  ::HU::TouchInfo* _internal_mutable_touch();
  public:
  void unsafe_arena_set_allocated_touch(
      ::HU::TouchInfo* touch);
  ::HU::TouchInfo* unsafe_arena_release_touch();

  // optional .HU.ButtonInfoWrapper button = 4;
  bool has_button() const;
  private:
  bool _internal_has_button() const;
  public:
  void clear_button();
  const ::HU::ButtonInfoWrapper& button() const;
  ::HU::ButtonInfoWrapper* release_button();
  ::HU::ButtonInfoWrapper* mutable_button();
  void set_allocated_button(::HU::ButtonInfoWrapper* button);
  private:
  const ::HU::ButtonInfoWrapper& _internal_button() const;
  ::HU::ButtonInfoWrapper* _internal_mutable_button();
  public:
  void unsafe_arena_set_allocated_button(
      ::HU::ButtonInfoWrapper* button);
  ::HU::ButtonInfoWrapper* unsafe_arena_release_button();

  // optional .HU.AbsoluteInputEventWrapper abs_event = 5;
  bool has_abs_event() const;
  private:
  bool _internal_has_abs_event() const;
  public:
  void clear_abs_event();
  const ::HU::AbsoluteInputEventWrapper& abs_event() const;
  ::HU::AbsoluteInputEventWrapper* release_abs_event();
  ::HU::AbsoluteInputEventWrapper* mutable_abs_event();
  void set_allocated_abs_event(::HU::AbsoluteInputEventWrapper* abs_event);
  private:
  const ::HU::AbsoluteInputEventWrapper& _internal_abs_event() const;
  ::HU::AbsoluteInputEventWrapper* _internal_mutable_abs_event();
  public:
  void unsafe_arena_set_allocated_abs_event(
      ::HU::AbsoluteInputEventWrapper* abs_event);
  ::HU::AbsoluteInputEventWrapper* unsafe_arena_release_abs_event();

  // optional .HU.RelativeInputEventWrapper rel_event = 6;
  bool has_rel_event() const;
  private:
  bool _internal_has_rel_event() const;
  public:
  void clear_rel_event();
  const ::HU::RelativeInputEventWrapper& rel_event() const;
  ::HU::RelativeInputEventWrapper* release_rel_event();
  ::HU::RelativeInputEventWrapper* mutable_rel_event();
  void set_allocated_rel_event(::HU::RelativeInputEventWrapper* rel_event);
  private:
  const ::HU::RelativeInputEventWrapper& _internal_rel_event() const;
  ::HU::RelativeInputEventWrapper* _internal_mutable_rel_event();
  public:
  void unsafe_arena_set_allocated_rel_event(
      ::HU::RelativeInputEventWrapper* rel_event);
  ::HU::RelativeInputEventWrapper* unsafe_arena_release_rel_event();

  // required uint64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 disp_channel = 2;
  bool has_disp_channel() const;
  private:
  bool _internal_has_disp_channel() const;
  public:
  void clear_disp_channel();
  ::PROTOBUF_NAMESPACE_ID::int32 disp_channel() const;
  void set_disp_channel(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_disp_channel() const;
  void _internal_set_disp_channel(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.InputEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::HU::TouchInfo* touch_;
  ::HU::ButtonInfoWrapper* button_;
  ::HU::AbsoluteInputEventWrapper* abs_event_;
  ::HU::RelativeInputEventWrapper* rel_event_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 disp_channel_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class BindingRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.BindingRequest) */ {
 public:
  inline BindingRequest() : BindingRequest(nullptr) {};
  virtual ~BindingRequest();

  BindingRequest(const BindingRequest& from);
  BindingRequest(BindingRequest&& from) noexcept
    : BindingRequest() {
    *this = ::std::move(from);
  }

  inline BindingRequest& operator=(const BindingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindingRequest& operator=(BindingRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BindingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingRequest* internal_default_instance() {
    return reinterpret_cast<const BindingRequest*>(
               &_BindingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BindingRequest& a, BindingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BindingRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BindingRequest* New() const final {
    return CreateMaybeMessage<BindingRequest>(nullptr);
  }

  BindingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BindingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BindingRequest& from);
  void MergeFrom(const BindingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.BindingRequest";
  }
  protected:
  explicit BindingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScanCodesFieldNumber = 1,
  };
  // repeated int32 scan_codes = 1;
  int scan_codes_size() const;
  private:
  int _internal_scan_codes_size() const;
  public:
  void clear_scan_codes();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_scan_codes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_scan_codes() const;
  void _internal_add_scan_codes(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_scan_codes();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 scan_codes(int index) const;
  void set_scan_codes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_scan_codes(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      scan_codes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_scan_codes();

  // @@protoc_insertion_point(class_scope:HU.BindingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > scan_codes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class BindingResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.BindingResponse) */ {
 public:
  inline BindingResponse() : BindingResponse(nullptr) {};
  virtual ~BindingResponse();

  BindingResponse(const BindingResponse& from);
  BindingResponse(BindingResponse&& from) noexcept
    : BindingResponse() {
    *this = ::std::move(from);
  }

  inline BindingResponse& operator=(const BindingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindingResponse& operator=(BindingResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BindingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BindingResponse* internal_default_instance() {
    return reinterpret_cast<const BindingResponse*>(
               &_BindingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BindingResponse& a, BindingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BindingResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BindingResponse* New() const final {
    return CreateMaybeMessage<BindingResponse>(nullptr);
  }

  BindingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BindingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BindingResponse& from);
  void MergeFrom(const BindingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.BindingResponse";
  }
  protected:
  explicit BindingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .HU.STATUS status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::HU::STATUS status() const;
  void set_status(::HU::STATUS value);
  private:
  ::HU::STATUS _internal_status() const;
  void _internal_set_status(::HU::STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.BindingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_LocationData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.LocationData) */ {
 public:
  inline SensorEvent_LocationData() : SensorEvent_LocationData(nullptr) {};
  virtual ~SensorEvent_LocationData();

  SensorEvent_LocationData(const SensorEvent_LocationData& from);
  SensorEvent_LocationData(SensorEvent_LocationData&& from) noexcept
    : SensorEvent_LocationData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_LocationData& operator=(const SensorEvent_LocationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_LocationData& operator=(SensorEvent_LocationData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_LocationData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_LocationData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_LocationData*>(
               &_SensorEvent_LocationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SensorEvent_LocationData& a, SensorEvent_LocationData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_LocationData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_LocationData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_LocationData* New() const final {
    return CreateMaybeMessage<SensorEvent_LocationData>(nullptr);
  }

  SensorEvent_LocationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_LocationData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_LocationData& from);
  void MergeFrom(const SensorEvent_LocationData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_LocationData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.LocationData";
  }
  protected:
  explicit SensorEvent_LocationData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kLatitudeFieldNumber = 2,
    kLongitudeFieldNumber = 3,
    kAccuracyFieldNumber = 4,
    kAltitudeFieldNumber = 5,
    kSpeedFieldNumber = 6,
    kBearingFieldNumber = 7,
  };
  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 latitude = 2;
  bool has_latitude() const;
  private:
  bool _internal_has_latitude() const;
  public:
  void clear_latitude();
  ::PROTOBUF_NAMESPACE_ID::int32 latitude() const;
  void set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_latitude() const;
  void _internal_set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 longitude = 3;
  bool has_longitude() const;
  private:
  bool _internal_has_longitude() const;
  public:
  void clear_longitude();
  ::PROTOBUF_NAMESPACE_ID::int32 longitude() const;
  void set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_longitude() const;
  void _internal_set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 accuracy = 4;
  bool has_accuracy() const;
  private:
  bool _internal_has_accuracy() const;
  public:
  void clear_accuracy();
  ::PROTOBUF_NAMESPACE_ID::uint32 accuracy() const;
  void set_accuracy(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_accuracy() const;
  void _internal_set_accuracy(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 altitude = 5;
  bool has_altitude() const;
  private:
  bool _internal_has_altitude() const;
  public:
  void clear_altitude();
  ::PROTOBUF_NAMESPACE_ID::int32 altitude() const;
  void set_altitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_altitude() const;
  void _internal_set_altitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 speed = 6;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  ::PROTOBUF_NAMESPACE_ID::int32 speed() const;
  void set_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_speed() const;
  void _internal_set_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 bearing = 7;
  bool has_bearing() const;
  private:
  bool _internal_has_bearing() const;
  public:
  void clear_bearing();
  ::PROTOBUF_NAMESPACE_ID::int32 bearing() const;
  void set_bearing(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bearing() const;
  void _internal_set_bearing(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.LocationData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 latitude_;
  ::PROTOBUF_NAMESPACE_ID::int32 longitude_;
  ::PROTOBUF_NAMESPACE_ID::uint32 accuracy_;
  ::PROTOBUF_NAMESPACE_ID::int32 altitude_;
  ::PROTOBUF_NAMESPACE_ID::int32 speed_;
  ::PROTOBUF_NAMESPACE_ID::int32 bearing_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_NightMode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.NightMode) */ {
 public:
  inline SensorEvent_NightMode() : SensorEvent_NightMode(nullptr) {};
  virtual ~SensorEvent_NightMode();

  SensorEvent_NightMode(const SensorEvent_NightMode& from);
  SensorEvent_NightMode(SensorEvent_NightMode&& from) noexcept
    : SensorEvent_NightMode() {
    *this = ::std::move(from);
  }

  inline SensorEvent_NightMode& operator=(const SensorEvent_NightMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_NightMode& operator=(SensorEvent_NightMode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_NightMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_NightMode* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_NightMode*>(
               &_SensorEvent_NightMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SensorEvent_NightMode& a, SensorEvent_NightMode& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_NightMode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_NightMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_NightMode* New() const final {
    return CreateMaybeMessage<SensorEvent_NightMode>(nullptr);
  }

  SensorEvent_NightMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_NightMode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_NightMode& from);
  void MergeFrom(const SensorEvent_NightMode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_NightMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.NightMode";
  }
  protected:
  explicit SensorEvent_NightMode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsNightFieldNumber = 1,
  };
  // required bool is_night = 1;
  bool has_is_night() const;
  private:
  bool _internal_has_is_night() const;
  public:
  void clear_is_night();
  bool is_night() const;
  void set_is_night(bool value);
  private:
  bool _internal_is_night() const;
  void _internal_set_is_night(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.NightMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_night_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_RPM PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.RPM) */ {
 public:
  inline SensorEvent_RPM() : SensorEvent_RPM(nullptr) {};
  virtual ~SensorEvent_RPM();

  SensorEvent_RPM(const SensorEvent_RPM& from);
  SensorEvent_RPM(SensorEvent_RPM&& from) noexcept
    : SensorEvent_RPM() {
    *this = ::std::move(from);
  }

  inline SensorEvent_RPM& operator=(const SensorEvent_RPM& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_RPM& operator=(SensorEvent_RPM&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_RPM& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_RPM* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_RPM*>(
               &_SensorEvent_RPM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SensorEvent_RPM& a, SensorEvent_RPM& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_RPM* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_RPM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_RPM* New() const final {
    return CreateMaybeMessage<SensorEvent_RPM>(nullptr);
  }

  SensorEvent_RPM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_RPM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_RPM& from);
  void MergeFrom(const SensorEvent_RPM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_RPM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.RPM";
  }
  protected:
  explicit SensorEvent_RPM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRpmFieldNumber = 1,
  };
  // required int32 rpm = 1;
  bool has_rpm() const;
  private:
  bool _internal_has_rpm() const;
  public:
  void clear_rpm();
  ::PROTOBUF_NAMESPACE_ID::int32 rpm() const;
  void set_rpm(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rpm() const;
  void _internal_set_rpm(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.RPM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 rpm_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_FuelLevel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.FuelLevel) */ {
 public:
  inline SensorEvent_FuelLevel() : SensorEvent_FuelLevel(nullptr) {};
  virtual ~SensorEvent_FuelLevel();

  SensorEvent_FuelLevel(const SensorEvent_FuelLevel& from);
  SensorEvent_FuelLevel(SensorEvent_FuelLevel&& from) noexcept
    : SensorEvent_FuelLevel() {
    *this = ::std::move(from);
  }

  inline SensorEvent_FuelLevel& operator=(const SensorEvent_FuelLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_FuelLevel& operator=(SensorEvent_FuelLevel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_FuelLevel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_FuelLevel* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_FuelLevel*>(
               &_SensorEvent_FuelLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SensorEvent_FuelLevel& a, SensorEvent_FuelLevel& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_FuelLevel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_FuelLevel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_FuelLevel* New() const final {
    return CreateMaybeMessage<SensorEvent_FuelLevel>(nullptr);
  }

  SensorEvent_FuelLevel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_FuelLevel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_FuelLevel& from);
  void MergeFrom(const SensorEvent_FuelLevel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_FuelLevel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.FuelLevel";
  }
  protected:
  explicit SensorEvent_FuelLevel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuelLevelFieldNumber = 1,
    kRangeFieldNumber = 2,
    kLowFuelFieldNumber = 3,
  };
  // required int32 fuel_level = 1;
  bool has_fuel_level() const;
  private:
  bool _internal_has_fuel_level() const;
  public:
  void clear_fuel_level();
  ::PROTOBUF_NAMESPACE_ID::int32 fuel_level() const;
  void set_fuel_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fuel_level() const;
  void _internal_set_fuel_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 range = 2;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  ::PROTOBUF_NAMESPACE_ID::int32 range() const;
  void set_range(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_range() const;
  void _internal_set_range(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool low_fuel = 3;
  bool has_low_fuel() const;
  private:
  bool _internal_has_low_fuel() const;
  public:
  void clear_low_fuel();
  bool low_fuel() const;
  void set_low_fuel(bool value);
  private:
  bool _internal_low_fuel() const;
  void _internal_set_low_fuel(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.FuelLevel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 fuel_level_;
  ::PROTOBUF_NAMESPACE_ID::int32 range_;
  bool low_fuel_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_DrivingStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.DrivingStatus) */ {
 public:
  inline SensorEvent_DrivingStatus() : SensorEvent_DrivingStatus(nullptr) {};
  virtual ~SensorEvent_DrivingStatus();

  SensorEvent_DrivingStatus(const SensorEvent_DrivingStatus& from);
  SensorEvent_DrivingStatus(SensorEvent_DrivingStatus&& from) noexcept
    : SensorEvent_DrivingStatus() {
    *this = ::std::move(from);
  }

  inline SensorEvent_DrivingStatus& operator=(const SensorEvent_DrivingStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_DrivingStatus& operator=(SensorEvent_DrivingStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_DrivingStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_DrivingStatus* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_DrivingStatus*>(
               &_SensorEvent_DrivingStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SensorEvent_DrivingStatus& a, SensorEvent_DrivingStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_DrivingStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_DrivingStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_DrivingStatus* New() const final {
    return CreateMaybeMessage<SensorEvent_DrivingStatus>(nullptr);
  }

  SensorEvent_DrivingStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_DrivingStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_DrivingStatus& from);
  void MergeFrom(const SensorEvent_DrivingStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_DrivingStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.DrivingStatus";
  }
  protected:
  explicit SensorEvent_DrivingStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SensorEvent_DrivingStatus_STATUS STATUS;
  static constexpr STATUS DRIVE_STATUS_FULLY_RESTRICTED =
    SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_FULLY_RESTRICTED;
  static constexpr STATUS DRIVE_STATUS_LIMIT_MESSAGE_LEN =
    SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_LIMIT_MESSAGE_LEN;
  static constexpr STATUS DRIVE_STATUS_NO_CONFIG =
    SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_CONFIG;
  static constexpr STATUS DRIVE_STATUS_NO_KEYBOARD_INPUT =
    SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_KEYBOARD_INPUT;
  static constexpr STATUS DRIVE_STATUS_NO_VIDEO =
    SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_VIDEO;
  static constexpr STATUS DRIVE_STATUS_NO_VOICE_INPUT =
    SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_NO_VOICE_INPUT;
  static constexpr STATUS DRIVE_STATUS_UNRESTRICTED =
    SensorEvent_DrivingStatus_STATUS_DRIVE_STATUS_UNRESTRICTED;
  static inline bool STATUS_IsValid(int value) {
    return SensorEvent_DrivingStatus_STATUS_IsValid(value);
  }
  static constexpr STATUS STATUS_MIN =
    SensorEvent_DrivingStatus_STATUS_STATUS_MIN;
  static constexpr STATUS STATUS_MAX =
    SensorEvent_DrivingStatus_STATUS_STATUS_MAX;
  static constexpr int STATUS_ARRAYSIZE =
    SensorEvent_DrivingStatus_STATUS_STATUS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  STATUS_descriptor() {
    return SensorEvent_DrivingStatus_STATUS_descriptor();
  }
  template<typename T>
  static inline const std::string& STATUS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, STATUS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function STATUS_Name.");
    return SensorEvent_DrivingStatus_STATUS_Name(enum_t_value);
  }
  static inline bool STATUS_Parse(const std::string& name,
      STATUS* value) {
    return SensorEvent_DrivingStatus_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required int32 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.DrivingStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_DeadReckoning PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.DeadReckoning) */ {
 public:
  inline SensorEvent_DeadReckoning() : SensorEvent_DeadReckoning(nullptr) {};
  virtual ~SensorEvent_DeadReckoning();

  SensorEvent_DeadReckoning(const SensorEvent_DeadReckoning& from);
  SensorEvent_DeadReckoning(SensorEvent_DeadReckoning&& from) noexcept
    : SensorEvent_DeadReckoning() {
    *this = ::std::move(from);
  }

  inline SensorEvent_DeadReckoning& operator=(const SensorEvent_DeadReckoning& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_DeadReckoning& operator=(SensorEvent_DeadReckoning&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_DeadReckoning& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_DeadReckoning* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_DeadReckoning*>(
               &_SensorEvent_DeadReckoning_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SensorEvent_DeadReckoning& a, SensorEvent_DeadReckoning& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_DeadReckoning* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_DeadReckoning* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_DeadReckoning* New() const final {
    return CreateMaybeMessage<SensorEvent_DeadReckoning>(nullptr);
  }

  SensorEvent_DeadReckoning* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_DeadReckoning>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_DeadReckoning& from);
  void MergeFrom(const SensorEvent_DeadReckoning& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_DeadReckoning* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.DeadReckoning";
  }
  protected:
  explicit SensorEvent_DeadReckoning(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteeringAngelFieldNumber = 1,
    kWheelSpeedFieldNumber = 2,
  };
  // optional int32 steering_angel = 1;
  bool has_steering_angel() const;
  private:
  bool _internal_has_steering_angel() const;
  public:
  void clear_steering_angel();
  ::PROTOBUF_NAMESPACE_ID::int32 steering_angel() const;
  void set_steering_angel(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_steering_angel() const;
  void _internal_set_steering_angel(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 wheel_speed = 2;
  bool has_wheel_speed() const;
  private:
  bool _internal_has_wheel_speed() const;
  public:
  void clear_wheel_speed();
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_speed() const;
  void set_wheel_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_wheel_speed() const;
  void _internal_set_wheel_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.DeadReckoning)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 steering_angel_;
  ::PROTOBUF_NAMESPACE_ID::int32 wheel_speed_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_CompassData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.CompassData) */ {
 public:
  inline SensorEvent_CompassData() : SensorEvent_CompassData(nullptr) {};
  virtual ~SensorEvent_CompassData();

  SensorEvent_CompassData(const SensorEvent_CompassData& from);
  SensorEvent_CompassData(SensorEvent_CompassData&& from) noexcept
    : SensorEvent_CompassData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_CompassData& operator=(const SensorEvent_CompassData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_CompassData& operator=(SensorEvent_CompassData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_CompassData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_CompassData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_CompassData*>(
               &_SensorEvent_CompassData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SensorEvent_CompassData& a, SensorEvent_CompassData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_CompassData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_CompassData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_CompassData* New() const final {
    return CreateMaybeMessage<SensorEvent_CompassData>(nullptr);
  }

  SensorEvent_CompassData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_CompassData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_CompassData& from);
  void MergeFrom(const SensorEvent_CompassData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_CompassData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.CompassData";
  }
  protected:
  explicit SensorEvent_CompassData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBearingE6FieldNumber = 1,
    kPitchE6FieldNumber = 2,
    kRollE6FieldNumber = 3,
  };
  // optional int32 bearing_e6 = 1;
  bool has_bearing_e6() const;
  private:
  bool _internal_has_bearing_e6() const;
  public:
  void clear_bearing_e6();
  ::PROTOBUF_NAMESPACE_ID::int32 bearing_e6() const;
  void set_bearing_e6(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bearing_e6() const;
  void _internal_set_bearing_e6(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 pitch_e6 = 2;
  bool has_pitch_e6() const;
  private:
  bool _internal_has_pitch_e6() const;
  public:
  void clear_pitch_e6();
  ::PROTOBUF_NAMESPACE_ID::int32 pitch_e6() const;
  void set_pitch_e6(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pitch_e6() const;
  void _internal_set_pitch_e6(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 roll_e6 = 3;
  bool has_roll_e6() const;
  private:
  bool _internal_has_roll_e6() const;
  public:
  void clear_roll_e6();
  ::PROTOBUF_NAMESPACE_ID::int32 roll_e6() const;
  void set_roll_e6(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_roll_e6() const;
  void _internal_set_roll_e6(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.CompassData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 bearing_e6_;
  ::PROTOBUF_NAMESPACE_ID::int32 pitch_e6_;
  ::PROTOBUF_NAMESPACE_ID::int32 roll_e6_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_SpeedData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.SpeedData) */ {
 public:
  inline SensorEvent_SpeedData() : SensorEvent_SpeedData(nullptr) {};
  virtual ~SensorEvent_SpeedData();

  SensorEvent_SpeedData(const SensorEvent_SpeedData& from);
  SensorEvent_SpeedData(SensorEvent_SpeedData&& from) noexcept
    : SensorEvent_SpeedData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_SpeedData& operator=(const SensorEvent_SpeedData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_SpeedData& operator=(SensorEvent_SpeedData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_SpeedData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_SpeedData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_SpeedData*>(
               &_SensorEvent_SpeedData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SensorEvent_SpeedData& a, SensorEvent_SpeedData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_SpeedData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_SpeedData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_SpeedData* New() const final {
    return CreateMaybeMessage<SensorEvent_SpeedData>(nullptr);
  }

  SensorEvent_SpeedData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_SpeedData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_SpeedData& from);
  void MergeFrom(const SensorEvent_SpeedData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_SpeedData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.SpeedData";
  }
  protected:
  explicit SensorEvent_SpeedData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeedE6FieldNumber = 1,
    kCruiseEngagedFieldNumber = 2,
    kCruiseSetSpeedFieldNumber = 3,
  };
  // optional int32 speed_e6 = 1;
  bool has_speed_e6() const;
  private:
  bool _internal_has_speed_e6() const;
  public:
  void clear_speed_e6();
  ::PROTOBUF_NAMESPACE_ID::int32 speed_e6() const;
  void set_speed_e6(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_speed_e6() const;
  void _internal_set_speed_e6(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool cruise_engaged = 2;
  bool has_cruise_engaged() const;
  private:
  bool _internal_has_cruise_engaged() const;
  public:
  void clear_cruise_engaged();
  bool cruise_engaged() const;
  void set_cruise_engaged(bool value);
  private:
  bool _internal_cruise_engaged() const;
  void _internal_set_cruise_engaged(bool value);
  public:

  // optional bool cruise_set_speed = 3;
  bool has_cruise_set_speed() const;
  private:
  bool _internal_has_cruise_set_speed() const;
  public:
  void clear_cruise_set_speed();
  bool cruise_set_speed() const;
  void set_cruise_set_speed(bool value);
  private:
  bool _internal_cruise_set_speed() const;
  void _internal_set_cruise_set_speed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.SpeedData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 speed_e6_;
  bool cruise_engaged_;
  bool cruise_set_speed_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_OdometerData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.OdometerData) */ {
 public:
  inline SensorEvent_OdometerData() : SensorEvent_OdometerData(nullptr) {};
  virtual ~SensorEvent_OdometerData();

  SensorEvent_OdometerData(const SensorEvent_OdometerData& from);
  SensorEvent_OdometerData(SensorEvent_OdometerData&& from) noexcept
    : SensorEvent_OdometerData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_OdometerData& operator=(const SensorEvent_OdometerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_OdometerData& operator=(SensorEvent_OdometerData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_OdometerData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_OdometerData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_OdometerData*>(
               &_SensorEvent_OdometerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SensorEvent_OdometerData& a, SensorEvent_OdometerData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_OdometerData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_OdometerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_OdometerData* New() const final {
    return CreateMaybeMessage<SensorEvent_OdometerData>(nullptr);
  }

  SensorEvent_OdometerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_OdometerData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_OdometerData& from);
  void MergeFrom(const SensorEvent_OdometerData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_OdometerData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.OdometerData";
  }
  protected:
  explicit SensorEvent_OdometerData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKmsElFieldNumber = 1,
    kTripKmsElFieldNumber = 2,
  };
  // optional int32 kms_el = 1;
  bool has_kms_el() const;
  private:
  bool _internal_has_kms_el() const;
  public:
  void clear_kms_el();
  ::PROTOBUF_NAMESPACE_ID::int32 kms_el() const;
  void set_kms_el(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_kms_el() const;
  void _internal_set_kms_el(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 trip_kms_el = 2;
  bool has_trip_kms_el() const;
  private:
  bool _internal_has_trip_kms_el() const;
  public:
  void clear_trip_kms_el();
  ::PROTOBUF_NAMESPACE_ID::int32 trip_kms_el() const;
  void set_trip_kms_el(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_trip_kms_el() const;
  void _internal_set_trip_kms_el(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.OdometerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 kms_el_;
  ::PROTOBUF_NAMESPACE_ID::int32 trip_kms_el_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_ParkingBreak PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.ParkingBreak) */ {
 public:
  inline SensorEvent_ParkingBreak() : SensorEvent_ParkingBreak(nullptr) {};
  virtual ~SensorEvent_ParkingBreak();

  SensorEvent_ParkingBreak(const SensorEvent_ParkingBreak& from);
  SensorEvent_ParkingBreak(SensorEvent_ParkingBreak&& from) noexcept
    : SensorEvent_ParkingBreak() {
    *this = ::std::move(from);
  }

  inline SensorEvent_ParkingBreak& operator=(const SensorEvent_ParkingBreak& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_ParkingBreak& operator=(SensorEvent_ParkingBreak&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_ParkingBreak& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_ParkingBreak* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_ParkingBreak*>(
               &_SensorEvent_ParkingBreak_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SensorEvent_ParkingBreak& a, SensorEvent_ParkingBreak& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_ParkingBreak* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_ParkingBreak* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_ParkingBreak* New() const final {
    return CreateMaybeMessage<SensorEvent_ParkingBreak>(nullptr);
  }

  SensorEvent_ParkingBreak* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_ParkingBreak>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_ParkingBreak& from);
  void MergeFrom(const SensorEvent_ParkingBreak& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_ParkingBreak* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.ParkingBreak";
  }
  protected:
  explicit SensorEvent_ParkingBreak(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParkingBreakeFieldNumber = 1,
  };
  // optional bool parking_breake = 1;
  bool has_parking_breake() const;
  private:
  bool _internal_has_parking_breake() const;
  public:
  void clear_parking_breake();
  bool parking_breake() const;
  void set_parking_breake(bool value);
  private:
  bool _internal_parking_breake() const;
  void _internal_set_parking_breake(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.ParkingBreak)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool parking_breake_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_Passenger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Passenger) */ {
 public:
  inline SensorEvent_Passenger() : SensorEvent_Passenger(nullptr) {};
  virtual ~SensorEvent_Passenger();

  SensorEvent_Passenger(const SensorEvent_Passenger& from);
  SensorEvent_Passenger(SensorEvent_Passenger&& from) noexcept
    : SensorEvent_Passenger() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Passenger& operator=(const SensorEvent_Passenger& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Passenger& operator=(SensorEvent_Passenger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_Passenger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_Passenger* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Passenger*>(
               &_SensorEvent_Passenger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SensorEvent_Passenger& a, SensorEvent_Passenger& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Passenger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Passenger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_Passenger* New() const final {
    return CreateMaybeMessage<SensorEvent_Passenger>(nullptr);
  }

  SensorEvent_Passenger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_Passenger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_Passenger& from);
  void MergeFrom(const SensorEvent_Passenger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_Passenger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.Passenger";
  }
  protected:
  explicit SensorEvent_Passenger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPassengerPresentFieldNumber = 1,
  };
  // optional bool passenger_present = 1;
  bool has_passenger_present() const;
  private:
  bool _internal_has_passenger_present() const;
  public:
  void clear_passenger_present();
  bool passenger_present() const;
  void set_passenger_present(bool value);
  private:
  bool _internal_passenger_present() const;
  void _internal_set_passenger_present(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Passenger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool passenger_present_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_Diagnostics PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Diagnostics) */ {
 public:
  inline SensorEvent_Diagnostics() : SensorEvent_Diagnostics(nullptr) {};
  virtual ~SensorEvent_Diagnostics();

  SensorEvent_Diagnostics(const SensorEvent_Diagnostics& from);
  SensorEvent_Diagnostics(SensorEvent_Diagnostics&& from) noexcept
    : SensorEvent_Diagnostics() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Diagnostics& operator=(const SensorEvent_Diagnostics& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Diagnostics& operator=(SensorEvent_Diagnostics&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_Diagnostics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_Diagnostics* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Diagnostics*>(
               &_SensorEvent_Diagnostics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SensorEvent_Diagnostics& a, SensorEvent_Diagnostics& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Diagnostics* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Diagnostics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_Diagnostics* New() const final {
    return CreateMaybeMessage<SensorEvent_Diagnostics>(nullptr);
  }

  SensorEvent_Diagnostics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_Diagnostics>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_Diagnostics& from);
  void MergeFrom(const SensorEvent_Diagnostics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_Diagnostics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.Diagnostics";
  }
  protected:
  explicit SensorEvent_Diagnostics(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiagnosticsByteFieldNumber = 1,
  };
  // optional bytes diagnostics_byte = 1;
  bool has_diagnostics_byte() const;
  private:
  bool _internal_has_diagnostics_byte() const;
  public:
  void clear_diagnostics_byte();
  const std::string& diagnostics_byte() const;
  void set_diagnostics_byte(const std::string& value);
  void set_diagnostics_byte(std::string&& value);
  void set_diagnostics_byte(const char* value);
  void set_diagnostics_byte(const void* value, size_t size);
  std::string* mutable_diagnostics_byte();
  std::string* release_diagnostics_byte();
  void set_allocated_diagnostics_byte(std::string* diagnostics_byte);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_diagnostics_byte();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_diagnostics_byte(
      std::string* diagnostics_byte);
  private:
  const std::string& _internal_diagnostics_byte() const;
  void _internal_set_diagnostics_byte(const std::string& value);
  std::string* _internal_mutable_diagnostics_byte();
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Diagnostics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr diagnostics_byte_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_Environment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Environment) */ {
 public:
  inline SensorEvent_Environment() : SensorEvent_Environment(nullptr) {};
  virtual ~SensorEvent_Environment();

  SensorEvent_Environment(const SensorEvent_Environment& from);
  SensorEvent_Environment(SensorEvent_Environment&& from) noexcept
    : SensorEvent_Environment() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Environment& operator=(const SensorEvent_Environment& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Environment& operator=(SensorEvent_Environment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_Environment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_Environment* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Environment*>(
               &_SensorEvent_Environment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SensorEvent_Environment& a, SensorEvent_Environment& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Environment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Environment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_Environment* New() const final {
    return CreateMaybeMessage<SensorEvent_Environment>(nullptr);
  }

  SensorEvent_Environment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_Environment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_Environment& from);
  void MergeFrom(const SensorEvent_Environment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_Environment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.Environment";
  }
  protected:
  explicit SensorEvent_Environment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemperatureE3FieldNumber = 1,
    kPressureE3FieldNumber = 2,
    kRainFieldNumber = 3,
  };
  // optional int32 temperature_e3 = 1;
  bool has_temperature_e3() const;
  private:
  bool _internal_has_temperature_e3() const;
  public:
  void clear_temperature_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 temperature_e3() const;
  void set_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_temperature_e3() const;
  void _internal_set_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 pressure_e3 = 2;
  bool has_pressure_e3() const;
  private:
  bool _internal_has_pressure_e3() const;
  public:
  void clear_pressure_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 pressure_e3() const;
  void set_pressure_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pressure_e3() const;
  void _internal_set_pressure_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 rain = 3;
  bool has_rain() const;
  private:
  bool _internal_has_rain() const;
  public:
  void clear_rain();
  ::PROTOBUF_NAMESPACE_ID::int32 rain() const;
  void set_rain(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rain() const;
  void _internal_set_rain(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Environment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 temperature_e3_;
  ::PROTOBUF_NAMESPACE_ID::int32 pressure_e3_;
  ::PROTOBUF_NAMESPACE_ID::int32 rain_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_HVAC PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.HVAC) */ {
 public:
  inline SensorEvent_HVAC() : SensorEvent_HVAC(nullptr) {};
  virtual ~SensorEvent_HVAC();

  SensorEvent_HVAC(const SensorEvent_HVAC& from);
  SensorEvent_HVAC(SensorEvent_HVAC&& from) noexcept
    : SensorEvent_HVAC() {
    *this = ::std::move(from);
  }

  inline SensorEvent_HVAC& operator=(const SensorEvent_HVAC& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_HVAC& operator=(SensorEvent_HVAC&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_HVAC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_HVAC* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_HVAC*>(
               &_SensorEvent_HVAC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(SensorEvent_HVAC& a, SensorEvent_HVAC& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_HVAC* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_HVAC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_HVAC* New() const final {
    return CreateMaybeMessage<SensorEvent_HVAC>(nullptr);
  }

  SensorEvent_HVAC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_HVAC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_HVAC& from);
  void MergeFrom(const SensorEvent_HVAC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_HVAC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.HVAC";
  }
  protected:
  explicit SensorEvent_HVAC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetTemperatureE3FieldNumber = 1,
    kCurrentTemperatureE3FieldNumber = 2,
  };
  // optional int32 target_temperature_e3 = 1;
  bool has_target_temperature_e3() const;
  private:
  bool _internal_has_target_temperature_e3() const;
  public:
  void clear_target_temperature_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 target_temperature_e3() const;
  void set_target_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_target_temperature_e3() const;
  void _internal_set_target_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 current_temperature_e3 = 2;
  bool has_current_temperature_e3() const;
  private:
  bool _internal_has_current_temperature_e3() const;
  public:
  void clear_current_temperature_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 current_temperature_e3() const;
  void set_current_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_current_temperature_e3() const;
  void _internal_set_current_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.HVAC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 target_temperature_e3_;
  ::PROTOBUF_NAMESPACE_ID::int32 current_temperature_e3_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_Accel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Accel) */ {
 public:
  inline SensorEvent_Accel() : SensorEvent_Accel(nullptr) {};
  virtual ~SensorEvent_Accel();

  SensorEvent_Accel(const SensorEvent_Accel& from);
  SensorEvent_Accel(SensorEvent_Accel&& from) noexcept
    : SensorEvent_Accel() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Accel& operator=(const SensorEvent_Accel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Accel& operator=(SensorEvent_Accel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_Accel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_Accel* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Accel*>(
               &_SensorEvent_Accel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SensorEvent_Accel& a, SensorEvent_Accel& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Accel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Accel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_Accel* New() const final {
    return CreateMaybeMessage<SensorEvent_Accel>(nullptr);
  }

  SensorEvent_Accel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_Accel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_Accel& from);
  void MergeFrom(const SensorEvent_Accel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_Accel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.Accel";
  }
  protected:
  explicit SensorEvent_Accel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccelerationXE3FieldNumber = 1,
    kAccelerationYE3FieldNumber = 2,
    kAccelerationZE3FieldNumber = 3,
  };
  // optional int32 acceleration_x_e3 = 1;
  bool has_acceleration_x_e3() const;
  private:
  bool _internal_has_acceleration_x_e3() const;
  public:
  void clear_acceleration_x_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 acceleration_x_e3() const;
  void set_acceleration_x_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_acceleration_x_e3() const;
  void _internal_set_acceleration_x_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 acceleration_y_e3 = 2;
  bool has_acceleration_y_e3() const;
  private:
  bool _internal_has_acceleration_y_e3() const;
  public:
  void clear_acceleration_y_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 acceleration_y_e3() const;
  void set_acceleration_y_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_acceleration_y_e3() const;
  void _internal_set_acceleration_y_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 acceleration_z_e3 = 3;
  bool has_acceleration_z_e3() const;
  private:
  bool _internal_has_acceleration_z_e3() const;
  public:
  void clear_acceleration_z_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 acceleration_z_e3() const;
  void set_acceleration_z_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_acceleration_z_e3() const;
  void _internal_set_acceleration_z_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Accel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 acceleration_x_e3_;
  ::PROTOBUF_NAMESPACE_ID::int32 acceleration_y_e3_;
  ::PROTOBUF_NAMESPACE_ID::int32 acceleration_z_e3_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_Gyro PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Gyro) */ {
 public:
  inline SensorEvent_Gyro() : SensorEvent_Gyro(nullptr) {};
  virtual ~SensorEvent_Gyro();

  SensorEvent_Gyro(const SensorEvent_Gyro& from);
  SensorEvent_Gyro(SensorEvent_Gyro&& from) noexcept
    : SensorEvent_Gyro() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Gyro& operator=(const SensorEvent_Gyro& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Gyro& operator=(SensorEvent_Gyro&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_Gyro& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_Gyro* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Gyro*>(
               &_SensorEvent_Gyro_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SensorEvent_Gyro& a, SensorEvent_Gyro& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Gyro* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Gyro* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_Gyro* New() const final {
    return CreateMaybeMessage<SensorEvent_Gyro>(nullptr);
  }

  SensorEvent_Gyro* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_Gyro>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_Gyro& from);
  void MergeFrom(const SensorEvent_Gyro& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_Gyro* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.Gyro";
  }
  protected:
  explicit SensorEvent_Gyro(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotationSpeedXE3FieldNumber = 1,
    kRotationSpeedYE3FieldNumber = 2,
    kRotationSpeedZE3FieldNumber = 3,
  };
  // optional int32 rotation_speed_x_e3 = 1;
  bool has_rotation_speed_x_e3() const;
  private:
  bool _internal_has_rotation_speed_x_e3() const;
  public:
  void clear_rotation_speed_x_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 rotation_speed_x_e3() const;
  void set_rotation_speed_x_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rotation_speed_x_e3() const;
  void _internal_set_rotation_speed_x_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 rotation_speed_y_e3 = 2;
  bool has_rotation_speed_y_e3() const;
  private:
  bool _internal_has_rotation_speed_y_e3() const;
  public:
  void clear_rotation_speed_y_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 rotation_speed_y_e3() const;
  void set_rotation_speed_y_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rotation_speed_y_e3() const;
  void _internal_set_rotation_speed_y_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 rotation_speed_z_e3 = 3;
  bool has_rotation_speed_z_e3() const;
  private:
  bool _internal_has_rotation_speed_z_e3() const;
  public:
  void clear_rotation_speed_z_e3();
  ::PROTOBUF_NAMESPACE_ID::int32 rotation_speed_z_e3() const;
  void set_rotation_speed_z_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rotation_speed_z_e3() const;
  void _internal_set_rotation_speed_z_e3(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Gyro)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 rotation_speed_x_e3_;
  ::PROTOBUF_NAMESPACE_ID::int32 rotation_speed_y_e3_;
  ::PROTOBUF_NAMESPACE_ID::int32 rotation_speed_z_e3_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_Door PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Door) */ {
 public:
  inline SensorEvent_Door() : SensorEvent_Door(nullptr) {};
  virtual ~SensorEvent_Door();

  SensorEvent_Door(const SensorEvent_Door& from);
  SensorEvent_Door(SensorEvent_Door&& from) noexcept
    : SensorEvent_Door() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Door& operator=(const SensorEvent_Door& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Door& operator=(SensorEvent_Door&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_Door& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_Door* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Door*>(
               &_SensorEvent_Door_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SensorEvent_Door& a, SensorEvent_Door& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Door* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Door* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_Door* New() const final {
    return CreateMaybeMessage<SensorEvent_Door>(nullptr);
  }

  SensorEvent_Door* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_Door>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_Door& from);
  void MergeFrom(const SensorEvent_Door& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_Door* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.Door";
  }
  protected:
  explicit SensorEvent_Door(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDoorOpenFieldNumber = 3,
    kHoodOpenFieldNumber = 1,
    kBootOpenFieldNumber = 2,
  };
  // repeated bool door_open = 3;
  int door_open_size() const;
  private:
  int _internal_door_open_size() const;
  public:
  void clear_door_open();
  private:
  bool _internal_door_open(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_door_open() const;
  void _internal_add_door_open(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_door_open();
  public:
  bool door_open(int index) const;
  void set_door_open(int index, bool value);
  void add_door_open(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      door_open() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_door_open();

  // optional bool hood_open = 1;
  bool has_hood_open() const;
  private:
  bool _internal_has_hood_open() const;
  public:
  void clear_hood_open();
  bool hood_open() const;
  void set_hood_open(bool value);
  private:
  bool _internal_hood_open() const;
  void _internal_set_hood_open(bool value);
  public:

  // optional bool boot_open = 2;
  bool has_boot_open() const;
  private:
  bool _internal_has_boot_open() const;
  public:
  void clear_boot_open();
  bool boot_open() const;
  void set_boot_open(bool value);
  private:
  bool _internal_boot_open() const;
  void _internal_set_boot_open(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Door)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > door_open_;
  bool hood_open_;
  bool boot_open_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_Light PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.Light) */ {
 public:
  inline SensorEvent_Light() : SensorEvent_Light(nullptr) {};
  virtual ~SensorEvent_Light();

  SensorEvent_Light(const SensorEvent_Light& from);
  SensorEvent_Light(SensorEvent_Light&& from) noexcept
    : SensorEvent_Light() {
    *this = ::std::move(from);
  }

  inline SensorEvent_Light& operator=(const SensorEvent_Light& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_Light& operator=(SensorEvent_Light&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_Light& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_Light* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_Light*>(
               &_SensorEvent_Light_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SensorEvent_Light& a, SensorEvent_Light& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_Light* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_Light* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_Light* New() const final {
    return CreateMaybeMessage<SensorEvent_Light>(nullptr);
  }

  SensorEvent_Light* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_Light>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_Light& from);
  void MergeFrom(const SensorEvent_Light& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_Light* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.Light";
  }
  protected:
  explicit SensorEvent_Light(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SensorEvent_Light_HEADLIGHT_STATE HEADLIGHT_STATE;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_0 =
    SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_0;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_1 =
    SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_1;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_2 =
    SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_2;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_3 =
    SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_3;
  static inline bool HEADLIGHT_STATE_IsValid(int value) {
    return SensorEvent_Light_HEADLIGHT_STATE_IsValid(value);
  }
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_MIN =
    SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_MIN;
  static constexpr HEADLIGHT_STATE HEADLIGHT_STATE_MAX =
    SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_MAX;
  static constexpr int HEADLIGHT_STATE_ARRAYSIZE =
    SensorEvent_Light_HEADLIGHT_STATE_HEADLIGHT_STATE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HEADLIGHT_STATE_descriptor() {
    return SensorEvent_Light_HEADLIGHT_STATE_descriptor();
  }
  template<typename T>
  static inline const std::string& HEADLIGHT_STATE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HEADLIGHT_STATE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HEADLIGHT_STATE_Name.");
    return SensorEvent_Light_HEADLIGHT_STATE_Name(enum_t_value);
  }
  static inline bool HEADLIGHT_STATE_Parse(const std::string& name,
      HEADLIGHT_STATE* value) {
    return SensorEvent_Light_HEADLIGHT_STATE_Parse(name, value);
  }

  typedef SensorEvent_Light_TURN_INDICATOR_STATE TURN_INDICATOR_STATE;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_0 =
    SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_0;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_1 =
    SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_1;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_2 =
    SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_2;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_3 =
    SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_3;
  static inline bool TURN_INDICATOR_STATE_IsValid(int value) {
    return SensorEvent_Light_TURN_INDICATOR_STATE_IsValid(value);
  }
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_MIN =
    SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_MIN;
  static constexpr TURN_INDICATOR_STATE TURN_INDICATOR_STATE_MAX =
    SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_MAX;
  static constexpr int TURN_INDICATOR_STATE_ARRAYSIZE =
    SensorEvent_Light_TURN_INDICATOR_STATE_TURN_INDICATOR_STATE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TURN_INDICATOR_STATE_descriptor() {
    return SensorEvent_Light_TURN_INDICATOR_STATE_descriptor();
  }
  template<typename T>
  static inline const std::string& TURN_INDICATOR_STATE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TURN_INDICATOR_STATE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TURN_INDICATOR_STATE_Name.");
    return SensorEvent_Light_TURN_INDICATOR_STATE_Name(enum_t_value);
  }
  static inline bool TURN_INDICATOR_STATE_Parse(const std::string& name,
      TURN_INDICATOR_STATE* value) {
    return SensorEvent_Light_TURN_INDICATOR_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeadlightFieldNumber = 1,
    kTurnIndicatorFieldNumber = 2,
    kHazardLightOnFieldNumber = 3,
  };
  // optional .HU.SensorEvent.Light.HEADLIGHT_STATE headlight = 1;
  bool has_headlight() const;
  private:
  bool _internal_has_headlight() const;
  public:
  void clear_headlight();
  ::HU::SensorEvent_Light_HEADLIGHT_STATE headlight() const;
  void set_headlight(::HU::SensorEvent_Light_HEADLIGHT_STATE value);
  private:
  ::HU::SensorEvent_Light_HEADLIGHT_STATE _internal_headlight() const;
  void _internal_set_headlight(::HU::SensorEvent_Light_HEADLIGHT_STATE value);
  public:

  // optional .HU.SensorEvent.Light.TURN_INDICATOR_STATE turn_indicator = 2;
  bool has_turn_indicator() const;
  private:
  bool _internal_has_turn_indicator() const;
  public:
  void clear_turn_indicator();
  ::HU::SensorEvent_Light_TURN_INDICATOR_STATE turn_indicator() const;
  void set_turn_indicator(::HU::SensorEvent_Light_TURN_INDICATOR_STATE value);
  private:
  ::HU::SensorEvent_Light_TURN_INDICATOR_STATE _internal_turn_indicator() const;
  void _internal_set_turn_indicator(::HU::SensorEvent_Light_TURN_INDICATOR_STATE value);
  public:

  // optional bool hazard_light_on = 3;
  bool has_hazard_light_on() const;
  private:
  bool _internal_has_hazard_light_on() const;
  public:
  void clear_hazard_light_on();
  bool hazard_light_on() const;
  void set_hazard_light_on(bool value);
  private:
  bool _internal_hazard_light_on() const;
  void _internal_set_hazard_light_on(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.Light)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int headlight_;
  int turn_indicator_;
  bool hazard_light_on_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent_GearData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent.GearData) */ {
 public:
  inline SensorEvent_GearData() : SensorEvent_GearData(nullptr) {};
  virtual ~SensorEvent_GearData();

  SensorEvent_GearData(const SensorEvent_GearData& from);
  SensorEvent_GearData(SensorEvent_GearData&& from) noexcept
    : SensorEvent_GearData() {
    *this = ::std::move(from);
  }

  inline SensorEvent_GearData& operator=(const SensorEvent_GearData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent_GearData& operator=(SensorEvent_GearData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent_GearData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent_GearData* internal_default_instance() {
    return reinterpret_cast<const SensorEvent_GearData*>(
               &_SensorEvent_GearData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SensorEvent_GearData& a, SensorEvent_GearData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent_GearData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent_GearData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent_GearData* New() const final {
    return CreateMaybeMessage<SensorEvent_GearData>(nullptr);
  }

  SensorEvent_GearData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent_GearData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent_GearData& from);
  void MergeFrom(const SensorEvent_GearData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent_GearData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent.GearData";
  }
  protected:
  explicit SensorEvent_GearData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SensorEvent_GearData_GEAR GEAR;
  static constexpr GEAR GEAR_DRIVE =
    SensorEvent_GearData_GEAR_GEAR_DRIVE;
  static constexpr GEAR GEAR_EIGHTH =
    SensorEvent_GearData_GEAR_GEAR_EIGHTH;
  static constexpr GEAR GEAR_FIFTH =
    SensorEvent_GearData_GEAR_GEAR_FIFTH;
  static constexpr GEAR GEAR_FIRST =
    SensorEvent_GearData_GEAR_GEAR_FIRST;
  static constexpr GEAR GEAR_FOURTH =
    SensorEvent_GearData_GEAR_GEAR_FOURTH;
  static constexpr GEAR GEAR_NEUTRAL =
    SensorEvent_GearData_GEAR_GEAR_NEUTRAL;
  static constexpr GEAR GEAR_NINTH =
    SensorEvent_GearData_GEAR_GEAR_NINTH;
  static constexpr GEAR GEAR_PARK =
    SensorEvent_GearData_GEAR_GEAR_PARK;
  static constexpr GEAR GEAR_REVERSE =
    SensorEvent_GearData_GEAR_GEAR_REVERSE;
  static constexpr GEAR GEAR_SECOND =
    SensorEvent_GearData_GEAR_GEAR_SECOND;
  static constexpr GEAR GEAR_SEVENTH =
    SensorEvent_GearData_GEAR_GEAR_SEVENTH;
  static constexpr GEAR GEAR_SIXTH =
    SensorEvent_GearData_GEAR_GEAR_SIXTH;
  static constexpr GEAR GEAR_TENTH =
    SensorEvent_GearData_GEAR_GEAR_TENTH;
  static constexpr GEAR GEAR_THIRD =
    SensorEvent_GearData_GEAR_GEAR_THIRD;
  static inline bool GEAR_IsValid(int value) {
    return SensorEvent_GearData_GEAR_IsValid(value);
  }
  static constexpr GEAR GEAR_MIN =
    SensorEvent_GearData_GEAR_GEAR_MIN;
  static constexpr GEAR GEAR_MAX =
    SensorEvent_GearData_GEAR_GEAR_MAX;
  static constexpr int GEAR_ARRAYSIZE =
    SensorEvent_GearData_GEAR_GEAR_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GEAR_descriptor() {
    return SensorEvent_GearData_GEAR_descriptor();
  }
  template<typename T>
  static inline const std::string& GEAR_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GEAR>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GEAR_Name.");
    return SensorEvent_GearData_GEAR_Name(enum_t_value);
  }
  static inline bool GEAR_Parse(const std::string& name,
      GEAR* value) {
    return SensorEvent_GearData_GEAR_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGearFieldNumber = 1,
  };
  // required .HU.SensorEvent.GearData.GEAR gear = 1;
  bool has_gear() const;
  private:
  bool _internal_has_gear() const;
  public:
  void clear_gear();
  ::HU::SensorEvent_GearData_GEAR gear() const;
  void set_gear(::HU::SensorEvent_GearData_GEAR value);
  private:
  ::HU::SensorEvent_GearData_GEAR _internal_gear() const;
  void _internal_set_gear(::HU::SensorEvent_GearData_GEAR value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorEvent.GearData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int gear_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorEvent) */ {
 public:
  inline SensorEvent() : SensorEvent(nullptr) {};
  virtual ~SensorEvent();

  SensorEvent(const SensorEvent& from);
  SensorEvent(SensorEvent&& from) noexcept
    : SensorEvent() {
    *this = ::std::move(from);
  }

  inline SensorEvent& operator=(const SensorEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorEvent& operator=(SensorEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorEvent* internal_default_instance() {
    return reinterpret_cast<const SensorEvent*>(
               &_SensorEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(SensorEvent& a, SensorEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorEvent* New() const final {
    return CreateMaybeMessage<SensorEvent>(nullptr);
  }

  SensorEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorEvent& from);
  void MergeFrom(const SensorEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorEvent";
  }
  protected:
  explicit SensorEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SensorEvent_LocationData LocationData;
  typedef SensorEvent_NightMode NightMode;
  typedef SensorEvent_RPM RPM;
  typedef SensorEvent_FuelLevel FuelLevel;
  typedef SensorEvent_DrivingStatus DrivingStatus;
  typedef SensorEvent_DeadReckoning DeadReckoning;
  typedef SensorEvent_CompassData CompassData;
  typedef SensorEvent_SpeedData SpeedData;
  typedef SensorEvent_OdometerData OdometerData;
  typedef SensorEvent_ParkingBreak ParkingBreak;
  typedef SensorEvent_Passenger Passenger;
  typedef SensorEvent_Diagnostics Diagnostics;
  typedef SensorEvent_Environment Environment;
  typedef SensorEvent_HVAC HVAC;
  typedef SensorEvent_Accel Accel;
  typedef SensorEvent_Gyro Gyro;
  typedef SensorEvent_Door Door;
  typedef SensorEvent_Light Light;
  typedef SensorEvent_GearData GearData;

  // accessors -------------------------------------------------------

  enum : int {
    kLocationDataFieldNumber = 1,
    kCompassDataFieldNumber = 2,
    kSpeedDataFieldNumber = 3,
    kRpmFieldNumber = 4,
    kOdometerDataFieldNumber = 5,
    kFuelDataFieldNumber = 6,
    kParkingbrakeDataFieldNumber = 7,
    kGearDataFieldNumber = 8,
    kDiagnosticsDataFieldNumber = 9,
    kNightModeFieldNumber = 10,
    kEnviormentDataFieldNumber = 11,
    kHvacDataFieldNumber = 12,
    kDrivingStatusFieldNumber = 13,
    kDeadReckoningFieldNumber = 14,
    kPassengerDataFieldNumber = 15,
    kDoorDataFieldNumber = 16,
    kLightDataFieldNumber = 17,
    kAccelDataFieldNumber = 19,
    kGyroDataFieldNumber = 20,
  };
  // repeated .HU.SensorEvent.LocationData location_data = 1;
  int location_data_size() const;
  private:
  int _internal_location_data_size() const;
  public:
  void clear_location_data();
  ::HU::SensorEvent_LocationData* mutable_location_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_LocationData >*
      mutable_location_data();
  private:
  const ::HU::SensorEvent_LocationData& _internal_location_data(int index) const;
  ::HU::SensorEvent_LocationData* _internal_add_location_data();
  public:
  const ::HU::SensorEvent_LocationData& location_data(int index) const;
  ::HU::SensorEvent_LocationData* add_location_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_LocationData >&
      location_data() const;

  // repeated .HU.SensorEvent.CompassData compass_data = 2;
  int compass_data_size() const;
  private:
  int _internal_compass_data_size() const;
  public:
  void clear_compass_data();
  ::HU::SensorEvent_CompassData* mutable_compass_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_CompassData >*
      mutable_compass_data();
  private:
  const ::HU::SensorEvent_CompassData& _internal_compass_data(int index) const;
  ::HU::SensorEvent_CompassData* _internal_add_compass_data();
  public:
  const ::HU::SensorEvent_CompassData& compass_data(int index) const;
  ::HU::SensorEvent_CompassData* add_compass_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_CompassData >&
      compass_data() const;

  // repeated .HU.SensorEvent.SpeedData speed_data = 3;
  int speed_data_size() const;
  private:
  int _internal_speed_data_size() const;
  public:
  void clear_speed_data();
  ::HU::SensorEvent_SpeedData* mutable_speed_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_SpeedData >*
      mutable_speed_data();
  private:
  const ::HU::SensorEvent_SpeedData& _internal_speed_data(int index) const;
  ::HU::SensorEvent_SpeedData* _internal_add_speed_data();
  public:
  const ::HU::SensorEvent_SpeedData& speed_data(int index) const;
  ::HU::SensorEvent_SpeedData* add_speed_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_SpeedData >&
      speed_data() const;

  // repeated .HU.SensorEvent.RPM rpm = 4;
  int rpm_size() const;
  private:
  int _internal_rpm_size() const;
  public:
  void clear_rpm();
  ::HU::SensorEvent_RPM* mutable_rpm(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_RPM >*
      mutable_rpm();
  private:
  const ::HU::SensorEvent_RPM& _internal_rpm(int index) const;
  ::HU::SensorEvent_RPM* _internal_add_rpm();
  public:
  const ::HU::SensorEvent_RPM& rpm(int index) const;
  ::HU::SensorEvent_RPM* add_rpm();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_RPM >&
      rpm() const;

  // repeated .HU.SensorEvent.OdometerData odometer_data = 5;
  int odometer_data_size() const;
  private:
  int _internal_odometer_data_size() const;
  public:
  void clear_odometer_data();
  ::HU::SensorEvent_OdometerData* mutable_odometer_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_OdometerData >*
      mutable_odometer_data();
  private:
  const ::HU::SensorEvent_OdometerData& _internal_odometer_data(int index) const;
  ::HU::SensorEvent_OdometerData* _internal_add_odometer_data();
  public:
  const ::HU::SensorEvent_OdometerData& odometer_data(int index) const;
  ::HU::SensorEvent_OdometerData* add_odometer_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_OdometerData >&
      odometer_data() const;

  // repeated .HU.SensorEvent.FuelLevel fuel_data = 6;
  int fuel_data_size() const;
  private:
  int _internal_fuel_data_size() const;
  public:
  void clear_fuel_data();
  ::HU::SensorEvent_FuelLevel* mutable_fuel_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_FuelLevel >*
      mutable_fuel_data();
  private:
  const ::HU::SensorEvent_FuelLevel& _internal_fuel_data(int index) const;
  ::HU::SensorEvent_FuelLevel* _internal_add_fuel_data();
  public:
  const ::HU::SensorEvent_FuelLevel& fuel_data(int index) const;
  ::HU::SensorEvent_FuelLevel* add_fuel_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_FuelLevel >&
      fuel_data() const;

  // repeated .HU.SensorEvent.ParkingBreak parkingbrake_data = 7;
  int parkingbrake_data_size() const;
  private:
  int _internal_parkingbrake_data_size() const;
  public:
  void clear_parkingbrake_data();
  ::HU::SensorEvent_ParkingBreak* mutable_parkingbrake_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_ParkingBreak >*
      mutable_parkingbrake_data();
  private:
  const ::HU::SensorEvent_ParkingBreak& _internal_parkingbrake_data(int index) const;
  ::HU::SensorEvent_ParkingBreak* _internal_add_parkingbrake_data();
  public:
  const ::HU::SensorEvent_ParkingBreak& parkingbrake_data(int index) const;
  ::HU::SensorEvent_ParkingBreak* add_parkingbrake_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_ParkingBreak >&
      parkingbrake_data() const;

  // repeated .HU.SensorEvent.GearData gear_data = 8;
  int gear_data_size() const;
  private:
  int _internal_gear_data_size() const;
  public:
  void clear_gear_data();
  ::HU::SensorEvent_GearData* mutable_gear_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_GearData >*
      mutable_gear_data();
  private:
  const ::HU::SensorEvent_GearData& _internal_gear_data(int index) const;
  ::HU::SensorEvent_GearData* _internal_add_gear_data();
  public:
  const ::HU::SensorEvent_GearData& gear_data(int index) const;
  ::HU::SensorEvent_GearData* add_gear_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_GearData >&
      gear_data() const;

  // repeated .HU.SensorEvent.Diagnostics diagnostics_data = 9;
  int diagnostics_data_size() const;
  private:
  int _internal_diagnostics_data_size() const;
  public:
  void clear_diagnostics_data();
  ::HU::SensorEvent_Diagnostics* mutable_diagnostics_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Diagnostics >*
      mutable_diagnostics_data();
  private:
  const ::HU::SensorEvent_Diagnostics& _internal_diagnostics_data(int index) const;
  ::HU::SensorEvent_Diagnostics* _internal_add_diagnostics_data();
  public:
  const ::HU::SensorEvent_Diagnostics& diagnostics_data(int index) const;
  ::HU::SensorEvent_Diagnostics* add_diagnostics_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Diagnostics >&
      diagnostics_data() const;

  // repeated .HU.SensorEvent.NightMode night_mode = 10;
  int night_mode_size() const;
  private:
  int _internal_night_mode_size() const;
  public:
  void clear_night_mode();
  ::HU::SensorEvent_NightMode* mutable_night_mode(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_NightMode >*
      mutable_night_mode();
  private:
  const ::HU::SensorEvent_NightMode& _internal_night_mode(int index) const;
  ::HU::SensorEvent_NightMode* _internal_add_night_mode();
  public:
  const ::HU::SensorEvent_NightMode& night_mode(int index) const;
  ::HU::SensorEvent_NightMode* add_night_mode();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_NightMode >&
      night_mode() const;

  // repeated .HU.SensorEvent.Environment enviorment_data = 11;
  int enviorment_data_size() const;
  private:
  int _internal_enviorment_data_size() const;
  public:
  void clear_enviorment_data();
  ::HU::SensorEvent_Environment* mutable_enviorment_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Environment >*
      mutable_enviorment_data();
  private:
  const ::HU::SensorEvent_Environment& _internal_enviorment_data(int index) const;
  ::HU::SensorEvent_Environment* _internal_add_enviorment_data();
  public:
  const ::HU::SensorEvent_Environment& enviorment_data(int index) const;
  ::HU::SensorEvent_Environment* add_enviorment_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Environment >&
      enviorment_data() const;

  // repeated .HU.SensorEvent.HVAC hvac_data = 12;
  int hvac_data_size() const;
  private:
  int _internal_hvac_data_size() const;
  public:
  void clear_hvac_data();
  ::HU::SensorEvent_HVAC* mutable_hvac_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_HVAC >*
      mutable_hvac_data();
  private:
  const ::HU::SensorEvent_HVAC& _internal_hvac_data(int index) const;
  ::HU::SensorEvent_HVAC* _internal_add_hvac_data();
  public:
  const ::HU::SensorEvent_HVAC& hvac_data(int index) const;
  ::HU::SensorEvent_HVAC* add_hvac_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_HVAC >&
      hvac_data() const;

  // repeated .HU.SensorEvent.DrivingStatus driving_status = 13;
  int driving_status_size() const;
  private:
  int _internal_driving_status_size() const;
  public:
  void clear_driving_status();
  ::HU::SensorEvent_DrivingStatus* mutable_driving_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DrivingStatus >*
      mutable_driving_status();
  private:
  const ::HU::SensorEvent_DrivingStatus& _internal_driving_status(int index) const;
  ::HU::SensorEvent_DrivingStatus* _internal_add_driving_status();
  public:
  const ::HU::SensorEvent_DrivingStatus& driving_status(int index) const;
  ::HU::SensorEvent_DrivingStatus* add_driving_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DrivingStatus >&
      driving_status() const;

  // repeated .HU.SensorEvent.DeadReckoning dead_reckoning = 14;
  int dead_reckoning_size() const;
  private:
  int _internal_dead_reckoning_size() const;
  public:
  void clear_dead_reckoning();
  ::HU::SensorEvent_DeadReckoning* mutable_dead_reckoning(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DeadReckoning >*
      mutable_dead_reckoning();
  private:
  const ::HU::SensorEvent_DeadReckoning& _internal_dead_reckoning(int index) const;
  ::HU::SensorEvent_DeadReckoning* _internal_add_dead_reckoning();
  public:
  const ::HU::SensorEvent_DeadReckoning& dead_reckoning(int index) const;
  ::HU::SensorEvent_DeadReckoning* add_dead_reckoning();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DeadReckoning >&
      dead_reckoning() const;

  // repeated .HU.SensorEvent.Passenger passenger_data = 15;
  int passenger_data_size() const;
  private:
  int _internal_passenger_data_size() const;
  public:
  void clear_passenger_data();
  ::HU::SensorEvent_Passenger* mutable_passenger_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Passenger >*
      mutable_passenger_data();
  private:
  const ::HU::SensorEvent_Passenger& _internal_passenger_data(int index) const;
  ::HU::SensorEvent_Passenger* _internal_add_passenger_data();
  public:
  const ::HU::SensorEvent_Passenger& passenger_data(int index) const;
  ::HU::SensorEvent_Passenger* add_passenger_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Passenger >&
      passenger_data() const;

  // repeated .HU.SensorEvent.Door door_data = 16;
  int door_data_size() const;
  private:
  int _internal_door_data_size() const;
  public:
  void clear_door_data();
  ::HU::SensorEvent_Door* mutable_door_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Door >*
      mutable_door_data();
  private:
  const ::HU::SensorEvent_Door& _internal_door_data(int index) const;
  ::HU::SensorEvent_Door* _internal_add_door_data();
  public:
  const ::HU::SensorEvent_Door& door_data(int index) const;
  ::HU::SensorEvent_Door* add_door_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Door >&
      door_data() const;

  // repeated .HU.SensorEvent.Light light_data = 17;
  int light_data_size() const;
  private:
  int _internal_light_data_size() const;
  public:
  void clear_light_data();
  ::HU::SensorEvent_Light* mutable_light_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Light >*
      mutable_light_data();
  private:
  const ::HU::SensorEvent_Light& _internal_light_data(int index) const;
  ::HU::SensorEvent_Light* _internal_add_light_data();
  public:
  const ::HU::SensorEvent_Light& light_data(int index) const;
  ::HU::SensorEvent_Light* add_light_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Light >&
      light_data() const;

  // repeated .HU.SensorEvent.Accel accel_data = 19;
  int accel_data_size() const;
  private:
  int _internal_accel_data_size() const;
  public:
  void clear_accel_data();
  ::HU::SensorEvent_Accel* mutable_accel_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Accel >*
      mutable_accel_data();
  private:
  const ::HU::SensorEvent_Accel& _internal_accel_data(int index) const;
  ::HU::SensorEvent_Accel* _internal_add_accel_data();
  public:
  const ::HU::SensorEvent_Accel& accel_data(int index) const;
  ::HU::SensorEvent_Accel* add_accel_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Accel >&
      accel_data() const;

  // repeated .HU.SensorEvent.Gyro gyro_data = 20;
  int gyro_data_size() const;
  private:
  int _internal_gyro_data_size() const;
  public:
  void clear_gyro_data();
  ::HU::SensorEvent_Gyro* mutable_gyro_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Gyro >*
      mutable_gyro_data();
  private:
  const ::HU::SensorEvent_Gyro& _internal_gyro_data(int index) const;
  ::HU::SensorEvent_Gyro* _internal_add_gyro_data();
  public:
  const ::HU::SensorEvent_Gyro& gyro_data(int index) const;
  ::HU::SensorEvent_Gyro* add_gyro_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Gyro >&
      gyro_data() const;

  // @@protoc_insertion_point(class_scope:HU.SensorEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_LocationData > location_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_CompassData > compass_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_SpeedData > speed_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_RPM > rpm_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_OdometerData > odometer_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_FuelLevel > fuel_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_ParkingBreak > parkingbrake_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_GearData > gear_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Diagnostics > diagnostics_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_NightMode > night_mode_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Environment > enviorment_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_HVAC > hvac_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DrivingStatus > driving_status_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DeadReckoning > dead_reckoning_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Passenger > passenger_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Door > door_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Light > light_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Accel > accel_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Gyro > gyro_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class AudioCofig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.AudioCofig) */ {
 public:
  inline AudioCofig() : AudioCofig(nullptr) {};
  virtual ~AudioCofig();

  AudioCofig(const AudioCofig& from);
  AudioCofig(AudioCofig&& from) noexcept
    : AudioCofig() {
    *this = ::std::move(from);
  }

  inline AudioCofig& operator=(const AudioCofig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioCofig& operator=(AudioCofig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioCofig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioCofig* internal_default_instance() {
    return reinterpret_cast<const AudioCofig*>(
               &_AudioCofig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AudioCofig& a, AudioCofig& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioCofig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioCofig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioCofig* New() const final {
    return CreateMaybeMessage<AudioCofig>(nullptr);
  }

  AudioCofig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioCofig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioCofig& from);
  void MergeFrom(const AudioCofig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioCofig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.AudioCofig";
  }
  protected:
  explicit AudioCofig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleRateFieldNumber = 1,
    kBitDepthFieldNumber = 2,
    kChannelCountFieldNumber = 3,
  };
  // required uint32 sample_rate = 1;
  bool has_sample_rate() const;
  private:
  bool _internal_has_sample_rate() const;
  public:
  void clear_sample_rate();
  ::PROTOBUF_NAMESPACE_ID::uint32 sample_rate() const;
  void set_sample_rate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sample_rate() const;
  void _internal_set_sample_rate(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 bit_depth = 2;
  bool has_bit_depth() const;
  private:
  bool _internal_has_bit_depth() const;
  public:
  void clear_bit_depth();
  ::PROTOBUF_NAMESPACE_ID::uint32 bit_depth() const;
  void set_bit_depth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_bit_depth() const;
  void _internal_set_bit_depth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 channel_count = 3;
  bool has_channel_count() const;
  private:
  bool _internal_has_channel_count() const;
  public:
  void clear_channel_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_count() const;
  void set_channel_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_count() const;
  void _internal_set_channel_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.AudioCofig)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sample_rate_;
  ::PROTOBUF_NAMESPACE_ID::uint32 bit_depth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_count_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_SensorChannel_Sensor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.SensorChannel.Sensor) */ {
 public:
  inline ChannelDescriptor_SensorChannel_Sensor() : ChannelDescriptor_SensorChannel_Sensor(nullptr) {};
  virtual ~ChannelDescriptor_SensorChannel_Sensor();

  ChannelDescriptor_SensorChannel_Sensor(const ChannelDescriptor_SensorChannel_Sensor& from);
  ChannelDescriptor_SensorChannel_Sensor(ChannelDescriptor_SensorChannel_Sensor&& from) noexcept
    : ChannelDescriptor_SensorChannel_Sensor() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_SensorChannel_Sensor& operator=(const ChannelDescriptor_SensorChannel_Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_SensorChannel_Sensor& operator=(ChannelDescriptor_SensorChannel_Sensor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_SensorChannel_Sensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_SensorChannel_Sensor* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_SensorChannel_Sensor*>(
               &_ChannelDescriptor_SensorChannel_Sensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ChannelDescriptor_SensorChannel_Sensor& a, ChannelDescriptor_SensorChannel_Sensor& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_SensorChannel_Sensor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_SensorChannel_Sensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_SensorChannel_Sensor* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_SensorChannel_Sensor>(nullptr);
  }

  ChannelDescriptor_SensorChannel_Sensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_SensorChannel_Sensor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_SensorChannel_Sensor& from);
  void MergeFrom(const ChannelDescriptor_SensorChannel_Sensor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_SensorChannel_Sensor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.SensorChannel.Sensor";
  }
  protected:
  explicit ChannelDescriptor_SensorChannel_Sensor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .HU.SENSOR_TYPE type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::HU::SENSOR_TYPE type() const;
  void set_type(::HU::SENSOR_TYPE value);
  private:
  ::HU::SENSOR_TYPE _internal_type() const;
  void _internal_set_type(::HU::SENSOR_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.SensorChannel.Sensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_SensorChannel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.SensorChannel) */ {
 public:
  inline ChannelDescriptor_SensorChannel() : ChannelDescriptor_SensorChannel(nullptr) {};
  virtual ~ChannelDescriptor_SensorChannel();

  ChannelDescriptor_SensorChannel(const ChannelDescriptor_SensorChannel& from);
  ChannelDescriptor_SensorChannel(ChannelDescriptor_SensorChannel&& from) noexcept
    : ChannelDescriptor_SensorChannel() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_SensorChannel& operator=(const ChannelDescriptor_SensorChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_SensorChannel& operator=(ChannelDescriptor_SensorChannel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_SensorChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_SensorChannel* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_SensorChannel*>(
               &_ChannelDescriptor_SensorChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ChannelDescriptor_SensorChannel& a, ChannelDescriptor_SensorChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_SensorChannel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_SensorChannel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_SensorChannel* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_SensorChannel>(nullptr);
  }

  ChannelDescriptor_SensorChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_SensorChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_SensorChannel& from);
  void MergeFrom(const ChannelDescriptor_SensorChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_SensorChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.SensorChannel";
  }
  protected:
  explicit ChannelDescriptor_SensorChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChannelDescriptor_SensorChannel_Sensor Sensor;

  // accessors -------------------------------------------------------

  enum : int {
    kSensorListFieldNumber = 1,
  };
  // repeated .HU.ChannelDescriptor.SensorChannel.Sensor sensor_list = 1;
  int sensor_list_size() const;
  private:
  int _internal_sensor_list_size() const;
  public:
  void clear_sensor_list();
  ::HU::ChannelDescriptor_SensorChannel_Sensor* mutable_sensor_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_SensorChannel_Sensor >*
      mutable_sensor_list();
  private:
  const ::HU::ChannelDescriptor_SensorChannel_Sensor& _internal_sensor_list(int index) const;
  ::HU::ChannelDescriptor_SensorChannel_Sensor* _internal_add_sensor_list();
  public:
  const ::HU::ChannelDescriptor_SensorChannel_Sensor& sensor_list(int index) const;
  ::HU::ChannelDescriptor_SensorChannel_Sensor* add_sensor_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_SensorChannel_Sensor >&
      sensor_list() const;

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.SensorChannel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_SensorChannel_Sensor > sensor_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_OutputStreamChannel_VideoConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig) */ {
 public:
  inline ChannelDescriptor_OutputStreamChannel_VideoConfig() : ChannelDescriptor_OutputStreamChannel_VideoConfig(nullptr) {};
  virtual ~ChannelDescriptor_OutputStreamChannel_VideoConfig();

  ChannelDescriptor_OutputStreamChannel_VideoConfig(const ChannelDescriptor_OutputStreamChannel_VideoConfig& from);
  ChannelDescriptor_OutputStreamChannel_VideoConfig(ChannelDescriptor_OutputStreamChannel_VideoConfig&& from) noexcept
    : ChannelDescriptor_OutputStreamChannel_VideoConfig() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_OutputStreamChannel_VideoConfig& operator=(const ChannelDescriptor_OutputStreamChannel_VideoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_OutputStreamChannel_VideoConfig& operator=(ChannelDescriptor_OutputStreamChannel_VideoConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_OutputStreamChannel_VideoConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_OutputStreamChannel_VideoConfig* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_OutputStreamChannel_VideoConfig*>(
               &_ChannelDescriptor_OutputStreamChannel_VideoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ChannelDescriptor_OutputStreamChannel_VideoConfig& a, ChannelDescriptor_OutputStreamChannel_VideoConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_OutputStreamChannel_VideoConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_OutputStreamChannel_VideoConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_OutputStreamChannel_VideoConfig* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_OutputStreamChannel_VideoConfig>(nullptr);
  }

  ChannelDescriptor_OutputStreamChannel_VideoConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_OutputStreamChannel_VideoConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_OutputStreamChannel_VideoConfig& from);
  void MergeFrom(const ChannelDescriptor_OutputStreamChannel_VideoConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_OutputStreamChannel_VideoConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.OutputStreamChannel.VideoConfig";
  }
  protected:
  explicit ChannelDescriptor_OutputStreamChannel_VideoConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION VIDEO_RESOLUTION;
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_800x480 =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_800x480;
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_1280x720 =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_1280x720;
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_1920x1080 =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_1920x1080;
  static inline bool VIDEO_RESOLUTION_IsValid(int value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_IsValid(value);
  }
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_MIN =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_MIN;
  static constexpr VIDEO_RESOLUTION VIDEO_RESOLUTION_MAX =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_MAX;
  static constexpr int VIDEO_RESOLUTION_ARRAYSIZE =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_VIDEO_RESOLUTION_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VIDEO_RESOLUTION_descriptor() {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor();
  }
  template<typename T>
  static inline const std::string& VIDEO_RESOLUTION_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VIDEO_RESOLUTION>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VIDEO_RESOLUTION_Name.");
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Name(enum_t_value);
  }
  static inline bool VIDEO_RESOLUTION_Parse(const std::string& name,
      VIDEO_RESOLUTION* value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_Parse(name, value);
  }

  typedef ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS VIDEO_FPS;
  static constexpr VIDEO_FPS VIDEO_FPS_30 =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_30;
  static constexpr VIDEO_FPS VIDEO_FPS_60 =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_60;
  static inline bool VIDEO_FPS_IsValid(int value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_IsValid(value);
  }
  static constexpr VIDEO_FPS VIDEO_FPS_MIN =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_MIN;
  static constexpr VIDEO_FPS VIDEO_FPS_MAX =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_MAX;
  static constexpr int VIDEO_FPS_ARRAYSIZE =
    ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_VIDEO_FPS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VIDEO_FPS_descriptor() {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor();
  }
  template<typename T>
  static inline const std::string& VIDEO_FPS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VIDEO_FPS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VIDEO_FPS_Name.");
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Name(enum_t_value);
  }
  static inline bool VIDEO_FPS_Parse(const std::string& name,
      VIDEO_FPS* value) {
    return ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMarginWidthFieldNumber = 3,
    kMarginHeightFieldNumber = 4,
    kDpiFieldNumber = 5,
    kAdditionalDepthFieldNumber = 6,
    kResolutionFieldNumber = 1,
    kFrameRateFieldNumber = 2,
  };
  // required uint32 margin_width = 3;
  bool has_margin_width() const;
  private:
  bool _internal_has_margin_width() const;
  public:
  void clear_margin_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 margin_width() const;
  void set_margin_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_margin_width() const;
  void _internal_set_margin_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 margin_height = 4;
  bool has_margin_height() const;
  private:
  bool _internal_has_margin_height() const;
  public:
  void clear_margin_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 margin_height() const;
  void set_margin_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_margin_height() const;
  void _internal_set_margin_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 dpi = 5;
  bool has_dpi() const;
  private:
  bool _internal_has_dpi() const;
  public:
  void clear_dpi();
  ::PROTOBUF_NAMESPACE_ID::uint32 dpi() const;
  void set_dpi(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_dpi() const;
  void _internal_set_dpi(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 additional_depth = 6;
  bool has_additional_depth() const;
  private:
  bool _internal_has_additional_depth() const;
  public:
  void clear_additional_depth();
  ::PROTOBUF_NAMESPACE_ID::uint32 additional_depth() const;
  void set_additional_depth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_additional_depth() const;
  void _internal_set_additional_depth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.VIDEO_RESOLUTION resolution = 1;
  bool has_resolution() const;
  private:
  bool _internal_has_resolution() const;
  public:
  void clear_resolution();
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION resolution() const;
  void set_resolution(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION value);
  private:
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION _internal_resolution() const;
  void _internal_set_resolution(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION value);
  public:

  // required .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.VIDEO_FPS frame_rate = 2;
  bool has_frame_rate() const;
  private:
  bool _internal_has_frame_rate() const;
  public:
  void clear_frame_rate();
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS frame_rate() const;
  void set_frame_rate(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS value);
  private:
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS _internal_frame_rate() const;
  void _internal_set_frame_rate(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 margin_width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 margin_height_;
  ::PROTOBUF_NAMESPACE_ID::uint32 dpi_;
  ::PROTOBUF_NAMESPACE_ID::uint32 additional_depth_;
  int resolution_;
  int frame_rate_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_OutputStreamChannel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.OutputStreamChannel) */ {
 public:
  inline ChannelDescriptor_OutputStreamChannel() : ChannelDescriptor_OutputStreamChannel(nullptr) {};
  virtual ~ChannelDescriptor_OutputStreamChannel();

  ChannelDescriptor_OutputStreamChannel(const ChannelDescriptor_OutputStreamChannel& from);
  ChannelDescriptor_OutputStreamChannel(ChannelDescriptor_OutputStreamChannel&& from) noexcept
    : ChannelDescriptor_OutputStreamChannel() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_OutputStreamChannel& operator=(const ChannelDescriptor_OutputStreamChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_OutputStreamChannel& operator=(ChannelDescriptor_OutputStreamChannel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_OutputStreamChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_OutputStreamChannel* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_OutputStreamChannel*>(
               &_ChannelDescriptor_OutputStreamChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ChannelDescriptor_OutputStreamChannel& a, ChannelDescriptor_OutputStreamChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_OutputStreamChannel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_OutputStreamChannel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_OutputStreamChannel* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_OutputStreamChannel>(nullptr);
  }

  ChannelDescriptor_OutputStreamChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_OutputStreamChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_OutputStreamChannel& from);
  void MergeFrom(const ChannelDescriptor_OutputStreamChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_OutputStreamChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.OutputStreamChannel";
  }
  protected:
  explicit ChannelDescriptor_OutputStreamChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChannelDescriptor_OutputStreamChannel_VideoConfig VideoConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kAudioConfigsFieldNumber = 3,
    kVideoConfigsFieldNumber = 4,
    kAvailableWhileInCallFieldNumber = 5,
    kTypeFieldNumber = 1,
    kAudioTypeFieldNumber = 2,
  };
  // repeated .HU.AudioCofig audio_configs = 3;
  int audio_configs_size() const;
  private:
  int _internal_audio_configs_size() const;
  public:
  void clear_audio_configs();
  ::HU::AudioCofig* mutable_audio_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::AudioCofig >*
      mutable_audio_configs();
  private:
  const ::HU::AudioCofig& _internal_audio_configs(int index) const;
  ::HU::AudioCofig* _internal_add_audio_configs();
  public:
  const ::HU::AudioCofig& audio_configs(int index) const;
  ::HU::AudioCofig* add_audio_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::AudioCofig >&
      audio_configs() const;

  // repeated .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig video_configs = 4;
  int video_configs_size() const;
  private:
  int _internal_video_configs_size() const;
  public:
  void clear_video_configs();
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* mutable_video_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig >*
      mutable_video_configs();
  private:
  const ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig& _internal_video_configs(int index) const;
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* _internal_add_video_configs();
  public:
  const ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig& video_configs(int index) const;
  ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* add_video_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig >&
      video_configs() const;

  // optional bool available_while_in_call = 5;
  bool has_available_while_in_call() const;
  private:
  bool _internal_has_available_while_in_call() const;
  public:
  void clear_available_while_in_call();
  bool available_while_in_call() const;
  void set_available_while_in_call(bool value);
  private:
  bool _internal_available_while_in_call() const;
  void _internal_set_available_while_in_call(bool value);
  public:

  // required .HU.STREAM_TYPE type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::HU::STREAM_TYPE type() const;
  void set_type(::HU::STREAM_TYPE value);
  private:
  ::HU::STREAM_TYPE _internal_type() const;
  void _internal_set_type(::HU::STREAM_TYPE value);
  public:

  // optional .HU.AUDIO_TYPE audio_type = 2;
  bool has_audio_type() const;
  private:
  bool _internal_has_audio_type() const;
  public:
  void clear_audio_type();
  ::HU::AUDIO_TYPE audio_type() const;
  void set_audio_type(::HU::AUDIO_TYPE value);
  private:
  ::HU::AUDIO_TYPE _internal_audio_type() const;
  void _internal_set_audio_type(::HU::AUDIO_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.OutputStreamChannel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::AudioCofig > audio_configs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig > video_configs_;
  bool available_while_in_call_;
  int type_;
  int audio_type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_InputEventChannel_TouchScreenConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig) */ {
 public:
  inline ChannelDescriptor_InputEventChannel_TouchScreenConfig() : ChannelDescriptor_InputEventChannel_TouchScreenConfig(nullptr) {};
  virtual ~ChannelDescriptor_InputEventChannel_TouchScreenConfig();

  ChannelDescriptor_InputEventChannel_TouchScreenConfig(const ChannelDescriptor_InputEventChannel_TouchScreenConfig& from);
  ChannelDescriptor_InputEventChannel_TouchScreenConfig(ChannelDescriptor_InputEventChannel_TouchScreenConfig&& from) noexcept
    : ChannelDescriptor_InputEventChannel_TouchScreenConfig() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_InputEventChannel_TouchScreenConfig& operator=(const ChannelDescriptor_InputEventChannel_TouchScreenConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_InputEventChannel_TouchScreenConfig& operator=(ChannelDescriptor_InputEventChannel_TouchScreenConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_InputEventChannel_TouchScreenConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_InputEventChannel_TouchScreenConfig* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(
               &_ChannelDescriptor_InputEventChannel_TouchScreenConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ChannelDescriptor_InputEventChannel_TouchScreenConfig& a, ChannelDescriptor_InputEventChannel_TouchScreenConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_InputEventChannel_TouchScreenConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_InputEventChannel_TouchScreenConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_InputEventChannel_TouchScreenConfig* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_InputEventChannel_TouchScreenConfig>(nullptr);
  }

  ChannelDescriptor_InputEventChannel_TouchScreenConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_InputEventChannel_TouchScreenConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_InputEventChannel_TouchScreenConfig& from);
  void MergeFrom(const ChannelDescriptor_InputEventChannel_TouchScreenConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_InputEventChannel_TouchScreenConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig";
  }
  protected:
  explicit ChannelDescriptor_InputEventChannel_TouchScreenConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // required uint32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_InputEventChannel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.InputEventChannel) */ {
 public:
  inline ChannelDescriptor_InputEventChannel() : ChannelDescriptor_InputEventChannel(nullptr) {};
  virtual ~ChannelDescriptor_InputEventChannel();

  ChannelDescriptor_InputEventChannel(const ChannelDescriptor_InputEventChannel& from);
  ChannelDescriptor_InputEventChannel(ChannelDescriptor_InputEventChannel&& from) noexcept
    : ChannelDescriptor_InputEventChannel() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_InputEventChannel& operator=(const ChannelDescriptor_InputEventChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_InputEventChannel& operator=(ChannelDescriptor_InputEventChannel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_InputEventChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_InputEventChannel* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_InputEventChannel*>(
               &_ChannelDescriptor_InputEventChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ChannelDescriptor_InputEventChannel& a, ChannelDescriptor_InputEventChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_InputEventChannel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_InputEventChannel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_InputEventChannel* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_InputEventChannel>(nullptr);
  }

  ChannelDescriptor_InputEventChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_InputEventChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_InputEventChannel& from);
  void MergeFrom(const ChannelDescriptor_InputEventChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_InputEventChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.InputEventChannel";
  }
  protected:
  explicit ChannelDescriptor_InputEventChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChannelDescriptor_InputEventChannel_TouchScreenConfig TouchScreenConfig;

  // accessors -------------------------------------------------------

  enum : int {
    kKeycodesSupportedFieldNumber = 1,
    kTouchScreenConfigFieldNumber = 2,
    kTouchPadConfigFieldNumber = 3,
  };
  // repeated uint32 keycodes_supported = 1;
  int keycodes_supported_size() const;
  private:
  int _internal_keycodes_supported_size() const;
  public:
  void clear_keycodes_supported();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_keycodes_supported(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_keycodes_supported() const;
  void _internal_add_keycodes_supported(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_keycodes_supported();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 keycodes_supported(int index) const;
  void set_keycodes_supported(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_keycodes_supported(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      keycodes_supported() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_keycodes_supported();

  // optional .HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig touch_screen_config = 2;
  bool has_touch_screen_config() const;
  private:
  bool _internal_has_touch_screen_config() const;
  public:
  void clear_touch_screen_config();
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& touch_screen_config() const;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* release_touch_screen_config();
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* mutable_touch_screen_config();
  void set_allocated_touch_screen_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_screen_config);
  private:
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& _internal_touch_screen_config() const;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* _internal_mutable_touch_screen_config();
  public:
  void unsafe_arena_set_allocated_touch_screen_config(
      ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_screen_config);
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* unsafe_arena_release_touch_screen_config();

  // optional .HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig touch_pad_config = 3;
  bool has_touch_pad_config() const;
  private:
  bool _internal_has_touch_pad_config() const;
  public:
  void clear_touch_pad_config();
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& touch_pad_config() const;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* release_touch_pad_config();
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* mutable_touch_pad_config();
  void set_allocated_touch_pad_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_pad_config);
  private:
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& _internal_touch_pad_config() const;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* _internal_mutable_touch_pad_config();
  public:
  void unsafe_arena_set_allocated_touch_pad_config(
      ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_pad_config);
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* unsafe_arena_release_touch_pad_config();

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.InputEventChannel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > keycodes_supported_;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_screen_config_;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_pad_config_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_InputStreamChannel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.InputStreamChannel) */ {
 public:
  inline ChannelDescriptor_InputStreamChannel() : ChannelDescriptor_InputStreamChannel(nullptr) {};
  virtual ~ChannelDescriptor_InputStreamChannel();

  ChannelDescriptor_InputStreamChannel(const ChannelDescriptor_InputStreamChannel& from);
  ChannelDescriptor_InputStreamChannel(ChannelDescriptor_InputStreamChannel&& from) noexcept
    : ChannelDescriptor_InputStreamChannel() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_InputStreamChannel& operator=(const ChannelDescriptor_InputStreamChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_InputStreamChannel& operator=(ChannelDescriptor_InputStreamChannel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_InputStreamChannel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_InputStreamChannel* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_InputStreamChannel*>(
               &_ChannelDescriptor_InputStreamChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(ChannelDescriptor_InputStreamChannel& a, ChannelDescriptor_InputStreamChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_InputStreamChannel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_InputStreamChannel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_InputStreamChannel* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_InputStreamChannel>(nullptr);
  }

  ChannelDescriptor_InputStreamChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_InputStreamChannel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_InputStreamChannel& from);
  void MergeFrom(const ChannelDescriptor_InputStreamChannel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_InputStreamChannel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.InputStreamChannel";
  }
  protected:
  explicit ChannelDescriptor_InputStreamChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioConfigFieldNumber = 2,
    kAvailableWhileInCallFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // required .HU.AudioCofig audio_config = 2;
  bool has_audio_config() const;
  private:
  bool _internal_has_audio_config() const;
  public:
  void clear_audio_config();
  const ::HU::AudioCofig& audio_config() const;
  ::HU::AudioCofig* release_audio_config();
  ::HU::AudioCofig* mutable_audio_config();
  void set_allocated_audio_config(::HU::AudioCofig* audio_config);
  private:
  const ::HU::AudioCofig& _internal_audio_config() const;
  ::HU::AudioCofig* _internal_mutable_audio_config();
  public:
  void unsafe_arena_set_allocated_audio_config(
      ::HU::AudioCofig* audio_config);
  ::HU::AudioCofig* unsafe_arena_release_audio_config();

  // optional bool available_while_in_call = 3;
  bool has_available_while_in_call() const;
  private:
  bool _internal_has_available_while_in_call() const;
  public:
  void clear_available_while_in_call();
  bool available_while_in_call() const;
  void set_available_while_in_call(bool value);
  private:
  bool _internal_available_while_in_call() const;
  void _internal_set_available_while_in_call(bool value);
  public:

  // required .HU.STREAM_TYPE type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::HU::STREAM_TYPE type() const;
  void set_type(::HU::STREAM_TYPE value);
  private:
  ::HU::STREAM_TYPE _internal_type() const;
  void _internal_set_type(::HU::STREAM_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.InputStreamChannel)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::HU::AudioCofig* audio_config_;
  bool available_while_in_call_;
  int type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_BluetoothService PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.BluetoothService) */ {
 public:
  inline ChannelDescriptor_BluetoothService() : ChannelDescriptor_BluetoothService(nullptr) {};
  virtual ~ChannelDescriptor_BluetoothService();

  ChannelDescriptor_BluetoothService(const ChannelDescriptor_BluetoothService& from);
  ChannelDescriptor_BluetoothService(ChannelDescriptor_BluetoothService&& from) noexcept
    : ChannelDescriptor_BluetoothService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_BluetoothService& operator=(const ChannelDescriptor_BluetoothService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_BluetoothService& operator=(ChannelDescriptor_BluetoothService&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_BluetoothService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_BluetoothService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_BluetoothService*>(
               &_ChannelDescriptor_BluetoothService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(ChannelDescriptor_BluetoothService& a, ChannelDescriptor_BluetoothService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_BluetoothService* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_BluetoothService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_BluetoothService* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_BluetoothService>(nullptr);
  }

  ChannelDescriptor_BluetoothService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_BluetoothService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_BluetoothService& from);
  void MergeFrom(const ChannelDescriptor_BluetoothService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_BluetoothService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.BluetoothService";
  }
  protected:
  explicit ChannelDescriptor_BluetoothService(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedPairingMethodsFieldNumber = 2,
    kCarAddressFieldNumber = 1,
  };
  // repeated .HU.BluetoothPairingMethod supported_pairing_methods = 2;
  int supported_pairing_methods_size() const;
  private:
  int _internal_supported_pairing_methods_size() const;
  public:
  void clear_supported_pairing_methods();
  private:
  ::HU::BluetoothPairingMethod _internal_supported_pairing_methods(int index) const;
  void _internal_add_supported_pairing_methods(::HU::BluetoothPairingMethod value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_pairing_methods();
  public:
  ::HU::BluetoothPairingMethod supported_pairing_methods(int index) const;
  void set_supported_pairing_methods(int index, ::HU::BluetoothPairingMethod value);
  void add_supported_pairing_methods(::HU::BluetoothPairingMethod value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_pairing_methods() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_pairing_methods();

  // required string car_address = 1;
  bool has_car_address() const;
  private:
  bool _internal_has_car_address() const;
  public:
  void clear_car_address();
  const std::string& car_address() const;
  void set_car_address(const std::string& value);
  void set_car_address(std::string&& value);
  void set_car_address(const char* value);
  void set_car_address(const char* value, size_t size);
  std::string* mutable_car_address();
  std::string* release_car_address();
  void set_allocated_car_address(std::string* car_address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_car_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_car_address(
      std::string* car_address);
  private:
  const std::string& _internal_car_address() const;
  void _internal_set_car_address(const std::string& value);
  std::string* _internal_mutable_car_address();
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.BluetoothService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_pairing_methods_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr car_address_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_NavigationStatusService_ImageOptions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.NavigationStatusService.ImageOptions) */ {
 public:
  inline ChannelDescriptor_NavigationStatusService_ImageOptions() : ChannelDescriptor_NavigationStatusService_ImageOptions(nullptr) {};
  virtual ~ChannelDescriptor_NavigationStatusService_ImageOptions();

  ChannelDescriptor_NavigationStatusService_ImageOptions(const ChannelDescriptor_NavigationStatusService_ImageOptions& from);
  ChannelDescriptor_NavigationStatusService_ImageOptions(ChannelDescriptor_NavigationStatusService_ImageOptions&& from) noexcept
    : ChannelDescriptor_NavigationStatusService_ImageOptions() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_NavigationStatusService_ImageOptions& operator=(const ChannelDescriptor_NavigationStatusService_ImageOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_NavigationStatusService_ImageOptions& operator=(ChannelDescriptor_NavigationStatusService_ImageOptions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_NavigationStatusService_ImageOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_NavigationStatusService_ImageOptions* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_NavigationStatusService_ImageOptions*>(
               &_ChannelDescriptor_NavigationStatusService_ImageOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ChannelDescriptor_NavigationStatusService_ImageOptions& a, ChannelDescriptor_NavigationStatusService_ImageOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_NavigationStatusService_ImageOptions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_NavigationStatusService_ImageOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_NavigationStatusService_ImageOptions* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_NavigationStatusService_ImageOptions>(nullptr);
  }

  ChannelDescriptor_NavigationStatusService_ImageOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_NavigationStatusService_ImageOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_NavigationStatusService_ImageOptions& from);
  void MergeFrom(const ChannelDescriptor_NavigationStatusService_ImageOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_NavigationStatusService_ImageOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.NavigationStatusService.ImageOptions";
  }
  protected:
  explicit ChannelDescriptor_NavigationStatusService_ImageOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kColourDepthBitsFieldNumber = 3,
  };
  // required int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::int32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::int32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 colour_depth_bits = 3;
  bool has_colour_depth_bits() const;
  private:
  bool _internal_has_colour_depth_bits() const;
  public:
  void clear_colour_depth_bits();
  ::PROTOBUF_NAMESPACE_ID::int32 colour_depth_bits() const;
  void set_colour_depth_bits(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_colour_depth_bits() const;
  void _internal_set_colour_depth_bits(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.NavigationStatusService.ImageOptions)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 width_;
  ::PROTOBUF_NAMESPACE_ID::int32 height_;
  ::PROTOBUF_NAMESPACE_ID::int32 colour_depth_bits_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_NavigationStatusService PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.NavigationStatusService) */ {
 public:
  inline ChannelDescriptor_NavigationStatusService() : ChannelDescriptor_NavigationStatusService(nullptr) {};
  virtual ~ChannelDescriptor_NavigationStatusService();

  ChannelDescriptor_NavigationStatusService(const ChannelDescriptor_NavigationStatusService& from);
  ChannelDescriptor_NavigationStatusService(ChannelDescriptor_NavigationStatusService&& from) noexcept
    : ChannelDescriptor_NavigationStatusService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_NavigationStatusService& operator=(const ChannelDescriptor_NavigationStatusService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_NavigationStatusService& operator=(ChannelDescriptor_NavigationStatusService&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_NavigationStatusService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_NavigationStatusService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_NavigationStatusService*>(
               &_ChannelDescriptor_NavigationStatusService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ChannelDescriptor_NavigationStatusService& a, ChannelDescriptor_NavigationStatusService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_NavigationStatusService* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_NavigationStatusService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_NavigationStatusService* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_NavigationStatusService>(nullptr);
  }

  ChannelDescriptor_NavigationStatusService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_NavigationStatusService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_NavigationStatusService& from);
  void MergeFrom(const ChannelDescriptor_NavigationStatusService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_NavigationStatusService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.NavigationStatusService";
  }
  protected:
  explicit ChannelDescriptor_NavigationStatusService(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChannelDescriptor_NavigationStatusService_ImageOptions ImageOptions;

  typedef ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE CLUSTER_TYPE;
  static constexpr CLUSTER_TYPE CUSTOM_IMAGES_SUPPORTED =
    ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CUSTOM_IMAGES_SUPPORTED;
  static constexpr CLUSTER_TYPE IMAGE_CODES_ONLY =
    ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IMAGE_CODES_ONLY;
  static inline bool CLUSTER_TYPE_IsValid(int value) {
    return ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IsValid(value);
  }
  static constexpr CLUSTER_TYPE CLUSTER_TYPE_MIN =
    ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_MIN;
  static constexpr CLUSTER_TYPE CLUSTER_TYPE_MAX =
    ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_MAX;
  static constexpr int CLUSTER_TYPE_ARRAYSIZE =
    ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_CLUSTER_TYPE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CLUSTER_TYPE_descriptor() {
    return ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor();
  }
  template<typename T>
  static inline const std::string& CLUSTER_TYPE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CLUSTER_TYPE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CLUSTER_TYPE_Name.");
    return ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Name(enum_t_value);
  }
  static inline bool CLUSTER_TYPE_Parse(const std::string& name,
      CLUSTER_TYPE* value) {
    return ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kImageOptionsFieldNumber = 3,
    kMinimumIntervalMsFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional .HU.ChannelDescriptor.NavigationStatusService.ImageOptions image_options = 3;
  bool has_image_options() const;
  private:
  bool _internal_has_image_options() const;
  public:
  void clear_image_options();
  const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions& image_options() const;
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* release_image_options();
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* mutable_image_options();
  void set_allocated_image_options(::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* image_options);
  private:
  const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions& _internal_image_options() const;
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* _internal_mutable_image_options();
  public:
  void unsafe_arena_set_allocated_image_options(
      ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* image_options);
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* unsafe_arena_release_image_options();

  // required uint32 minimum_interval_ms = 1;
  bool has_minimum_interval_ms() const;
  private:
  bool _internal_has_minimum_interval_ms() const;
  public:
  void clear_minimum_interval_ms();
  ::PROTOBUF_NAMESPACE_ID::uint32 minimum_interval_ms() const;
  void set_minimum_interval_ms(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_minimum_interval_ms() const;
  void _internal_set_minimum_interval_ms(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .HU.ChannelDescriptor.NavigationStatusService.CLUSTER_TYPE type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE type() const;
  void set_type(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE value);
  private:
  ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE _internal_type() const;
  void _internal_set_type(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.NavigationStatusService)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* image_options_;
  ::PROTOBUF_NAMESPACE_ID::uint32 minimum_interval_ms_;
  int type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_PhoneStatusService PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.PhoneStatusService) */ {
 public:
  inline ChannelDescriptor_PhoneStatusService() : ChannelDescriptor_PhoneStatusService(nullptr) {};
  virtual ~ChannelDescriptor_PhoneStatusService();

  ChannelDescriptor_PhoneStatusService(const ChannelDescriptor_PhoneStatusService& from);
  ChannelDescriptor_PhoneStatusService(ChannelDescriptor_PhoneStatusService&& from) noexcept
    : ChannelDescriptor_PhoneStatusService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_PhoneStatusService& operator=(const ChannelDescriptor_PhoneStatusService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_PhoneStatusService& operator=(ChannelDescriptor_PhoneStatusService&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_PhoneStatusService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_PhoneStatusService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_PhoneStatusService*>(
               &_ChannelDescriptor_PhoneStatusService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ChannelDescriptor_PhoneStatusService& a, ChannelDescriptor_PhoneStatusService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_PhoneStatusService* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_PhoneStatusService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_PhoneStatusService* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_PhoneStatusService>(nullptr);
  }

  ChannelDescriptor_PhoneStatusService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_PhoneStatusService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_PhoneStatusService& from);
  void MergeFrom(const ChannelDescriptor_PhoneStatusService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_PhoneStatusService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.PhoneStatusService";
  }
  protected:
  explicit ChannelDescriptor_PhoneStatusService(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.PhoneStatusService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_VendorExtensionService PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.VendorExtensionService) */ {
 public:
  inline ChannelDescriptor_VendorExtensionService() : ChannelDescriptor_VendorExtensionService(nullptr) {};
  virtual ~ChannelDescriptor_VendorExtensionService();

  ChannelDescriptor_VendorExtensionService(const ChannelDescriptor_VendorExtensionService& from);
  ChannelDescriptor_VendorExtensionService(ChannelDescriptor_VendorExtensionService&& from) noexcept
    : ChannelDescriptor_VendorExtensionService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_VendorExtensionService& operator=(const ChannelDescriptor_VendorExtensionService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_VendorExtensionService& operator=(ChannelDescriptor_VendorExtensionService&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_VendorExtensionService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_VendorExtensionService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_VendorExtensionService*>(
               &_ChannelDescriptor_VendorExtensionService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ChannelDescriptor_VendorExtensionService& a, ChannelDescriptor_VendorExtensionService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_VendorExtensionService* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_VendorExtensionService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_VendorExtensionService* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_VendorExtensionService>(nullptr);
  }

  ChannelDescriptor_VendorExtensionService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_VendorExtensionService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_VendorExtensionService& from);
  void MergeFrom(const ChannelDescriptor_VendorExtensionService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_VendorExtensionService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.VendorExtensionService";
  }
  protected:
  explicit ChannelDescriptor_VendorExtensionService(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPackageWhiteListFieldNumber = 2,
    kNameFieldNumber = 1,
    kDataFieldNumber = 3,
  };
  // repeated string package_white_list = 2;
  int package_white_list_size() const;
  private:
  int _internal_package_white_list_size() const;
  public:
  void clear_package_white_list();
  const std::string& package_white_list(int index) const;
  std::string* mutable_package_white_list(int index);
  void set_package_white_list(int index, const std::string& value);
  void set_package_white_list(int index, std::string&& value);
  void set_package_white_list(int index, const char* value);
  void set_package_white_list(int index, const char* value, size_t size);
  std::string* add_package_white_list();
  void add_package_white_list(const std::string& value);
  void add_package_white_list(std::string&& value);
  void add_package_white_list(const char* value);
  void add_package_white_list(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& package_white_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_package_white_list();
  private:
  const std::string& _internal_package_white_list(int index) const;
  std::string* _internal_add_package_white_list();
  public:

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.VendorExtensionService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> package_white_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor_GenericNotificationService PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor.GenericNotificationService) */ {
 public:
  inline ChannelDescriptor_GenericNotificationService() : ChannelDescriptor_GenericNotificationService(nullptr) {};
  virtual ~ChannelDescriptor_GenericNotificationService();

  ChannelDescriptor_GenericNotificationService(const ChannelDescriptor_GenericNotificationService& from);
  ChannelDescriptor_GenericNotificationService(ChannelDescriptor_GenericNotificationService&& from) noexcept
    : ChannelDescriptor_GenericNotificationService() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor_GenericNotificationService& operator=(const ChannelDescriptor_GenericNotificationService& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor_GenericNotificationService& operator=(ChannelDescriptor_GenericNotificationService&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor_GenericNotificationService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor_GenericNotificationService* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor_GenericNotificationService*>(
               &_ChannelDescriptor_GenericNotificationService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ChannelDescriptor_GenericNotificationService& a, ChannelDescriptor_GenericNotificationService& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor_GenericNotificationService* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor_GenericNotificationService* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor_GenericNotificationService* New() const final {
    return CreateMaybeMessage<ChannelDescriptor_GenericNotificationService>(nullptr);
  }

  ChannelDescriptor_GenericNotificationService* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor_GenericNotificationService>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor_GenericNotificationService& from);
  void MergeFrom(const ChannelDescriptor_GenericNotificationService& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor_GenericNotificationService* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor.GenericNotificationService";
  }
  protected:
  explicit ChannelDescriptor_GenericNotificationService(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor.GenericNotificationService)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelDescriptor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelDescriptor) */ {
 public:
  inline ChannelDescriptor() : ChannelDescriptor(nullptr) {};
  virtual ~ChannelDescriptor();

  ChannelDescriptor(const ChannelDescriptor& from);
  ChannelDescriptor(ChannelDescriptor&& from) noexcept
    : ChannelDescriptor() {
    *this = ::std::move(from);
  }

  inline ChannelDescriptor& operator=(const ChannelDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelDescriptor& operator=(ChannelDescriptor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelDescriptor* internal_default_instance() {
    return reinterpret_cast<const ChannelDescriptor*>(
               &_ChannelDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ChannelDescriptor& a, ChannelDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelDescriptor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelDescriptor* New() const final {
    return CreateMaybeMessage<ChannelDescriptor>(nullptr);
  }

  ChannelDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelDescriptor& from);
  void MergeFrom(const ChannelDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelDescriptor";
  }
  protected:
  explicit ChannelDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ChannelDescriptor_SensorChannel SensorChannel;
  typedef ChannelDescriptor_OutputStreamChannel OutputStreamChannel;
  typedef ChannelDescriptor_InputEventChannel InputEventChannel;
  typedef ChannelDescriptor_InputStreamChannel InputStreamChannel;
  typedef ChannelDescriptor_BluetoothService BluetoothService;
  typedef ChannelDescriptor_NavigationStatusService NavigationStatusService;
  typedef ChannelDescriptor_PhoneStatusService PhoneStatusService;
  typedef ChannelDescriptor_VendorExtensionService VendorExtensionService;
  typedef ChannelDescriptor_GenericNotificationService GenericNotificationService;

  // accessors -------------------------------------------------------

  enum : int {
    kSensorChannelFieldNumber = 2,
    kOutputStreamChannelFieldNumber = 3,
    kInputEventChannelFieldNumber = 4,
    kInputStreamChannelFieldNumber = 5,
    kBluetoothServiceFieldNumber = 6,
    kNavigationStatusServiceFieldNumber = 8,
    kPhoneStatusServiceFieldNumber = 10,
    kVendorExtensionServiceFieldNumber = 12,
    kGenericNotificationServiceFieldNumber = 13,
    kChannelIdFieldNumber = 1,
  };
  // optional .HU.ChannelDescriptor.SensorChannel sensor_channel = 2;
  bool has_sensor_channel() const;
  private:
  bool _internal_has_sensor_channel() const;
  public:
  void clear_sensor_channel();
  const ::HU::ChannelDescriptor_SensorChannel& sensor_channel() const;
  ::HU::ChannelDescriptor_SensorChannel* release_sensor_channel();
  ::HU::ChannelDescriptor_SensorChannel* mutable_sensor_channel();
  void set_allocated_sensor_channel(::HU::ChannelDescriptor_SensorChannel* sensor_channel);
  private:
  const ::HU::ChannelDescriptor_SensorChannel& _internal_sensor_channel() const;
  ::HU::ChannelDescriptor_SensorChannel* _internal_mutable_sensor_channel();
  public:
  void unsafe_arena_set_allocated_sensor_channel(
      ::HU::ChannelDescriptor_SensorChannel* sensor_channel);
  ::HU::ChannelDescriptor_SensorChannel* unsafe_arena_release_sensor_channel();

  // optional .HU.ChannelDescriptor.OutputStreamChannel output_stream_channel = 3;
  bool has_output_stream_channel() const;
  private:
  bool _internal_has_output_stream_channel() const;
  public:
  void clear_output_stream_channel();
  const ::HU::ChannelDescriptor_OutputStreamChannel& output_stream_channel() const;
  ::HU::ChannelDescriptor_OutputStreamChannel* release_output_stream_channel();
  ::HU::ChannelDescriptor_OutputStreamChannel* mutable_output_stream_channel();
  void set_allocated_output_stream_channel(::HU::ChannelDescriptor_OutputStreamChannel* output_stream_channel);
  private:
  const ::HU::ChannelDescriptor_OutputStreamChannel& _internal_output_stream_channel() const;
  ::HU::ChannelDescriptor_OutputStreamChannel* _internal_mutable_output_stream_channel();
  public:
  void unsafe_arena_set_allocated_output_stream_channel(
      ::HU::ChannelDescriptor_OutputStreamChannel* output_stream_channel);
  ::HU::ChannelDescriptor_OutputStreamChannel* unsafe_arena_release_output_stream_channel();

  // optional .HU.ChannelDescriptor.InputEventChannel input_event_channel = 4;
  bool has_input_event_channel() const;
  private:
  bool _internal_has_input_event_channel() const;
  public:
  void clear_input_event_channel();
  const ::HU::ChannelDescriptor_InputEventChannel& input_event_channel() const;
  ::HU::ChannelDescriptor_InputEventChannel* release_input_event_channel();
  ::HU::ChannelDescriptor_InputEventChannel* mutable_input_event_channel();
  void set_allocated_input_event_channel(::HU::ChannelDescriptor_InputEventChannel* input_event_channel);
  private:
  const ::HU::ChannelDescriptor_InputEventChannel& _internal_input_event_channel() const;
  ::HU::ChannelDescriptor_InputEventChannel* _internal_mutable_input_event_channel();
  public:
  void unsafe_arena_set_allocated_input_event_channel(
      ::HU::ChannelDescriptor_InputEventChannel* input_event_channel);
  ::HU::ChannelDescriptor_InputEventChannel* unsafe_arena_release_input_event_channel();

  // optional .HU.ChannelDescriptor.InputStreamChannel input_stream_channel = 5;
  bool has_input_stream_channel() const;
  private:
  bool _internal_has_input_stream_channel() const;
  public:
  void clear_input_stream_channel();
  const ::HU::ChannelDescriptor_InputStreamChannel& input_stream_channel() const;
  ::HU::ChannelDescriptor_InputStreamChannel* release_input_stream_channel();
  ::HU::ChannelDescriptor_InputStreamChannel* mutable_input_stream_channel();
  void set_allocated_input_stream_channel(::HU::ChannelDescriptor_InputStreamChannel* input_stream_channel);
  private:
  const ::HU::ChannelDescriptor_InputStreamChannel& _internal_input_stream_channel() const;
  ::HU::ChannelDescriptor_InputStreamChannel* _internal_mutable_input_stream_channel();
  public:
  void unsafe_arena_set_allocated_input_stream_channel(
      ::HU::ChannelDescriptor_InputStreamChannel* input_stream_channel);
  ::HU::ChannelDescriptor_InputStreamChannel* unsafe_arena_release_input_stream_channel();

  // optional .HU.ChannelDescriptor.BluetoothService bluetooth_service = 6;
  bool has_bluetooth_service() const;
  private:
  bool _internal_has_bluetooth_service() const;
  public:
  void clear_bluetooth_service();
  const ::HU::ChannelDescriptor_BluetoothService& bluetooth_service() const;
  ::HU::ChannelDescriptor_BluetoothService* release_bluetooth_service();
  ::HU::ChannelDescriptor_BluetoothService* mutable_bluetooth_service();
  void set_allocated_bluetooth_service(::HU::ChannelDescriptor_BluetoothService* bluetooth_service);
  private:
  const ::HU::ChannelDescriptor_BluetoothService& _internal_bluetooth_service() const;
  ::HU::ChannelDescriptor_BluetoothService* _internal_mutable_bluetooth_service();
  public:
  void unsafe_arena_set_allocated_bluetooth_service(
      ::HU::ChannelDescriptor_BluetoothService* bluetooth_service);
  ::HU::ChannelDescriptor_BluetoothService* unsafe_arena_release_bluetooth_service();

  // optional .HU.ChannelDescriptor.NavigationStatusService navigation_status_service = 8;
  bool has_navigation_status_service() const;
  private:
  bool _internal_has_navigation_status_service() const;
  public:
  void clear_navigation_status_service();
  const ::HU::ChannelDescriptor_NavigationStatusService& navigation_status_service() const;
  ::HU::ChannelDescriptor_NavigationStatusService* release_navigation_status_service();
  ::HU::ChannelDescriptor_NavigationStatusService* mutable_navigation_status_service();
  void set_allocated_navigation_status_service(::HU::ChannelDescriptor_NavigationStatusService* navigation_status_service);
  private:
  const ::HU::ChannelDescriptor_NavigationStatusService& _internal_navigation_status_service() const;
  ::HU::ChannelDescriptor_NavigationStatusService* _internal_mutable_navigation_status_service();
  public:
  void unsafe_arena_set_allocated_navigation_status_service(
      ::HU::ChannelDescriptor_NavigationStatusService* navigation_status_service);
  ::HU::ChannelDescriptor_NavigationStatusService* unsafe_arena_release_navigation_status_service();

  // optional .HU.ChannelDescriptor.PhoneStatusService phone_status_service = 10;
  bool has_phone_status_service() const;
  private:
  bool _internal_has_phone_status_service() const;
  public:
  void clear_phone_status_service();
  const ::HU::ChannelDescriptor_PhoneStatusService& phone_status_service() const;
  ::HU::ChannelDescriptor_PhoneStatusService* release_phone_status_service();
  ::HU::ChannelDescriptor_PhoneStatusService* mutable_phone_status_service();
  void set_allocated_phone_status_service(::HU::ChannelDescriptor_PhoneStatusService* phone_status_service);
  private:
  const ::HU::ChannelDescriptor_PhoneStatusService& _internal_phone_status_service() const;
  ::HU::ChannelDescriptor_PhoneStatusService* _internal_mutable_phone_status_service();
  public:
  void unsafe_arena_set_allocated_phone_status_service(
      ::HU::ChannelDescriptor_PhoneStatusService* phone_status_service);
  ::HU::ChannelDescriptor_PhoneStatusService* unsafe_arena_release_phone_status_service();

  // optional .HU.ChannelDescriptor.VendorExtensionService vendor_extension_service = 12;
  bool has_vendor_extension_service() const;
  private:
  bool _internal_has_vendor_extension_service() const;
  public:
  void clear_vendor_extension_service();
  const ::HU::ChannelDescriptor_VendorExtensionService& vendor_extension_service() const;
  ::HU::ChannelDescriptor_VendorExtensionService* release_vendor_extension_service();
  ::HU::ChannelDescriptor_VendorExtensionService* mutable_vendor_extension_service();
  void set_allocated_vendor_extension_service(::HU::ChannelDescriptor_VendorExtensionService* vendor_extension_service);
  private:
  const ::HU::ChannelDescriptor_VendorExtensionService& _internal_vendor_extension_service() const;
  ::HU::ChannelDescriptor_VendorExtensionService* _internal_mutable_vendor_extension_service();
  public:
  void unsafe_arena_set_allocated_vendor_extension_service(
      ::HU::ChannelDescriptor_VendorExtensionService* vendor_extension_service);
  ::HU::ChannelDescriptor_VendorExtensionService* unsafe_arena_release_vendor_extension_service();

  // optional .HU.ChannelDescriptor.GenericNotificationService generic_notification_service = 13;
  bool has_generic_notification_service() const;
  private:
  bool _internal_has_generic_notification_service() const;
  public:
  void clear_generic_notification_service();
  const ::HU::ChannelDescriptor_GenericNotificationService& generic_notification_service() const;
  ::HU::ChannelDescriptor_GenericNotificationService* release_generic_notification_service();
  ::HU::ChannelDescriptor_GenericNotificationService* mutable_generic_notification_service();
  void set_allocated_generic_notification_service(::HU::ChannelDescriptor_GenericNotificationService* generic_notification_service);
  private:
  const ::HU::ChannelDescriptor_GenericNotificationService& _internal_generic_notification_service() const;
  ::HU::ChannelDescriptor_GenericNotificationService* _internal_mutable_generic_notification_service();
  public:
  void unsafe_arena_set_allocated_generic_notification_service(
      ::HU::ChannelDescriptor_GenericNotificationService* generic_notification_service);
  ::HU::ChannelDescriptor_GenericNotificationService* unsafe_arena_release_generic_notification_service();

  // required uint32 channel_id = 1;
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id() const;
  void set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel_id() const;
  void _internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::HU::ChannelDescriptor_SensorChannel* sensor_channel_;
  ::HU::ChannelDescriptor_OutputStreamChannel* output_stream_channel_;
  ::HU::ChannelDescriptor_InputEventChannel* input_event_channel_;
  ::HU::ChannelDescriptor_InputStreamChannel* input_stream_channel_;
  ::HU::ChannelDescriptor_BluetoothService* bluetooth_service_;
  ::HU::ChannelDescriptor_NavigationStatusService* navigation_status_service_;
  ::HU::ChannelDescriptor_PhoneStatusService* phone_status_service_;
  ::HU::ChannelDescriptor_VendorExtensionService* vendor_extension_service_;
  ::HU::ChannelDescriptor_GenericNotificationService* generic_notification_service_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_id_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ServiceDiscoveryRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ServiceDiscoveryRequest) */ {
 public:
  inline ServiceDiscoveryRequest() : ServiceDiscoveryRequest(nullptr) {};
  virtual ~ServiceDiscoveryRequest();

  ServiceDiscoveryRequest(const ServiceDiscoveryRequest& from);
  ServiceDiscoveryRequest(ServiceDiscoveryRequest&& from) noexcept
    : ServiceDiscoveryRequest() {
    *this = ::std::move(from);
  }

  inline ServiceDiscoveryRequest& operator=(const ServiceDiscoveryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceDiscoveryRequest& operator=(ServiceDiscoveryRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServiceDiscoveryRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceDiscoveryRequest* internal_default_instance() {
    return reinterpret_cast<const ServiceDiscoveryRequest*>(
               &_ServiceDiscoveryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ServiceDiscoveryRequest& a, ServiceDiscoveryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceDiscoveryRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceDiscoveryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServiceDiscoveryRequest* New() const final {
    return CreateMaybeMessage<ServiceDiscoveryRequest>(nullptr);
  }

  ServiceDiscoveryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServiceDiscoveryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServiceDiscoveryRequest& from);
  void MergeFrom(const ServiceDiscoveryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceDiscoveryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ServiceDiscoveryRequest";
  }
  protected:
  explicit ServiceDiscoveryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneNameFieldNumber = 4,
  };
  // optional string phone_name = 4;
  bool has_phone_name() const;
  private:
  bool _internal_has_phone_name() const;
  public:
  void clear_phone_name();
  const std::string& phone_name() const;
  void set_phone_name(const std::string& value);
  void set_phone_name(std::string&& value);
  void set_phone_name(const char* value);
  void set_phone_name(const char* value, size_t size);
  std::string* mutable_phone_name();
  std::string* release_phone_name();
  void set_allocated_phone_name(std::string* phone_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_phone_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_phone_name(
      std::string* phone_name);
  private:
  const std::string& _internal_phone_name() const;
  void _internal_set_phone_name(const std::string& value);
  std::string* _internal_mutable_phone_name();
  public:

  // @@protoc_insertion_point(class_scope:HU.ServiceDiscoveryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_name_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ServiceDiscoveryResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ServiceDiscoveryResponse) */ {
 public:
  inline ServiceDiscoveryResponse() : ServiceDiscoveryResponse(nullptr) {};
  virtual ~ServiceDiscoveryResponse();

  ServiceDiscoveryResponse(const ServiceDiscoveryResponse& from);
  ServiceDiscoveryResponse(ServiceDiscoveryResponse&& from) noexcept
    : ServiceDiscoveryResponse() {
    *this = ::std::move(from);
  }

  inline ServiceDiscoveryResponse& operator=(const ServiceDiscoveryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceDiscoveryResponse& operator=(ServiceDiscoveryResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServiceDiscoveryResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServiceDiscoveryResponse* internal_default_instance() {
    return reinterpret_cast<const ServiceDiscoveryResponse*>(
               &_ServiceDiscoveryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ServiceDiscoveryResponse& a, ServiceDiscoveryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceDiscoveryResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceDiscoveryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServiceDiscoveryResponse* New() const final {
    return CreateMaybeMessage<ServiceDiscoveryResponse>(nullptr);
  }

  ServiceDiscoveryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServiceDiscoveryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServiceDiscoveryResponse& from);
  void MergeFrom(const ServiceDiscoveryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceDiscoveryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ServiceDiscoveryResponse";
  }
  protected:
  explicit ServiceDiscoveryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 1,
    kHeadUnitNameFieldNumber = 2,
    kCarModelFieldNumber = 3,
    kCarYearFieldNumber = 4,
    kCarSerialFieldNumber = 5,
    kHeadunitMakeFieldNumber = 7,
    kHeadunitModelFieldNumber = 8,
    kSwBuildFieldNumber = 9,
    kSwVersionFieldNumber = 10,
    kDriverPosFieldNumber = 6,
    kCanPlayNativeMediaDuringVrFieldNumber = 11,
    kHideClockFieldNumber = 12,
  };
  // repeated .HU.ChannelDescriptor channels = 1;
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  ::HU::ChannelDescriptor* mutable_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor >*
      mutable_channels();
  private:
  const ::HU::ChannelDescriptor& _internal_channels(int index) const;
  ::HU::ChannelDescriptor* _internal_add_channels();
  public:
  const ::HU::ChannelDescriptor& channels(int index) const;
  ::HU::ChannelDescriptor* add_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor >&
      channels() const;

  // required string head_unit_name = 2;
  bool has_head_unit_name() const;
  private:
  bool _internal_has_head_unit_name() const;
  public:
  void clear_head_unit_name();
  const std::string& head_unit_name() const;
  void set_head_unit_name(const std::string& value);
  void set_head_unit_name(std::string&& value);
  void set_head_unit_name(const char* value);
  void set_head_unit_name(const char* value, size_t size);
  std::string* mutable_head_unit_name();
  std::string* release_head_unit_name();
  void set_allocated_head_unit_name(std::string* head_unit_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_head_unit_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_head_unit_name(
      std::string* head_unit_name);
  private:
  const std::string& _internal_head_unit_name() const;
  void _internal_set_head_unit_name(const std::string& value);
  std::string* _internal_mutable_head_unit_name();
  public:

  // required string car_model = 3;
  bool has_car_model() const;
  private:
  bool _internal_has_car_model() const;
  public:
  void clear_car_model();
  const std::string& car_model() const;
  void set_car_model(const std::string& value);
  void set_car_model(std::string&& value);
  void set_car_model(const char* value);
  void set_car_model(const char* value, size_t size);
  std::string* mutable_car_model();
  std::string* release_car_model();
  void set_allocated_car_model(std::string* car_model);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_car_model();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_car_model(
      std::string* car_model);
  private:
  const std::string& _internal_car_model() const;
  void _internal_set_car_model(const std::string& value);
  std::string* _internal_mutable_car_model();
  public:

  // required string car_year = 4;
  bool has_car_year() const;
  private:
  bool _internal_has_car_year() const;
  public:
  void clear_car_year();
  const std::string& car_year() const;
  void set_car_year(const std::string& value);
  void set_car_year(std::string&& value);
  void set_car_year(const char* value);
  void set_car_year(const char* value, size_t size);
  std::string* mutable_car_year();
  std::string* release_car_year();
  void set_allocated_car_year(std::string* car_year);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_car_year();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_car_year(
      std::string* car_year);
  private:
  const std::string& _internal_car_year() const;
  void _internal_set_car_year(const std::string& value);
  std::string* _internal_mutable_car_year();
  public:

  // required string car_serial = 5;
  bool has_car_serial() const;
  private:
  bool _internal_has_car_serial() const;
  public:
  void clear_car_serial();
  const std::string& car_serial() const;
  void set_car_serial(const std::string& value);
  void set_car_serial(std::string&& value);
  void set_car_serial(const char* value);
  void set_car_serial(const char* value, size_t size);
  std::string* mutable_car_serial();
  std::string* release_car_serial();
  void set_allocated_car_serial(std::string* car_serial);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_car_serial();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_car_serial(
      std::string* car_serial);
  private:
  const std::string& _internal_car_serial() const;
  void _internal_set_car_serial(const std::string& value);
  std::string* _internal_mutable_car_serial();
  public:

  // required string headunit_make = 7;
  bool has_headunit_make() const;
  private:
  bool _internal_has_headunit_make() const;
  public:
  void clear_headunit_make();
  const std::string& headunit_make() const;
  void set_headunit_make(const std::string& value);
  void set_headunit_make(std::string&& value);
  void set_headunit_make(const char* value);
  void set_headunit_make(const char* value, size_t size);
  std::string* mutable_headunit_make();
  std::string* release_headunit_make();
  void set_allocated_headunit_make(std::string* headunit_make);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_headunit_make();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_headunit_make(
      std::string* headunit_make);
  private:
  const std::string& _internal_headunit_make() const;
  void _internal_set_headunit_make(const std::string& value);
  std::string* _internal_mutable_headunit_make();
  public:

  // required string headunit_model = 8;
  bool has_headunit_model() const;
  private:
  bool _internal_has_headunit_model() const;
  public:
  void clear_headunit_model();
  const std::string& headunit_model() const;
  void set_headunit_model(const std::string& value);
  void set_headunit_model(std::string&& value);
  void set_headunit_model(const char* value);
  void set_headunit_model(const char* value, size_t size);
  std::string* mutable_headunit_model();
  std::string* release_headunit_model();
  void set_allocated_headunit_model(std::string* headunit_model);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_headunit_model();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_headunit_model(
      std::string* headunit_model);
  private:
  const std::string& _internal_headunit_model() const;
  void _internal_set_headunit_model(const std::string& value);
  std::string* _internal_mutable_headunit_model();
  public:

  // required string sw_build = 9;
  bool has_sw_build() const;
  private:
  bool _internal_has_sw_build() const;
  public:
  void clear_sw_build();
  const std::string& sw_build() const;
  void set_sw_build(const std::string& value);
  void set_sw_build(std::string&& value);
  void set_sw_build(const char* value);
  void set_sw_build(const char* value, size_t size);
  std::string* mutable_sw_build();
  std::string* release_sw_build();
  void set_allocated_sw_build(std::string* sw_build);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sw_build();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sw_build(
      std::string* sw_build);
  private:
  const std::string& _internal_sw_build() const;
  void _internal_set_sw_build(const std::string& value);
  std::string* _internal_mutable_sw_build();
  public:

  // required string sw_version = 10;
  bool has_sw_version() const;
  private:
  bool _internal_has_sw_version() const;
  public:
  void clear_sw_version();
  const std::string& sw_version() const;
  void set_sw_version(const std::string& value);
  void set_sw_version(std::string&& value);
  void set_sw_version(const char* value);
  void set_sw_version(const char* value, size_t size);
  std::string* mutable_sw_version();
  std::string* release_sw_version();
  void set_allocated_sw_version(std::string* sw_version);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_sw_version();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_sw_version(
      std::string* sw_version);
  private:
  const std::string& _internal_sw_version() const;
  void _internal_set_sw_version(const std::string& value);
  std::string* _internal_mutable_sw_version();
  public:

  // required bool driver_pos = 6;
  bool has_driver_pos() const;
  private:
  bool _internal_has_driver_pos() const;
  public:
  void clear_driver_pos();
  bool driver_pos() const;
  void set_driver_pos(bool value);
  private:
  bool _internal_driver_pos() const;
  void _internal_set_driver_pos(bool value);
  public:

  // required bool can_play_native_media_during_vr = 11;
  bool has_can_play_native_media_during_vr() const;
  private:
  bool _internal_has_can_play_native_media_during_vr() const;
  public:
  void clear_can_play_native_media_during_vr();
  bool can_play_native_media_during_vr() const;
  void set_can_play_native_media_during_vr(bool value);
  private:
  bool _internal_can_play_native_media_during_vr() const;
  void _internal_set_can_play_native_media_during_vr(bool value);
  public:

  // required bool hide_clock = 12;
  bool has_hide_clock() const;
  private:
  bool _internal_has_hide_clock() const;
  public:
  void clear_hide_clock();
  bool hide_clock() const;
  void set_hide_clock(bool value);
  private:
  bool _internal_hide_clock() const;
  void _internal_set_hide_clock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ServiceDiscoveryResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor > channels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr head_unit_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr car_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr car_year_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr car_serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headunit_make_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headunit_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sw_build_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sw_version_;
  bool driver_pos_;
  bool can_play_native_media_during_vr_;
  bool hide_clock_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelOpenRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelOpenRequest) */ {
 public:
  inline ChannelOpenRequest() : ChannelOpenRequest(nullptr) {};
  virtual ~ChannelOpenRequest();

  ChannelOpenRequest(const ChannelOpenRequest& from);
  ChannelOpenRequest(ChannelOpenRequest&& from) noexcept
    : ChannelOpenRequest() {
    *this = ::std::move(from);
  }

  inline ChannelOpenRequest& operator=(const ChannelOpenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelOpenRequest& operator=(ChannelOpenRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelOpenRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelOpenRequest* internal_default_instance() {
    return reinterpret_cast<const ChannelOpenRequest*>(
               &_ChannelOpenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ChannelOpenRequest& a, ChannelOpenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelOpenRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelOpenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelOpenRequest* New() const final {
    return CreateMaybeMessage<ChannelOpenRequest>(nullptr);
  }

  ChannelOpenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelOpenRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelOpenRequest& from);
  void MergeFrom(const ChannelOpenRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelOpenRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelOpenRequest";
  }
  protected:
  explicit ChannelOpenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPriorityFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional int32 priority = 1;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  ::PROTOBUF_NAMESPACE_ID::int32 priority() const;
  void set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_priority() const;
  void _internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelOpenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 priority_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ChannelOpenResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ChannelOpenResponse) */ {
 public:
  inline ChannelOpenResponse() : ChannelOpenResponse(nullptr) {};
  virtual ~ChannelOpenResponse();

  ChannelOpenResponse(const ChannelOpenResponse& from);
  ChannelOpenResponse(ChannelOpenResponse&& from) noexcept
    : ChannelOpenResponse() {
    *this = ::std::move(from);
  }

  inline ChannelOpenResponse& operator=(const ChannelOpenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelOpenResponse& operator=(ChannelOpenResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChannelOpenResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelOpenResponse* internal_default_instance() {
    return reinterpret_cast<const ChannelOpenResponse*>(
               &_ChannelOpenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ChannelOpenResponse& a, ChannelOpenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelOpenResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelOpenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChannelOpenResponse* New() const final {
    return CreateMaybeMessage<ChannelOpenResponse>(nullptr);
  }

  ChannelOpenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChannelOpenResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChannelOpenResponse& from);
  void MergeFrom(const ChannelOpenResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelOpenResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ChannelOpenResponse";
  }
  protected:
  explicit ChannelOpenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .HU.STATUS status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::HU::STATUS status() const;
  void set_status(::HU::STATUS value);
  private:
  ::HU::STATUS _internal_status() const;
  void _internal_set_status(::HU::STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ChannelOpenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class PingRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {};
  virtual ~PingRequest();

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingRequest* New() const final {
    return CreateMaybeMessage<PingRequest>(nullptr);
  }

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PingRequest& from);
  void MergeFrom(const PingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // required int64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class PingResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {};
  virtual ~PingResponse();

  PingResponse(const PingResponse& from);
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingResponse* New() const final {
    return CreateMaybeMessage<PingResponse>(nullptr);
  }

  PingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PingResponse& from);
  void MergeFrom(const PingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.PingResponse";
  }
  protected:
  explicit PingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // required int64 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.PingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ShutdownRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ShutdownRequest) */ {
 public:
  inline ShutdownRequest() : ShutdownRequest(nullptr) {};
  virtual ~ShutdownRequest();

  ShutdownRequest(const ShutdownRequest& from);
  ShutdownRequest(ShutdownRequest&& from) noexcept
    : ShutdownRequest() {
    *this = ::std::move(from);
  }

  inline ShutdownRequest& operator=(const ShutdownRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownRequest& operator=(ShutdownRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShutdownRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShutdownRequest* internal_default_instance() {
    return reinterpret_cast<const ShutdownRequest*>(
               &_ShutdownRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ShutdownRequest& a, ShutdownRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShutdownRequest* New() const final {
    return CreateMaybeMessage<ShutdownRequest>(nullptr);
  }

  ShutdownRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShutdownRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShutdownRequest& from);
  void MergeFrom(const ShutdownRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ShutdownRequest";
  }
  protected:
  explicit ShutdownRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ShutdownRequest_REASON REASON;
  static constexpr REASON REASON_QUIT =
    ShutdownRequest_REASON_REASON_QUIT;
  static inline bool REASON_IsValid(int value) {
    return ShutdownRequest_REASON_IsValid(value);
  }
  static constexpr REASON REASON_MIN =
    ShutdownRequest_REASON_REASON_MIN;
  static constexpr REASON REASON_MAX =
    ShutdownRequest_REASON_REASON_MAX;
  static constexpr int REASON_ARRAYSIZE =
    ShutdownRequest_REASON_REASON_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  REASON_descriptor() {
    return ShutdownRequest_REASON_descriptor();
  }
  template<typename T>
  static inline const std::string& REASON_Name(T enum_t_value) {
    static_assert(::std::is_same<T, REASON>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function REASON_Name.");
    return ShutdownRequest_REASON_Name(enum_t_value);
  }
  static inline bool REASON_Parse(const std::string& name,
      REASON* value) {
    return ShutdownRequest_REASON_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 1,
  };
  // optional .HU.ShutdownRequest.REASON reason = 1;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  ::HU::ShutdownRequest_REASON reason() const;
  void set_reason(::HU::ShutdownRequest_REASON value);
  private:
  ::HU::ShutdownRequest_REASON _internal_reason() const;
  void _internal_set_reason(::HU::ShutdownRequest_REASON value);
  public:

  // @@protoc_insertion_point(class_scope:HU.ShutdownRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int reason_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class ShutdownResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.ShutdownResponse) */ {
 public:
  inline ShutdownResponse() : ShutdownResponse(nullptr) {};
  virtual ~ShutdownResponse();

  ShutdownResponse(const ShutdownResponse& from);
  ShutdownResponse(ShutdownResponse&& from) noexcept
    : ShutdownResponse() {
    *this = ::std::move(from);
  }

  inline ShutdownResponse& operator=(const ShutdownResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShutdownResponse& operator=(ShutdownResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ShutdownResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShutdownResponse* internal_default_instance() {
    return reinterpret_cast<const ShutdownResponse*>(
               &_ShutdownResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(ShutdownResponse& a, ShutdownResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ShutdownResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShutdownResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ShutdownResponse* New() const final {
    return CreateMaybeMessage<ShutdownResponse>(nullptr);
  }

  ShutdownResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ShutdownResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ShutdownResponse& from);
  void MergeFrom(const ShutdownResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.ShutdownResponse";
  }
  protected:
  explicit ShutdownResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.ShutdownResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class MediaSetupRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.MediaSetupRequest) */ {
 public:
  inline MediaSetupRequest() : MediaSetupRequest(nullptr) {};
  virtual ~MediaSetupRequest();

  MediaSetupRequest(const MediaSetupRequest& from);
  MediaSetupRequest(MediaSetupRequest&& from) noexcept
    : MediaSetupRequest() {
    *this = ::std::move(from);
  }

  inline MediaSetupRequest& operator=(const MediaSetupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaSetupRequest& operator=(MediaSetupRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MediaSetupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MediaSetupRequest* internal_default_instance() {
    return reinterpret_cast<const MediaSetupRequest*>(
               &_MediaSetupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(MediaSetupRequest& a, MediaSetupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaSetupRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaSetupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MediaSetupRequest* New() const final {
    return CreateMaybeMessage<MediaSetupRequest>(nullptr);
  }

  MediaSetupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MediaSetupRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MediaSetupRequest& from);
  void MergeFrom(const MediaSetupRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaSetupRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.MediaSetupRequest";
  }
  protected:
  explicit MediaSetupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional uint32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.MediaSetupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class MediaSetupResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.MediaSetupResponse) */ {
 public:
  inline MediaSetupResponse() : MediaSetupResponse(nullptr) {};
  virtual ~MediaSetupResponse();

  MediaSetupResponse(const MediaSetupResponse& from);
  MediaSetupResponse(MediaSetupResponse&& from) noexcept
    : MediaSetupResponse() {
    *this = ::std::move(from);
  }

  inline MediaSetupResponse& operator=(const MediaSetupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaSetupResponse& operator=(MediaSetupResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MediaSetupResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MediaSetupResponse* internal_default_instance() {
    return reinterpret_cast<const MediaSetupResponse*>(
               &_MediaSetupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(MediaSetupResponse& a, MediaSetupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaSetupResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaSetupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MediaSetupResponse* New() const final {
    return CreateMaybeMessage<MediaSetupResponse>(nullptr);
  }

  MediaSetupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MediaSetupResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MediaSetupResponse& from);
  void MergeFrom(const MediaSetupResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaSetupResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.MediaSetupResponse";
  }
  protected:
  explicit MediaSetupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MediaSetupResponse_MEDIA_STATUS MEDIA_STATUS;
  static constexpr MEDIA_STATUS MEDIA_STATUS_1 =
    MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_1;
  static constexpr MEDIA_STATUS MEDIA_STATUS_2 =
    MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_2;
  static inline bool MEDIA_STATUS_IsValid(int value) {
    return MediaSetupResponse_MEDIA_STATUS_IsValid(value);
  }
  static constexpr MEDIA_STATUS MEDIA_STATUS_MIN =
    MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_MIN;
  static constexpr MEDIA_STATUS MEDIA_STATUS_MAX =
    MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_MAX;
  static constexpr int MEDIA_STATUS_ARRAYSIZE =
    MediaSetupResponse_MEDIA_STATUS_MEDIA_STATUS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MEDIA_STATUS_descriptor() {
    return MediaSetupResponse_MEDIA_STATUS_descriptor();
  }
  template<typename T>
  static inline const std::string& MEDIA_STATUS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MEDIA_STATUS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MEDIA_STATUS_Name.");
    return MediaSetupResponse_MEDIA_STATUS_Name(enum_t_value);
  }
  static inline bool MEDIA_STATUS_Parse(const std::string& name,
      MEDIA_STATUS* value) {
    return MediaSetupResponse_MEDIA_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfigsFieldNumber = 3,
    kMaxUnackedFieldNumber = 2,
    kMediaStatusFieldNumber = 1,
  };
  // repeated uint32 configs = 3;
  int configs_size() const;
  private:
  int _internal_configs_size() const;
  public:
  void clear_configs();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_configs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_configs() const;
  void _internal_add_configs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_configs();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 configs(int index) const;
  void set_configs(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_configs(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      configs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_configs();

  // required uint32 max_unacked = 2;
  bool has_max_unacked() const;
  private:
  bool _internal_has_max_unacked() const;
  public:
  void clear_max_unacked();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_unacked() const;
  void set_max_unacked(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_max_unacked() const;
  void _internal_set_max_unacked(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .HU.MediaSetupResponse.MEDIA_STATUS media_status = 1;
  bool has_media_status() const;
  private:
  bool _internal_has_media_status() const;
  public:
  void clear_media_status();
  ::HU::MediaSetupResponse_MEDIA_STATUS media_status() const;
  void set_media_status(::HU::MediaSetupResponse_MEDIA_STATUS value);
  private:
  ::HU::MediaSetupResponse_MEDIA_STATUS _internal_media_status() const;
  void _internal_set_media_status(::HU::MediaSetupResponse_MEDIA_STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.MediaSetupResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > configs_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_unacked_;
  int media_status_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class MediaStopRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.MediaStopRequest) */ {
 public:
  inline MediaStopRequest() : MediaStopRequest(nullptr) {};
  virtual ~MediaStopRequest();

  MediaStopRequest(const MediaStopRequest& from);
  MediaStopRequest(MediaStopRequest&& from) noexcept
    : MediaStopRequest() {
    *this = ::std::move(from);
  }

  inline MediaStopRequest& operator=(const MediaStopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaStopRequest& operator=(MediaStopRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MediaStopRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MediaStopRequest* internal_default_instance() {
    return reinterpret_cast<const MediaStopRequest*>(
               &_MediaStopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(MediaStopRequest& a, MediaStopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaStopRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaStopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MediaStopRequest* New() const final {
    return CreateMaybeMessage<MediaStopRequest>(nullptr);
  }

  MediaStopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MediaStopRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MediaStopRequest& from);
  void MergeFrom(const MediaStopRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaStopRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.MediaStopRequest";
  }
  protected:
  explicit MediaStopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.MediaStopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class MediaStartRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.MediaStartRequest) */ {
 public:
  inline MediaStartRequest() : MediaStartRequest(nullptr) {};
  virtual ~MediaStartRequest();

  MediaStartRequest(const MediaStartRequest& from);
  MediaStartRequest(MediaStartRequest&& from) noexcept
    : MediaStartRequest() {
    *this = ::std::move(from);
  }

  inline MediaStartRequest& operator=(const MediaStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaStartRequest& operator=(MediaStartRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MediaStartRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MediaStartRequest* internal_default_instance() {
    return reinterpret_cast<const MediaStartRequest*>(
               &_MediaStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(MediaStartRequest& a, MediaStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaStartRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaStartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MediaStartRequest* New() const final {
    return CreateMaybeMessage<MediaStartRequest>(nullptr);
  }

  MediaStartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MediaStartRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MediaStartRequest& from);
  void MergeFrom(const MediaStartRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaStartRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.MediaStartRequest";
  }
  protected:
  explicit MediaStartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // required int32 session = 1;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::int32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  ::PROTOBUF_NAMESPACE_ID::uint32 config() const;
  void set_config(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_config() const;
  void _internal_set_config(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.MediaStartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 session_;
  ::PROTOBUF_NAMESPACE_ID::uint32 config_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class MediaAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.MediaAck) */ {
 public:
  inline MediaAck() : MediaAck(nullptr) {};
  virtual ~MediaAck();

  MediaAck(const MediaAck& from);
  MediaAck(MediaAck&& from) noexcept
    : MediaAck() {
    *this = ::std::move(from);
  }

  inline MediaAck& operator=(const MediaAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MediaAck& operator=(MediaAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MediaAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MediaAck* internal_default_instance() {
    return reinterpret_cast<const MediaAck*>(
               &_MediaAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(MediaAck& a, MediaAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MediaAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MediaAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MediaAck* New() const final {
    return CreateMaybeMessage<MediaAck>(nullptr);
  }

  MediaAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MediaAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MediaAck& from);
  void MergeFrom(const MediaAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MediaAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.MediaAck";
  }
  protected:
  explicit MediaAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required int32 session = 1;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::int32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required uint32 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.MediaAck)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 session_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class MicRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.MicRequest) */ {
 public:
  inline MicRequest() : MicRequest(nullptr) {};
  virtual ~MicRequest();

  MicRequest(const MicRequest& from);
  MicRequest(MicRequest&& from) noexcept
    : MicRequest() {
    *this = ::std::move(from);
  }

  inline MicRequest& operator=(const MicRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MicRequest& operator=(MicRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MicRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MicRequest* internal_default_instance() {
    return reinterpret_cast<const MicRequest*>(
               &_MicRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(MicRequest& a, MicRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MicRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MicRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MicRequest* New() const final {
    return CreateMaybeMessage<MicRequest>(nullptr);
  }

  MicRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MicRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MicRequest& from);
  void MergeFrom(const MicRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MicRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.MicRequest";
  }
  protected:
  explicit MicRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpenFieldNumber = 1,
    kAncFieldNumber = 2,
    kEcFieldNumber = 3,
    kMaxUnackedFieldNumber = 4,
  };
  // required bool open = 1;
  bool has_open() const;
  private:
  bool _internal_has_open() const;
  public:
  void clear_open();
  bool open() const;
  void set_open(bool value);
  private:
  bool _internal_open() const;
  void _internal_set_open(bool value);
  public:

  // optional bool anc = 2;
  bool has_anc() const;
  private:
  bool _internal_has_anc() const;
  public:
  void clear_anc();
  bool anc() const;
  void set_anc(bool value);
  private:
  bool _internal_anc() const;
  void _internal_set_anc(bool value);
  public:

  // optional bool ec = 3;
  bool has_ec() const;
  private:
  bool _internal_has_ec() const;
  public:
  void clear_ec();
  bool ec() const;
  void set_ec(bool value);
  private:
  bool _internal_ec() const;
  void _internal_set_ec(bool value);
  public:

  // optional int32 max_unacked = 4;
  bool has_max_unacked() const;
  private:
  bool _internal_has_max_unacked() const;
  public:
  void clear_max_unacked();
  ::PROTOBUF_NAMESPACE_ID::int32 max_unacked() const;
  void set_max_unacked(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_unacked() const;
  void _internal_set_max_unacked(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.MicRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool open_;
  bool anc_;
  bool ec_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_unacked_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class MicResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.MicResponse) */ {
 public:
  inline MicResponse() : MicResponse(nullptr) {};
  virtual ~MicResponse();

  MicResponse(const MicResponse& from);
  MicResponse(MicResponse&& from) noexcept
    : MicResponse() {
    *this = ::std::move(from);
  }

  inline MicResponse& operator=(const MicResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MicResponse& operator=(MicResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MicResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MicResponse* internal_default_instance() {
    return reinterpret_cast<const MicResponse*>(
               &_MicResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(MicResponse& a, MicResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MicResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MicResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MicResponse* New() const final {
    return CreateMaybeMessage<MicResponse>(nullptr);
  }

  MicResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MicResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MicResponse& from);
  void MergeFrom(const MicResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MicResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.MicResponse";
  }
  protected:
  explicit MicResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required int32 session = 1;
  bool has_session() const;
  private:
  bool _internal_has_session() const;
  public:
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::int32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required uint32 value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.MicResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 session_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class VideoFocusRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.VideoFocusRequest) */ {
 public:
  inline VideoFocusRequest() : VideoFocusRequest(nullptr) {};
  virtual ~VideoFocusRequest();

  VideoFocusRequest(const VideoFocusRequest& from);
  VideoFocusRequest(VideoFocusRequest&& from) noexcept
    : VideoFocusRequest() {
    *this = ::std::move(from);
  }

  inline VideoFocusRequest& operator=(const VideoFocusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoFocusRequest& operator=(VideoFocusRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoFocusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoFocusRequest* internal_default_instance() {
    return reinterpret_cast<const VideoFocusRequest*>(
               &_VideoFocusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(VideoFocusRequest& a, VideoFocusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoFocusRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoFocusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoFocusRequest* New() const final {
    return CreateMaybeMessage<VideoFocusRequest>(nullptr);
  }

  VideoFocusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoFocusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoFocusRequest& from);
  void MergeFrom(const VideoFocusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoFocusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.VideoFocusRequest";
  }
  protected:
  explicit VideoFocusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDispIndexFieldNumber = 1,
    kModeFieldNumber = 2,
    kReasonFieldNumber = 3,
  };
  // optional int32 disp_index = 1;
  bool has_disp_index() const;
  private:
  bool _internal_has_disp_index() const;
  public:
  void clear_disp_index();
  ::PROTOBUF_NAMESPACE_ID::int32 disp_index() const;
  void set_disp_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_disp_index() const;
  void _internal_set_disp_index(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .HU.VIDEO_FOCUS_MODE mode = 2;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::HU::VIDEO_FOCUS_MODE mode() const;
  void set_mode(::HU::VIDEO_FOCUS_MODE value);
  private:
  ::HU::VIDEO_FOCUS_MODE _internal_mode() const;
  void _internal_set_mode(::HU::VIDEO_FOCUS_MODE value);
  public:

  // optional .HU.VIDEO_FOCUS_REASON reason = 3;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  ::HU::VIDEO_FOCUS_REASON reason() const;
  void set_reason(::HU::VIDEO_FOCUS_REASON value);
  private:
  ::HU::VIDEO_FOCUS_REASON _internal_reason() const;
  void _internal_set_reason(::HU::VIDEO_FOCUS_REASON value);
  public:

  // @@protoc_insertion_point(class_scope:HU.VideoFocusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 disp_index_;
  int mode_;
  int reason_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class VideoFocus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.VideoFocus) */ {
 public:
  inline VideoFocus() : VideoFocus(nullptr) {};
  virtual ~VideoFocus();

  VideoFocus(const VideoFocus& from);
  VideoFocus(VideoFocus&& from) noexcept
    : VideoFocus() {
    *this = ::std::move(from);
  }

  inline VideoFocus& operator=(const VideoFocus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoFocus& operator=(VideoFocus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VideoFocus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VideoFocus* internal_default_instance() {
    return reinterpret_cast<const VideoFocus*>(
               &_VideoFocus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(VideoFocus& a, VideoFocus& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoFocus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoFocus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VideoFocus* New() const final {
    return CreateMaybeMessage<VideoFocus>(nullptr);
  }

  VideoFocus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VideoFocus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VideoFocus& from);
  void MergeFrom(const VideoFocus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoFocus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.VideoFocus";
  }
  protected:
  explicit VideoFocus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnrequestedFieldNumber = 2,
    kModeFieldNumber = 1,
  };
  // optional bool unrequested = 2;
  bool has_unrequested() const;
  private:
  bool _internal_has_unrequested() const;
  public:
  void clear_unrequested();
  bool unrequested() const;
  void set_unrequested(bool value);
  private:
  bool _internal_unrequested() const;
  void _internal_set_unrequested(bool value);
  public:

  // optional .HU.VIDEO_FOCUS_MODE mode = 1;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::HU::VIDEO_FOCUS_MODE mode() const;
  void set_mode(::HU::VIDEO_FOCUS_MODE value);
  private:
  ::HU::VIDEO_FOCUS_MODE _internal_mode() const;
  void _internal_set_mode(::HU::VIDEO_FOCUS_MODE value);
  public:

  // @@protoc_insertion_point(class_scope:HU.VideoFocus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool unrequested_;
  int mode_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorStartRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorStartRequest) */ {
 public:
  inline SensorStartRequest() : SensorStartRequest(nullptr) {};
  virtual ~SensorStartRequest();

  SensorStartRequest(const SensorStartRequest& from);
  SensorStartRequest(SensorStartRequest&& from) noexcept
    : SensorStartRequest() {
    *this = ::std::move(from);
  }

  inline SensorStartRequest& operator=(const SensorStartRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorStartRequest& operator=(SensorStartRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorStartRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorStartRequest* internal_default_instance() {
    return reinterpret_cast<const SensorStartRequest*>(
               &_SensorStartRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(SensorStartRequest& a, SensorStartRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorStartRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorStartRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorStartRequest* New() const final {
    return CreateMaybeMessage<SensorStartRequest>(nullptr);
  }

  SensorStartRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorStartRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorStartRequest& from);
  void MergeFrom(const SensorStartRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorStartRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorStartRequest";
  }
  protected:
  explicit SensorStartRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefreshIntervalFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional int64 refresh_interval = 2;
  bool has_refresh_interval() const;
  private:
  bool _internal_has_refresh_interval() const;
  public:
  void clear_refresh_interval();
  ::PROTOBUF_NAMESPACE_ID::int64 refresh_interval() const;
  void set_refresh_interval(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_refresh_interval() const;
  void _internal_set_refresh_interval(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required .HU.SENSOR_TYPE type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::HU::SENSOR_TYPE type() const;
  void set_type(::HU::SENSOR_TYPE value);
  private:
  ::HU::SENSOR_TYPE _internal_type() const;
  void _internal_set_type(::HU::SENSOR_TYPE value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorStartRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 refresh_interval_;
  int type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class SensorStartResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.SensorStartResponse) */ {
 public:
  inline SensorStartResponse() : SensorStartResponse(nullptr) {};
  virtual ~SensorStartResponse();

  SensorStartResponse(const SensorStartResponse& from);
  SensorStartResponse(SensorStartResponse&& from) noexcept
    : SensorStartResponse() {
    *this = ::std::move(from);
  }

  inline SensorStartResponse& operator=(const SensorStartResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorStartResponse& operator=(SensorStartResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorStartResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorStartResponse* internal_default_instance() {
    return reinterpret_cast<const SensorStartResponse*>(
               &_SensorStartResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(SensorStartResponse& a, SensorStartResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorStartResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorStartResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorStartResponse* New() const final {
    return CreateMaybeMessage<SensorStartResponse>(nullptr);
  }

  SensorStartResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorStartResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorStartResponse& from);
  void MergeFrom(const SensorStartResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorStartResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.SensorStartResponse";
  }
  protected:
  explicit SensorStartResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .HU.STATUS status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::HU::STATUS status() const;
  void set_status(::HU::STATUS value);
  private:
  ::HU::STATUS _internal_status() const;
  void _internal_set_status(::HU::STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.SensorStartResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class NavigationFocusRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.NavigationFocusRequest) */ {
 public:
  inline NavigationFocusRequest() : NavigationFocusRequest(nullptr) {};
  virtual ~NavigationFocusRequest();

  NavigationFocusRequest(const NavigationFocusRequest& from);
  NavigationFocusRequest(NavigationFocusRequest&& from) noexcept
    : NavigationFocusRequest() {
    *this = ::std::move(from);
  }

  inline NavigationFocusRequest& operator=(const NavigationFocusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationFocusRequest& operator=(NavigationFocusRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationFocusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavigationFocusRequest* internal_default_instance() {
    return reinterpret_cast<const NavigationFocusRequest*>(
               &_NavigationFocusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(NavigationFocusRequest& a, NavigationFocusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationFocusRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationFocusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationFocusRequest* New() const final {
    return CreateMaybeMessage<NavigationFocusRequest>(nullptr);
  }

  NavigationFocusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationFocusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationFocusRequest& from);
  void MergeFrom(const NavigationFocusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationFocusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.NavigationFocusRequest";
  }
  protected:
  explicit NavigationFocusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFocusTypeFieldNumber = 1,
  };
  // optional uint32 focus_type = 1;
  bool has_focus_type() const;
  private:
  bool _internal_has_focus_type() const;
  public:
  void clear_focus_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 focus_type() const;
  void set_focus_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_focus_type() const;
  void _internal_set_focus_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.NavigationFocusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 focus_type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class NavigationFocusResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.NavigationFocusResponse) */ {
 public:
  inline NavigationFocusResponse() : NavigationFocusResponse(nullptr) {};
  virtual ~NavigationFocusResponse();

  NavigationFocusResponse(const NavigationFocusResponse& from);
  NavigationFocusResponse(NavigationFocusResponse&& from) noexcept
    : NavigationFocusResponse() {
    *this = ::std::move(from);
  }

  inline NavigationFocusResponse& operator=(const NavigationFocusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationFocusResponse& operator=(NavigationFocusResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NavigationFocusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NavigationFocusResponse* internal_default_instance() {
    return reinterpret_cast<const NavigationFocusResponse*>(
               &_NavigationFocusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(NavigationFocusResponse& a, NavigationFocusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NavigationFocusResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationFocusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NavigationFocusResponse* New() const final {
    return CreateMaybeMessage<NavigationFocusResponse>(nullptr);
  }

  NavigationFocusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NavigationFocusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NavigationFocusResponse& from);
  void MergeFrom(const NavigationFocusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NavigationFocusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.NavigationFocusResponse";
  }
  protected:
  explicit NavigationFocusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFocusTypeFieldNumber = 1,
  };
  // optional uint32 focus_type = 1;
  bool has_focus_type() const;
  private:
  bool _internal_has_focus_type() const;
  public:
  void clear_focus_type();
  ::PROTOBUF_NAMESPACE_ID::uint32 focus_type() const;
  void set_focus_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_focus_type() const;
  void _internal_set_focus_type(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.NavigationFocusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 focus_type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class VoiceSessionRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.VoiceSessionRequest) */ {
 public:
  inline VoiceSessionRequest() : VoiceSessionRequest(nullptr) {};
  virtual ~VoiceSessionRequest();

  VoiceSessionRequest(const VoiceSessionRequest& from);
  VoiceSessionRequest(VoiceSessionRequest&& from) noexcept
    : VoiceSessionRequest() {
    *this = ::std::move(from);
  }

  inline VoiceSessionRequest& operator=(const VoiceSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoiceSessionRequest& operator=(VoiceSessionRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VoiceSessionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoiceSessionRequest* internal_default_instance() {
    return reinterpret_cast<const VoiceSessionRequest*>(
               &_VoiceSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(VoiceSessionRequest& a, VoiceSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VoiceSessionRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoiceSessionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoiceSessionRequest* New() const final {
    return CreateMaybeMessage<VoiceSessionRequest>(nullptr);
  }

  VoiceSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoiceSessionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VoiceSessionRequest& from);
  void MergeFrom(const VoiceSessionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceSessionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.VoiceSessionRequest";
  }
  protected:
  explicit VoiceSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VoiceSessionRequest_VOICE_STATUS VOICE_STATUS;
  static constexpr VOICE_STATUS VOICE_STATUS_START =
    VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_START;
  static constexpr VOICE_STATUS VOICE_STATUS_STOP =
    VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_STOP;
  static inline bool VOICE_STATUS_IsValid(int value) {
    return VoiceSessionRequest_VOICE_STATUS_IsValid(value);
  }
  static constexpr VOICE_STATUS VOICE_STATUS_MIN =
    VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_MIN;
  static constexpr VOICE_STATUS VOICE_STATUS_MAX =
    VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_MAX;
  static constexpr int VOICE_STATUS_ARRAYSIZE =
    VoiceSessionRequest_VOICE_STATUS_VOICE_STATUS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  VOICE_STATUS_descriptor() {
    return VoiceSessionRequest_VOICE_STATUS_descriptor();
  }
  template<typename T>
  static inline const std::string& VOICE_STATUS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, VOICE_STATUS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function VOICE_STATUS_Name.");
    return VoiceSessionRequest_VOICE_STATUS_Name(enum_t_value);
  }
  static inline bool VOICE_STATUS_Parse(const std::string& name,
      VOICE_STATUS* value) {
    return VoiceSessionRequest_VOICE_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVoiceStatusFieldNumber = 1,
  };
  // optional .HU.VoiceSessionRequest.VOICE_STATUS voice_status = 1;
  bool has_voice_status() const;
  private:
  bool _internal_has_voice_status() const;
  public:
  void clear_voice_status();
  ::HU::VoiceSessionRequest_VOICE_STATUS voice_status() const;
  void set_voice_status(::HU::VoiceSessionRequest_VOICE_STATUS value);
  private:
  ::HU::VoiceSessionRequest_VOICE_STATUS _internal_voice_status() const;
  void _internal_set_voice_status(::HU::VoiceSessionRequest_VOICE_STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.VoiceSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int voice_status_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class AudioFocusRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.AudioFocusRequest) */ {
 public:
  inline AudioFocusRequest() : AudioFocusRequest(nullptr) {};
  virtual ~AudioFocusRequest();

  AudioFocusRequest(const AudioFocusRequest& from);
  AudioFocusRequest(AudioFocusRequest&& from) noexcept
    : AudioFocusRequest() {
    *this = ::std::move(from);
  }

  inline AudioFocusRequest& operator=(const AudioFocusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioFocusRequest& operator=(AudioFocusRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioFocusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioFocusRequest* internal_default_instance() {
    return reinterpret_cast<const AudioFocusRequest*>(
               &_AudioFocusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(AudioFocusRequest& a, AudioFocusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioFocusRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioFocusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioFocusRequest* New() const final {
    return CreateMaybeMessage<AudioFocusRequest>(nullptr);
  }

  AudioFocusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioFocusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioFocusRequest& from);
  void MergeFrom(const AudioFocusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioFocusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.AudioFocusRequest";
  }
  protected:
  explicit AudioFocusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AudioFocusRequest_AUDIO_FOCUS AUDIO_FOCUS;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_GAIN =
    AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_GAIN_TRANSIENT =
    AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN_TRANSIENT;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_GAIN_NAVI =
    AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_GAIN_NAVI;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_RELEASE =
    AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_RELEASE;
  static inline bool AUDIO_FOCUS_IsValid(int value) {
    return AudioFocusRequest_AUDIO_FOCUS_IsValid(value);
  }
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_MIN =
    AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_MIN;
  static constexpr AUDIO_FOCUS AUDIO_FOCUS_MAX =
    AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_MAX;
  static constexpr int AUDIO_FOCUS_ARRAYSIZE =
    AudioFocusRequest_AUDIO_FOCUS_AUDIO_FOCUS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AUDIO_FOCUS_descriptor() {
    return AudioFocusRequest_AUDIO_FOCUS_descriptor();
  }
  template<typename T>
  static inline const std::string& AUDIO_FOCUS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AUDIO_FOCUS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AUDIO_FOCUS_Name.");
    return AudioFocusRequest_AUDIO_FOCUS_Name(enum_t_value);
  }
  static inline bool AUDIO_FOCUS_Parse(const std::string& name,
      AUDIO_FOCUS* value) {
    return AudioFocusRequest_AUDIO_FOCUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFocusTypeFieldNumber = 1,
  };
  // required .HU.AudioFocusRequest.AUDIO_FOCUS focus_type = 1;
  bool has_focus_type() const;
  private:
  bool _internal_has_focus_type() const;
  public:
  void clear_focus_type();
  ::HU::AudioFocusRequest_AUDIO_FOCUS focus_type() const;
  void set_focus_type(::HU::AudioFocusRequest_AUDIO_FOCUS value);
  private:
  ::HU::AudioFocusRequest_AUDIO_FOCUS _internal_focus_type() const;
  void _internal_set_focus_type(::HU::AudioFocusRequest_AUDIO_FOCUS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.AudioFocusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int focus_type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class AudioFocusResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.AudioFocusResponse) */ {
 public:
  inline AudioFocusResponse() : AudioFocusResponse(nullptr) {};
  virtual ~AudioFocusResponse();

  AudioFocusResponse(const AudioFocusResponse& from);
  AudioFocusResponse(AudioFocusResponse&& from) noexcept
    : AudioFocusResponse() {
    *this = ::std::move(from);
  }

  inline AudioFocusResponse& operator=(const AudioFocusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioFocusResponse& operator=(AudioFocusResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AudioFocusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AudioFocusResponse* internal_default_instance() {
    return reinterpret_cast<const AudioFocusResponse*>(
               &_AudioFocusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(AudioFocusResponse& a, AudioFocusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioFocusResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioFocusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AudioFocusResponse* New() const final {
    return CreateMaybeMessage<AudioFocusResponse>(nullptr);
  }

  AudioFocusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AudioFocusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AudioFocusResponse& from);
  void MergeFrom(const AudioFocusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioFocusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.AudioFocusResponse";
  }
  protected:
  explicit AudioFocusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AudioFocusResponse_AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_GAIN =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_GAIN_TRANSIENT =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_TRANSIENT;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_LOSS =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS_TRANSIENT_CAN_DUCK;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_LOSS_TRANSIENT =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_LOSS_TRANSIENT;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_MEDIA_ONLY;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_GAIN_TRANSIENT_GUIDANCE_ONLY;
  static inline bool AUDIO_FOCUS_STATE_IsValid(int value) {
    return AudioFocusResponse_AUDIO_FOCUS_STATE_IsValid(value);
  }
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_MIN =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_MIN;
  static constexpr AUDIO_FOCUS_STATE AUDIO_FOCUS_STATE_MAX =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_MAX;
  static constexpr int AUDIO_FOCUS_STATE_ARRAYSIZE =
    AudioFocusResponse_AUDIO_FOCUS_STATE_AUDIO_FOCUS_STATE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AUDIO_FOCUS_STATE_descriptor() {
    return AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor();
  }
  template<typename T>
  static inline const std::string& AUDIO_FOCUS_STATE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AUDIO_FOCUS_STATE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AUDIO_FOCUS_STATE_Name.");
    return AudioFocusResponse_AUDIO_FOCUS_STATE_Name(enum_t_value);
  }
  static inline bool AUDIO_FOCUS_STATE_Parse(const std::string& name,
      AUDIO_FOCUS_STATE* value) {
    return AudioFocusResponse_AUDIO_FOCUS_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFocusTypeFieldNumber = 1,
  };
  // required .HU.AudioFocusResponse.AUDIO_FOCUS_STATE focus_type = 1;
  bool has_focus_type() const;
  private:
  bool _internal_has_focus_type() const;
  public:
  void clear_focus_type();
  ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE focus_type() const;
  void set_focus_type(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE value);
  private:
  ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE _internal_focus_type() const;
  void _internal_set_focus_type(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE value);
  public:

  // @@protoc_insertion_point(class_scope:HU.AudioFocusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int focus_type_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class AuthCompleteResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.AuthCompleteResponse) */ {
 public:
  inline AuthCompleteResponse() : AuthCompleteResponse(nullptr) {};
  virtual ~AuthCompleteResponse();

  AuthCompleteResponse(const AuthCompleteResponse& from);
  AuthCompleteResponse(AuthCompleteResponse&& from) noexcept
    : AuthCompleteResponse() {
    *this = ::std::move(from);
  }

  inline AuthCompleteResponse& operator=(const AuthCompleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthCompleteResponse& operator=(AuthCompleteResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AuthCompleteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthCompleteResponse* internal_default_instance() {
    return reinterpret_cast<const AuthCompleteResponse*>(
               &_AuthCompleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(AuthCompleteResponse& a, AuthCompleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthCompleteResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthCompleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthCompleteResponse* New() const final {
    return CreateMaybeMessage<AuthCompleteResponse>(nullptr);
  }

  AuthCompleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthCompleteResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AuthCompleteResponse& from);
  void MergeFrom(const AuthCompleteResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthCompleteResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.AuthCompleteResponse";
  }
  protected:
  explicit AuthCompleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required .HU.STATUS status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::HU::STATUS status() const;
  void set_status(::HU::STATUS value);
  private:
  ::HU::STATUS _internal_status() const;
  void _internal_set_status(::HU::STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.AuthCompleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class PhoneStatus_Call PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.PhoneStatus.Call) */ {
 public:
  inline PhoneStatus_Call() : PhoneStatus_Call(nullptr) {};
  virtual ~PhoneStatus_Call();

  PhoneStatus_Call(const PhoneStatus_Call& from);
  PhoneStatus_Call(PhoneStatus_Call&& from) noexcept
    : PhoneStatus_Call() {
    *this = ::std::move(from);
  }

  inline PhoneStatus_Call& operator=(const PhoneStatus_Call& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneStatus_Call& operator=(PhoneStatus_Call&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhoneStatus_Call& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhoneStatus_Call* internal_default_instance() {
    return reinterpret_cast<const PhoneStatus_Call*>(
               &_PhoneStatus_Call_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(PhoneStatus_Call& a, PhoneStatus_Call& b) {
    a.Swap(&b);
  }
  inline void Swap(PhoneStatus_Call* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhoneStatus_Call* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhoneStatus_Call* New() const final {
    return CreateMaybeMessage<PhoneStatus_Call>(nullptr);
  }

  PhoneStatus_Call* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhoneStatus_Call>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhoneStatus_Call& from);
  void MergeFrom(const PhoneStatus_Call& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhoneStatus_Call* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.PhoneStatus.Call";
  }
  protected:
  explicit PhoneStatus_Call(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneNumberFieldNumber = 3,
    kCallerIdFieldNumber = 4,
    kPhoneNumberTypeFieldNumber = 5,
    kThumbnailFieldNumber = 6,
    kCallTimeFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // optional string phone_number = 3;
  bool has_phone_number() const;
  private:
  bool _internal_has_phone_number() const;
  public:
  void clear_phone_number();
  const std::string& phone_number() const;
  void set_phone_number(const std::string& value);
  void set_phone_number(std::string&& value);
  void set_phone_number(const char* value);
  void set_phone_number(const char* value, size_t size);
  std::string* mutable_phone_number();
  std::string* release_phone_number();
  void set_allocated_phone_number(std::string* phone_number);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_phone_number();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_phone_number(
      std::string* phone_number);
  private:
  const std::string& _internal_phone_number() const;
  void _internal_set_phone_number(const std::string& value);
  std::string* _internal_mutable_phone_number();
  public:

  // optional string caller_id = 4;
  bool has_caller_id() const;
  private:
  bool _internal_has_caller_id() const;
  public:
  void clear_caller_id();
  const std::string& caller_id() const;
  void set_caller_id(const std::string& value);
  void set_caller_id(std::string&& value);
  void set_caller_id(const char* value);
  void set_caller_id(const char* value, size_t size);
  std::string* mutable_caller_id();
  std::string* release_caller_id();
  void set_allocated_caller_id(std::string* caller_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_caller_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_caller_id(
      std::string* caller_id);
  private:
  const std::string& _internal_caller_id() const;
  void _internal_set_caller_id(const std::string& value);
  std::string* _internal_mutable_caller_id();
  public:

  // optional string phone_number_type = 5;
  bool has_phone_number_type() const;
  private:
  bool _internal_has_phone_number_type() const;
  public:
  void clear_phone_number_type();
  const std::string& phone_number_type() const;
  void set_phone_number_type(const std::string& value);
  void set_phone_number_type(std::string&& value);
  void set_phone_number_type(const char* value);
  void set_phone_number_type(const char* value, size_t size);
  std::string* mutable_phone_number_type();
  std::string* release_phone_number_type();
  void set_allocated_phone_number_type(std::string* phone_number_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_phone_number_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_phone_number_type(
      std::string* phone_number_type);
  private:
  const std::string& _internal_phone_number_type() const;
  void _internal_set_phone_number_type(const std::string& value);
  std::string* _internal_mutable_phone_number_type();
  public:

  // optional bytes thumbnail = 6;
  bool has_thumbnail() const;
  private:
  bool _internal_has_thumbnail() const;
  public:
  void clear_thumbnail();
  const std::string& thumbnail() const;
  void set_thumbnail(const std::string& value);
  void set_thumbnail(std::string&& value);
  void set_thumbnail(const char* value);
  void set_thumbnail(const void* value, size_t size);
  std::string* mutable_thumbnail();
  std::string* release_thumbnail();
  void set_allocated_thumbnail(std::string* thumbnail);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_thumbnail();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_thumbnail(
      std::string* thumbnail);
  private:
  const std::string& _internal_thumbnail() const;
  void _internal_set_thumbnail(const std::string& value);
  std::string* _internal_mutable_thumbnail();
  public:

  // optional uint32 call_time = 2;
  bool has_call_time() const;
  private:
  bool _internal_has_call_time() const;
  public:
  void clear_call_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 call_time() const;
  void set_call_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_call_time() const;
  void _internal_set_call_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .HU.PhoneStatus.PHONE_STATE state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::HU::PhoneStatus_PHONE_STATE state() const;
  void set_state(::HU::PhoneStatus_PHONE_STATE value);
  private:
  ::HU::PhoneStatus_PHONE_STATE _internal_state() const;
  void _internal_set_state(::HU::PhoneStatus_PHONE_STATE value);
  public:

  // @@protoc_insertion_point(class_scope:HU.PhoneStatus.Call)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_number_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_;
  ::PROTOBUF_NAMESPACE_ID::uint32 call_time_;
  int state_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class PhoneStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.PhoneStatus) */ {
 public:
  inline PhoneStatus() : PhoneStatus(nullptr) {};
  virtual ~PhoneStatus();

  PhoneStatus(const PhoneStatus& from);
  PhoneStatus(PhoneStatus&& from) noexcept
    : PhoneStatus() {
    *this = ::std::move(from);
  }

  inline PhoneStatus& operator=(const PhoneStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneStatus& operator=(PhoneStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhoneStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhoneStatus* internal_default_instance() {
    return reinterpret_cast<const PhoneStatus*>(
               &_PhoneStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(PhoneStatus& a, PhoneStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PhoneStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhoneStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhoneStatus* New() const final {
    return CreateMaybeMessage<PhoneStatus>(nullptr);
  }

  PhoneStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhoneStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhoneStatus& from);
  void MergeFrom(const PhoneStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhoneStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.PhoneStatus";
  }
  protected:
  explicit PhoneStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PhoneStatus_Call Call;

  typedef PhoneStatus_PHONE_STATE PHONE_STATE;
  static constexpr PHONE_STATE PHONE_STATE_IN_CALL =
    PhoneStatus_PHONE_STATE_PHONE_STATE_IN_CALL;
  static constexpr PHONE_STATE PHONE_STATE_ON_HOLD =
    PhoneStatus_PHONE_STATE_PHONE_STATE_ON_HOLD;
  static constexpr PHONE_STATE PHONE_STATE_HANGINGUP =
    PhoneStatus_PHONE_STATE_PHONE_STATE_HANGINGUP;
  static constexpr PHONE_STATE PHONE_STATE_INCOMING =
    PhoneStatus_PHONE_STATE_PHONE_STATE_INCOMING;
  static constexpr PHONE_STATE PHONE_STATE_UNKNOWN_5 =
    PhoneStatus_PHONE_STATE_PHONE_STATE_UNKNOWN_5;
  static constexpr PHONE_STATE PHONE_STATE_UNKNOWN_6 =
    PhoneStatus_PHONE_STATE_PHONE_STATE_UNKNOWN_6;
  static inline bool PHONE_STATE_IsValid(int value) {
    return PhoneStatus_PHONE_STATE_IsValid(value);
  }
  static constexpr PHONE_STATE PHONE_STATE_MIN =
    PhoneStatus_PHONE_STATE_PHONE_STATE_MIN;
  static constexpr PHONE_STATE PHONE_STATE_MAX =
    PhoneStatus_PHONE_STATE_PHONE_STATE_MAX;
  static constexpr int PHONE_STATE_ARRAYSIZE =
    PhoneStatus_PHONE_STATE_PHONE_STATE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PHONE_STATE_descriptor() {
    return PhoneStatus_PHONE_STATE_descriptor();
  }
  template<typename T>
  static inline const std::string& PHONE_STATE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PHONE_STATE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PHONE_STATE_Name.");
    return PhoneStatus_PHONE_STATE_Name(enum_t_value);
  }
  static inline bool PHONE_STATE_Parse(const std::string& name,
      PHONE_STATE* value) {
    return PhoneStatus_PHONE_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCallsFieldNumber = 1,
    kSignalStrengthFieldNumber = 2,
  };
  // repeated .HU.PhoneStatus.Call calls = 1;
  int calls_size() const;
  private:
  int _internal_calls_size() const;
  public:
  void clear_calls();
  ::HU::PhoneStatus_Call* mutable_calls(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::PhoneStatus_Call >*
      mutable_calls();
  private:
  const ::HU::PhoneStatus_Call& _internal_calls(int index) const;
  ::HU::PhoneStatus_Call* _internal_add_calls();
  public:
  const ::HU::PhoneStatus_Call& calls(int index) const;
  ::HU::PhoneStatus_Call* add_calls();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::PhoneStatus_Call >&
      calls() const;

  // optional uint32 signal_strength = 2;
  bool has_signal_strength() const;
  private:
  bool _internal_has_signal_strength() const;
  public:
  void clear_signal_strength();
  ::PROTOBUF_NAMESPACE_ID::uint32 signal_strength() const;
  void set_signal_strength(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_signal_strength() const;
  void _internal_set_signal_strength(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:HU.PhoneStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::PhoneStatus_Call > calls_;
  ::PROTOBUF_NAMESPACE_ID::uint32 signal_strength_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class PhoneStatusInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.PhoneStatusInput) */ {
 public:
  inline PhoneStatusInput() : PhoneStatusInput(nullptr) {};
  virtual ~PhoneStatusInput();

  PhoneStatusInput(const PhoneStatusInput& from);
  PhoneStatusInput(PhoneStatusInput&& from) noexcept
    : PhoneStatusInput() {
    *this = ::std::move(from);
  }

  inline PhoneStatusInput& operator=(const PhoneStatusInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhoneStatusInput& operator=(PhoneStatusInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhoneStatusInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhoneStatusInput* internal_default_instance() {
    return reinterpret_cast<const PhoneStatusInput*>(
               &_PhoneStatusInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(PhoneStatusInput& a, PhoneStatusInput& b) {
    a.Swap(&b);
  }
  inline void Swap(PhoneStatusInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhoneStatusInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhoneStatusInput* New() const final {
    return CreateMaybeMessage<PhoneStatusInput>(nullptr);
  }

  PhoneStatusInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhoneStatusInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhoneStatusInput& from);
  void MergeFrom(const PhoneStatusInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhoneStatusInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.PhoneStatusInput";
  }
  protected:
  explicit PhoneStatusInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallerNumberFieldNumber = 1,
    kCallerIdFieldNumber = 2,
  };
  // optional string caller_number = 1;
  bool has_caller_number() const;
  private:
  bool _internal_has_caller_number() const;
  public:
  void clear_caller_number();
  const std::string& caller_number() const;
  void set_caller_number(const std::string& value);
  void set_caller_number(std::string&& value);
  void set_caller_number(const char* value);
  void set_caller_number(const char* value, size_t size);
  std::string* mutable_caller_number();
  std::string* release_caller_number();
  void set_allocated_caller_number(std::string* caller_number);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_caller_number();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_caller_number(
      std::string* caller_number);
  private:
  const std::string& _internal_caller_number() const;
  void _internal_set_caller_number(const std::string& value);
  std::string* _internal_mutable_caller_number();
  public:

  // optional string caller_id = 2;
  bool has_caller_id() const;
  private:
  bool _internal_has_caller_id() const;
  public:
  void clear_caller_id();
  const std::string& caller_id() const;
  void set_caller_id(const std::string& value);
  void set_caller_id(std::string&& value);
  void set_caller_id(const char* value);
  void set_caller_id(const char* value, size_t size);
  std::string* mutable_caller_id();
  std::string* release_caller_id();
  void set_allocated_caller_id(std::string* caller_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_caller_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_caller_id(
      std::string* caller_id);
  private:
  const std::string& _internal_caller_id() const;
  void _internal_set_caller_id(const std::string& value);
  std::string* _internal_mutable_caller_id();
  public:

  // @@protoc_insertion_point(class_scope:HU.PhoneStatusInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_number_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caller_id_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class GenericNotificationRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.GenericNotificationRequest) */ {
 public:
  inline GenericNotificationRequest() : GenericNotificationRequest(nullptr) {};
  virtual ~GenericNotificationRequest();

  GenericNotificationRequest(const GenericNotificationRequest& from);
  GenericNotificationRequest(GenericNotificationRequest&& from) noexcept
    : GenericNotificationRequest() {
    *this = ::std::move(from);
  }

  inline GenericNotificationRequest& operator=(const GenericNotificationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericNotificationRequest& operator=(GenericNotificationRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenericNotificationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericNotificationRequest* internal_default_instance() {
    return reinterpret_cast<const GenericNotificationRequest*>(
               &_GenericNotificationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(GenericNotificationRequest& a, GenericNotificationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericNotificationRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericNotificationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericNotificationRequest* New() const final {
    return CreateMaybeMessage<GenericNotificationRequest>(nullptr);
  }

  GenericNotificationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericNotificationRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenericNotificationRequest& from);
  void MergeFrom(const GenericNotificationRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericNotificationRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.GenericNotificationRequest";
  }
  protected:
  explicit GenericNotificationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kTextFieldNumber = 2,
    kIconFieldNumber = 3,
  };
  // required string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_text();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_text(
      std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string icon = 3;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  const std::string& icon() const;
  void set_icon(const std::string& value);
  void set_icon(std::string&& value);
  void set_icon(const char* value);
  void set_icon(const char* value, size_t size);
  std::string* mutable_icon();
  std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_icon();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_icon(
      std::string* icon);
  private:
  const std::string& _internal_icon() const;
  void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // @@protoc_insertion_point(class_scope:HU.GenericNotificationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class GenericNotificationResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.GenericNotificationResponse) */ {
 public:
  inline GenericNotificationResponse() : GenericNotificationResponse(nullptr) {};
  virtual ~GenericNotificationResponse();

  GenericNotificationResponse(const GenericNotificationResponse& from);
  GenericNotificationResponse(GenericNotificationResponse&& from) noexcept
    : GenericNotificationResponse() {
    *this = ::std::move(from);
  }

  inline GenericNotificationResponse& operator=(const GenericNotificationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenericNotificationResponse& operator=(GenericNotificationResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GenericNotificationResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GenericNotificationResponse* internal_default_instance() {
    return reinterpret_cast<const GenericNotificationResponse*>(
               &_GenericNotificationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(GenericNotificationResponse& a, GenericNotificationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenericNotificationResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenericNotificationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenericNotificationResponse* New() const final {
    return CreateMaybeMessage<GenericNotificationResponse>(nullptr);
  }

  GenericNotificationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenericNotificationResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GenericNotificationResponse& from);
  void MergeFrom(const GenericNotificationResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenericNotificationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.GenericNotificationResponse";
  }
  protected:
  explicit GenericNotificationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHandledFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_id(
      std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // required bool handled = 2;
  bool has_handled() const;
  private:
  bool _internal_has_handled() const;
  public:
  void clear_handled();
  bool handled() const;
  void set_handled(bool value);
  private:
  bool _internal_handled() const;
  void _internal_set_handled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HU.GenericNotificationResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  bool handled_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class StartGenericNotifications PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.StartGenericNotifications) */ {
 public:
  inline StartGenericNotifications() : StartGenericNotifications(nullptr) {};
  virtual ~StartGenericNotifications();

  StartGenericNotifications(const StartGenericNotifications& from);
  StartGenericNotifications(StartGenericNotifications&& from) noexcept
    : StartGenericNotifications() {
    *this = ::std::move(from);
  }

  inline StartGenericNotifications& operator=(const StartGenericNotifications& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartGenericNotifications& operator=(StartGenericNotifications&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartGenericNotifications& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartGenericNotifications* internal_default_instance() {
    return reinterpret_cast<const StartGenericNotifications*>(
               &_StartGenericNotifications_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(StartGenericNotifications& a, StartGenericNotifications& b) {
    a.Swap(&b);
  }
  inline void Swap(StartGenericNotifications* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartGenericNotifications* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartGenericNotifications* New() const final {
    return CreateMaybeMessage<StartGenericNotifications>(nullptr);
  }

  StartGenericNotifications* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartGenericNotifications>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartGenericNotifications& from);
  void MergeFrom(const StartGenericNotifications& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartGenericNotifications* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.StartGenericNotifications";
  }
  protected:
  explicit StartGenericNotifications(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.StartGenericNotifications)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class StopGenericNotifications PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.StopGenericNotifications) */ {
 public:
  inline StopGenericNotifications() : StopGenericNotifications(nullptr) {};
  virtual ~StopGenericNotifications();

  StopGenericNotifications(const StopGenericNotifications& from);
  StopGenericNotifications(StopGenericNotifications&& from) noexcept
    : StopGenericNotifications() {
    *this = ::std::move(from);
  }

  inline StopGenericNotifications& operator=(const StopGenericNotifications& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopGenericNotifications& operator=(StopGenericNotifications&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopGenericNotifications& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopGenericNotifications* internal_default_instance() {
    return reinterpret_cast<const StopGenericNotifications*>(
               &_StopGenericNotifications_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(StopGenericNotifications& a, StopGenericNotifications& b) {
    a.Swap(&b);
  }
  inline void Swap(StopGenericNotifications* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopGenericNotifications* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopGenericNotifications* New() const final {
    return CreateMaybeMessage<StopGenericNotifications>(nullptr);
  }

  StopGenericNotifications* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopGenericNotifications>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopGenericNotifications& from);
  void MergeFrom(const StopGenericNotifications& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopGenericNotifications* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.StopGenericNotifications";
  }
  protected:
  explicit StopGenericNotifications(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HU.StopGenericNotifications)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class BluetoothPairingRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.BluetoothPairingRequest) */ {
 public:
  inline BluetoothPairingRequest() : BluetoothPairingRequest(nullptr) {};
  virtual ~BluetoothPairingRequest();

  BluetoothPairingRequest(const BluetoothPairingRequest& from);
  BluetoothPairingRequest(BluetoothPairingRequest&& from) noexcept
    : BluetoothPairingRequest() {
    *this = ::std::move(from);
  }

  inline BluetoothPairingRequest& operator=(const BluetoothPairingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothPairingRequest& operator=(BluetoothPairingRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BluetoothPairingRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BluetoothPairingRequest* internal_default_instance() {
    return reinterpret_cast<const BluetoothPairingRequest*>(
               &_BluetoothPairingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(BluetoothPairingRequest& a, BluetoothPairingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothPairingRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothPairingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BluetoothPairingRequest* New() const final {
    return CreateMaybeMessage<BluetoothPairingRequest>(nullptr);
  }

  BluetoothPairingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BluetoothPairingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BluetoothPairingRequest& from);
  void MergeFrom(const BluetoothPairingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BluetoothPairingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.BluetoothPairingRequest";
  }
  protected:
  explicit BluetoothPairingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneAddressFieldNumber = 1,
    kPairingMethodFieldNumber = 2,
  };
  // required string phone_address = 1;
  bool has_phone_address() const;
  private:
  bool _internal_has_phone_address() const;
  public:
  void clear_phone_address();
  const std::string& phone_address() const;
  void set_phone_address(const std::string& value);
  void set_phone_address(std::string&& value);
  void set_phone_address(const char* value);
  void set_phone_address(const char* value, size_t size);
  std::string* mutable_phone_address();
  std::string* release_phone_address();
  void set_allocated_phone_address(std::string* phone_address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_phone_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_phone_address(
      std::string* phone_address);
  private:
  const std::string& _internal_phone_address() const;
  void _internal_set_phone_address(const std::string& value);
  std::string* _internal_mutable_phone_address();
  public:

  // optional .HU.BluetoothPairingMethod pairing_method = 2;
  bool has_pairing_method() const;
  private:
  bool _internal_has_pairing_method() const;
  public:
  void clear_pairing_method();
  ::HU::BluetoothPairingMethod pairing_method() const;
  void set_pairing_method(::HU::BluetoothPairingMethod value);
  private:
  ::HU::BluetoothPairingMethod _internal_pairing_method() const;
  void _internal_set_pairing_method(::HU::BluetoothPairingMethod value);
  public:

  // @@protoc_insertion_point(class_scope:HU.BluetoothPairingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_address_;
  int pairing_method_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class BluetoothPairingResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.BluetoothPairingResponse) */ {
 public:
  inline BluetoothPairingResponse() : BluetoothPairingResponse(nullptr) {};
  virtual ~BluetoothPairingResponse();

  BluetoothPairingResponse(const BluetoothPairingResponse& from);
  BluetoothPairingResponse(BluetoothPairingResponse&& from) noexcept
    : BluetoothPairingResponse() {
    *this = ::std::move(from);
  }

  inline BluetoothPairingResponse& operator=(const BluetoothPairingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothPairingResponse& operator=(BluetoothPairingResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BluetoothPairingResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BluetoothPairingResponse* internal_default_instance() {
    return reinterpret_cast<const BluetoothPairingResponse*>(
               &_BluetoothPairingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(BluetoothPairingResponse& a, BluetoothPairingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothPairingResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothPairingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BluetoothPairingResponse* New() const final {
    return CreateMaybeMessage<BluetoothPairingResponse>(nullptr);
  }

  BluetoothPairingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BluetoothPairingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BluetoothPairingResponse& from);
  void MergeFrom(const BluetoothPairingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BluetoothPairingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.BluetoothPairingResponse";
  }
  protected:
  explicit BluetoothPairingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BluetoothPairingResponse_PAIRING_STATUS PAIRING_STATUS;
  static constexpr PAIRING_STATUS PAIRING_STATUS_1 =
    BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_1;
  static constexpr PAIRING_STATUS PAIRING_STATUS_2 =
    BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_2;
  static inline bool PAIRING_STATUS_IsValid(int value) {
    return BluetoothPairingResponse_PAIRING_STATUS_IsValid(value);
  }
  static constexpr PAIRING_STATUS PAIRING_STATUS_MIN =
    BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_MIN;
  static constexpr PAIRING_STATUS PAIRING_STATUS_MAX =
    BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_MAX;
  static constexpr int PAIRING_STATUS_ARRAYSIZE =
    BluetoothPairingResponse_PAIRING_STATUS_PAIRING_STATUS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PAIRING_STATUS_descriptor() {
    return BluetoothPairingResponse_PAIRING_STATUS_descriptor();
  }
  template<typename T>
  static inline const std::string& PAIRING_STATUS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PAIRING_STATUS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PAIRING_STATUS_Name.");
    return BluetoothPairingResponse_PAIRING_STATUS_Name(enum_t_value);
  }
  static inline bool PAIRING_STATUS_Parse(const std::string& name,
      PAIRING_STATUS* value) {
    return BluetoothPairingResponse_PAIRING_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAlreadyPairedFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // optional bool already_paired = 1;
  bool has_already_paired() const;
  private:
  bool _internal_has_already_paired() const;
  public:
  void clear_already_paired();
  bool already_paired() const;
  void set_already_paired(bool value);
  private:
  bool _internal_already_paired() const;
  void _internal_set_already_paired(bool value);
  public:

  // optional .HU.BluetoothPairingResponse.PAIRING_STATUS status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::HU::BluetoothPairingResponse_PAIRING_STATUS status() const;
  void set_status(::HU::BluetoothPairingResponse_PAIRING_STATUS value);
  private:
  ::HU::BluetoothPairingResponse_PAIRING_STATUS _internal_status() const;
  void _internal_set_status(::HU::BluetoothPairingResponse_PAIRING_STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.BluetoothPairingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool already_paired_;
  int status_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class BluetoothAuthData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.BluetoothAuthData) */ {
 public:
  inline BluetoothAuthData() : BluetoothAuthData(nullptr) {};
  virtual ~BluetoothAuthData();

  BluetoothAuthData(const BluetoothAuthData& from);
  BluetoothAuthData(BluetoothAuthData&& from) noexcept
    : BluetoothAuthData() {
    *this = ::std::move(from);
  }

  inline BluetoothAuthData& operator=(const BluetoothAuthData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BluetoothAuthData& operator=(BluetoothAuthData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BluetoothAuthData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BluetoothAuthData* internal_default_instance() {
    return reinterpret_cast<const BluetoothAuthData*>(
               &_BluetoothAuthData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(BluetoothAuthData& a, BluetoothAuthData& b) {
    a.Swap(&b);
  }
  inline void Swap(BluetoothAuthData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BluetoothAuthData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BluetoothAuthData* New() const final {
    return CreateMaybeMessage<BluetoothAuthData>(nullptr);
  }

  BluetoothAuthData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BluetoothAuthData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BluetoothAuthData& from);
  void MergeFrom(const BluetoothAuthData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BluetoothAuthData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.BluetoothAuthData";
  }
  protected:
  explicit BluetoothAuthData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // optional string data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:HU.BluetoothAuthData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class NAVMessagesStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.NAVMessagesStatus) */ {
 public:
  inline NAVMessagesStatus() : NAVMessagesStatus(nullptr) {};
  virtual ~NAVMessagesStatus();

  NAVMessagesStatus(const NAVMessagesStatus& from);
  NAVMessagesStatus(NAVMessagesStatus&& from) noexcept
    : NAVMessagesStatus() {
    *this = ::std::move(from);
  }

  inline NAVMessagesStatus& operator=(const NAVMessagesStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NAVMessagesStatus& operator=(NAVMessagesStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NAVMessagesStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NAVMessagesStatus* internal_default_instance() {
    return reinterpret_cast<const NAVMessagesStatus*>(
               &_NAVMessagesStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(NAVMessagesStatus& a, NAVMessagesStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NAVMessagesStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NAVMessagesStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NAVMessagesStatus* New() const final {
    return CreateMaybeMessage<NAVMessagesStatus>(nullptr);
  }

  NAVMessagesStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NAVMessagesStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NAVMessagesStatus& from);
  void MergeFrom(const NAVMessagesStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NAVMessagesStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.NAVMessagesStatus";
  }
  protected:
  explicit NAVMessagesStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NAVMessagesStatus_STATUS STATUS;
  static constexpr STATUS START =
    NAVMessagesStatus_STATUS_START;
  static constexpr STATUS STOP =
    NAVMessagesStatus_STATUS_STOP;
  static inline bool STATUS_IsValid(int value) {
    return NAVMessagesStatus_STATUS_IsValid(value);
  }
  static constexpr STATUS STATUS_MIN =
    NAVMessagesStatus_STATUS_STATUS_MIN;
  static constexpr STATUS STATUS_MAX =
    NAVMessagesStatus_STATUS_STATUS_MAX;
  static constexpr int STATUS_ARRAYSIZE =
    NAVMessagesStatus_STATUS_STATUS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  STATUS_descriptor() {
    return NAVMessagesStatus_STATUS_descriptor();
  }
  template<typename T>
  static inline const std::string& STATUS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, STATUS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function STATUS_Name.");
    return NAVMessagesStatus_STATUS_Name(enum_t_value);
  }
  static inline bool STATUS_Parse(const std::string& name,
      STATUS* value) {
    return NAVMessagesStatus_STATUS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional .HU.NAVMessagesStatus.STATUS status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::HU::NAVMessagesStatus_STATUS status() const;
  void set_status(::HU::NAVMessagesStatus_STATUS value);
  private:
  ::HU::NAVMessagesStatus_STATUS _internal_status() const;
  void _internal_set_status(::HU::NAVMessagesStatus_STATUS value);
  public:

  // @@protoc_insertion_point(class_scope:HU.NAVMessagesStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class NAVTurnMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.NAVTurnMessage) */ {
 public:
  inline NAVTurnMessage() : NAVTurnMessage(nullptr) {};
  virtual ~NAVTurnMessage();

  NAVTurnMessage(const NAVTurnMessage& from);
  NAVTurnMessage(NAVTurnMessage&& from) noexcept
    : NAVTurnMessage() {
    *this = ::std::move(from);
  }

  inline NAVTurnMessage& operator=(const NAVTurnMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NAVTurnMessage& operator=(NAVTurnMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NAVTurnMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NAVTurnMessage* internal_default_instance() {
    return reinterpret_cast<const NAVTurnMessage*>(
               &_NAVTurnMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(NAVTurnMessage& a, NAVTurnMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NAVTurnMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NAVTurnMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NAVTurnMessage* New() const final {
    return CreateMaybeMessage<NAVTurnMessage>(nullptr);
  }

  NAVTurnMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NAVTurnMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NAVTurnMessage& from);
  void MergeFrom(const NAVTurnMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NAVTurnMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.NAVTurnMessage";
  }
  protected:
  explicit NAVTurnMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NAVTurnMessage_TURN_SIDE TURN_SIDE;
  static constexpr TURN_SIDE TURN_LEFT =
    NAVTurnMessage_TURN_SIDE_TURN_LEFT;
  static constexpr TURN_SIDE TURN_RIGHT =
    NAVTurnMessage_TURN_SIDE_TURN_RIGHT;
  static constexpr TURN_SIDE TURN_UNSPECIFIED =
    NAVTurnMessage_TURN_SIDE_TURN_UNSPECIFIED;
  static inline bool TURN_SIDE_IsValid(int value) {
    return NAVTurnMessage_TURN_SIDE_IsValid(value);
  }
  static constexpr TURN_SIDE TURN_SIDE_MIN =
    NAVTurnMessage_TURN_SIDE_TURN_SIDE_MIN;
  static constexpr TURN_SIDE TURN_SIDE_MAX =
    NAVTurnMessage_TURN_SIDE_TURN_SIDE_MAX;
  static constexpr int TURN_SIDE_ARRAYSIZE =
    NAVTurnMessage_TURN_SIDE_TURN_SIDE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TURN_SIDE_descriptor() {
    return NAVTurnMessage_TURN_SIDE_descriptor();
  }
  template<typename T>
  static inline const std::string& TURN_SIDE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TURN_SIDE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TURN_SIDE_Name.");
    return NAVTurnMessage_TURN_SIDE_Name(enum_t_value);
  }
  static inline bool TURN_SIDE_Parse(const std::string& name,
      TURN_SIDE* value) {
    return NAVTurnMessage_TURN_SIDE_Parse(name, value);
  }

  typedef NAVTurnMessage_TURN_EVENT TURN_EVENT;
  static constexpr TURN_EVENT TURN_UNKNOWN =
    NAVTurnMessage_TURN_EVENT_TURN_UNKNOWN;
  static constexpr TURN_EVENT TURN_DEPART =
    NAVTurnMessage_TURN_EVENT_TURN_DEPART;
  static constexpr TURN_EVENT TURN_NAME_CHANGE =
    NAVTurnMessage_TURN_EVENT_TURN_NAME_CHANGE;
  static constexpr TURN_EVENT TURN_SLIGHT_TURN =
    NAVTurnMessage_TURN_EVENT_TURN_SLIGHT_TURN;
  static constexpr TURN_EVENT TURN_TURN =
    NAVTurnMessage_TURN_EVENT_TURN_TURN;
  static constexpr TURN_EVENT TURN_SHARP_TURN =
    NAVTurnMessage_TURN_EVENT_TURN_SHARP_TURN;
  static constexpr TURN_EVENT TURN_U_TURN =
    NAVTurnMessage_TURN_EVENT_TURN_U_TURN;
  static constexpr TURN_EVENT TURN_ON_RAMP =
    NAVTurnMessage_TURN_EVENT_TURN_ON_RAMP;
  static constexpr TURN_EVENT TURN_OFF_RAMP =
    NAVTurnMessage_TURN_EVENT_TURN_OFF_RAMP;
  static constexpr TURN_EVENT TURN_FORK =
    NAVTurnMessage_TURN_EVENT_TURN_FORK;
  static constexpr TURN_EVENT TURN_MERGE =
    NAVTurnMessage_TURN_EVENT_TURN_MERGE;
  static constexpr TURN_EVENT TURN_ROUNDABOUT_ENTER =
    NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_ENTER;
  static constexpr TURN_EVENT TURN_ROUNDABOUT_EXIT =
    NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_EXIT;
  static constexpr TURN_EVENT TURN_ROUNDABOUT_ENTER_AND_EXIT =
    NAVTurnMessage_TURN_EVENT_TURN_ROUNDABOUT_ENTER_AND_EXIT;
  static constexpr TURN_EVENT TURN_STRAIGHT =
    NAVTurnMessage_TURN_EVENT_TURN_STRAIGHT;
  static constexpr TURN_EVENT TURN_FERRY_BOAT =
    NAVTurnMessage_TURN_EVENT_TURN_FERRY_BOAT;
  static constexpr TURN_EVENT TURN_FERRY_TRAIN =
    NAVTurnMessage_TURN_EVENT_TURN_FERRY_TRAIN;
  static constexpr TURN_EVENT TURN_DESTINATION =
    NAVTurnMessage_TURN_EVENT_TURN_DESTINATION;
  static inline bool TURN_EVENT_IsValid(int value) {
    return NAVTurnMessage_TURN_EVENT_IsValid(value);
  }
  static constexpr TURN_EVENT TURN_EVENT_MIN =
    NAVTurnMessage_TURN_EVENT_TURN_EVENT_MIN;
  static constexpr TURN_EVENT TURN_EVENT_MAX =
    NAVTurnMessage_TURN_EVENT_TURN_EVENT_MAX;
  static constexpr int TURN_EVENT_ARRAYSIZE =
    NAVTurnMessage_TURN_EVENT_TURN_EVENT_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TURN_EVENT_descriptor() {
    return NAVTurnMessage_TURN_EVENT_descriptor();
  }
  template<typename T>
  static inline const std::string& TURN_EVENT_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TURN_EVENT>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TURN_EVENT_Name.");
    return NAVTurnMessage_TURN_EVENT_Name(enum_t_value);
  }
  static inline bool TURN_EVENT_Parse(const std::string& name,
      TURN_EVENT* value) {
    return NAVTurnMessage_TURN_EVENT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEventNameFieldNumber = 1,
    kImageFieldNumber = 4,
    kTurnEventFieldNumber = 3,
    kTurnNumberFieldNumber = 5,
    kTurnAngleFieldNumber = 6,
    kTurnSideFieldNumber = 2,
  };
  // optional string event_name = 1;
  bool has_event_name() const;
  private:
  bool _internal_has_event_name() const;
  public:
  void clear_event_name();
  const std::string& event_name() const;
  void set_event_name(const std::string& value);
  void set_event_name(std::string&& value);
  void set_event_name(const char* value);
  void set_event_name(const char* value, size_t size);
  std::string* mutable_event_name();
  std::string* release_event_name();
  void set_allocated_event_name(std::string* event_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_event_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_event_name(
      std::string* event_name);
  private:
  const std::string& _internal_event_name() const;
  void _internal_set_event_name(const std::string& value);
  std::string* _internal_mutable_event_name();
  public:

  // optional bytes image = 4;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const std::string& image() const;
  void set_image(const std::string& value);
  void set_image(std::string&& value);
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  std::string* mutable_image();
  std::string* release_image();
  void set_allocated_image(std::string* image);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_image();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_image(
      std::string* image);
  private:
  const std::string& _internal_image() const;
  void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // optional .HU.NAVTurnMessage.TURN_EVENT turn_event = 3;
  bool has_turn_event() const;
  private:
  bool _internal_has_turn_event() const;
  public:
  void clear_turn_event();
  ::HU::NAVTurnMessage_TURN_EVENT turn_event() const;
  void set_turn_event(::HU::NAVTurnMessage_TURN_EVENT value);
  private:
  ::HU::NAVTurnMessage_TURN_EVENT _internal_turn_event() const;
  void _internal_set_turn_event(::HU::NAVTurnMessage_TURN_EVENT value);
  public:

  // optional int32 turn_number = 5;
  bool has_turn_number() const;
  private:
  bool _internal_has_turn_number() const;
  public:
  void clear_turn_number();
  ::PROTOBUF_NAMESPACE_ID::int32 turn_number() const;
  void set_turn_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_turn_number() const;
  void _internal_set_turn_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 turn_angle = 6;
  bool has_turn_angle() const;
  private:
  bool _internal_has_turn_angle() const;
  public:
  void clear_turn_angle();
  ::PROTOBUF_NAMESPACE_ID::int32 turn_angle() const;
  void set_turn_angle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_turn_angle() const;
  void _internal_set_turn_angle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .HU.NAVTurnMessage.TURN_SIDE turn_side = 2;
  bool has_turn_side() const;
  private:
  bool _internal_has_turn_side() const;
  public:
  void clear_turn_side();
  ::HU::NAVTurnMessage_TURN_SIDE turn_side() const;
  void set_turn_side(::HU::NAVTurnMessage_TURN_SIDE value);
  private:
  ::HU::NAVTurnMessage_TURN_SIDE _internal_turn_side() const;
  void _internal_set_turn_side(::HU::NAVTurnMessage_TURN_SIDE value);
  public:

  // @@protoc_insertion_point(class_scope:HU.NAVTurnMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  int turn_event_;
  ::PROTOBUF_NAMESPACE_ID::int32 turn_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 turn_angle_;
  int turn_side_;
  friend struct ::TableStruct_hu_2eproto;
};
// -------------------------------------------------------------------

class NAVDistanceMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HU.NAVDistanceMessage) */ {
 public:
  inline NAVDistanceMessage() : NAVDistanceMessage(nullptr) {};
  virtual ~NAVDistanceMessage();

  NAVDistanceMessage(const NAVDistanceMessage& from);
  NAVDistanceMessage(NAVDistanceMessage&& from) noexcept
    : NAVDistanceMessage() {
    *this = ::std::move(from);
  }

  inline NAVDistanceMessage& operator=(const NAVDistanceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline NAVDistanceMessage& operator=(NAVDistanceMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NAVDistanceMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NAVDistanceMessage* internal_default_instance() {
    return reinterpret_cast<const NAVDistanceMessage*>(
               &_NAVDistanceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(NAVDistanceMessage& a, NAVDistanceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(NAVDistanceMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NAVDistanceMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NAVDistanceMessage* New() const final {
    return CreateMaybeMessage<NAVDistanceMessage>(nullptr);
  }

  NAVDistanceMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NAVDistanceMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NAVDistanceMessage& from);
  void MergeFrom(const NAVDistanceMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NAVDistanceMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HU.NAVDistanceMessage";
  }
  protected:
  explicit NAVDistanceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_hu_2eproto);
    return ::descriptor_table_hu_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NAVDistanceMessage_DISPLAY_DISTANCE_UNIT DISPLAY_DISTANCE_UNIT;
  static constexpr DISPLAY_DISTANCE_UNIT METERS =
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_METERS;
  static constexpr DISPLAY_DISTANCE_UNIT KILOMETERS10 =
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_KILOMETERS10;
  static constexpr DISPLAY_DISTANCE_UNIT KILOMETERS =
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_KILOMETERS;
  static constexpr DISPLAY_DISTANCE_UNIT MILES10 =
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_MILES10;
  static constexpr DISPLAY_DISTANCE_UNIT MILES =
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_MILES;
  static constexpr DISPLAY_DISTANCE_UNIT FEET =
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_FEET;
  static inline bool DISPLAY_DISTANCE_UNIT_IsValid(int value) {
    return NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_IsValid(value);
  }
  static constexpr DISPLAY_DISTANCE_UNIT DISPLAY_DISTANCE_UNIT_MIN =
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_MIN;
  static constexpr DISPLAY_DISTANCE_UNIT DISPLAY_DISTANCE_UNIT_MAX =
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_MAX;
  static constexpr int DISPLAY_DISTANCE_UNIT_ARRAYSIZE =
    NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_DISPLAY_DISTANCE_UNIT_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DISPLAY_DISTANCE_UNIT_descriptor() {
    return NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor();
  }
  template<typename T>
  static inline const std::string& DISPLAY_DISTANCE_UNIT_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DISPLAY_DISTANCE_UNIT>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DISPLAY_DISTANCE_UNIT_Name.");
    return NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Name(enum_t_value);
  }
  static inline bool DISPLAY_DISTANCE_UNIT_Parse(const std::string& name,
      DISPLAY_DISTANCE_UNIT* value) {
    return NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceFieldNumber = 1,
    kTimeUntilFieldNumber = 2,
    kDisplayDistanceFieldNumber = 3,
    kDisplayDistanceUnitFieldNumber = 4,
  };
  // optional int32 distance = 1;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  ::PROTOBUF_NAMESPACE_ID::int32 distance() const;
  void set_distance(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_distance() const;
  void _internal_set_distance(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 time_until = 2;
  bool has_time_until() const;
  private:
  bool _internal_has_time_until() const;
  public:
  void clear_time_until();
  ::PROTOBUF_NAMESPACE_ID::int32 time_until() const;
  void set_time_until(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_time_until() const;
  void _internal_set_time_until(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint64 display_distance = 3;
  bool has_display_distance() const;
  private:
  bool _internal_has_display_distance() const;
  public:
  void clear_display_distance();
  ::PROTOBUF_NAMESPACE_ID::uint64 display_distance() const;
  void set_display_distance(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_display_distance() const;
  void _internal_set_display_distance(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .HU.NAVDistanceMessage.DISPLAY_DISTANCE_UNIT display_distance_unit = 4;
  bool has_display_distance_unit() const;
  private:
  bool _internal_has_display_distance_unit() const;
  public:
  void clear_display_distance_unit();
  ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT display_distance_unit() const;
  void set_display_distance_unit(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT value);
  private:
  ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT _internal_display_distance_unit() const;
  void _internal_set_display_distance_unit(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT value);
  public:

  // @@protoc_insertion_point(class_scope:HU.NAVDistanceMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 distance_;
  ::PROTOBUF_NAMESPACE_ID::int32 time_until_;
  ::PROTOBUF_NAMESPACE_ID::uint64 display_distance_;
  int display_distance_unit_;
  friend struct ::TableStruct_hu_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ButtonInfo

// required uint32 scan_code = 1;
inline bool ButtonInfo::_internal_has_scan_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ButtonInfo::has_scan_code() const {
  return _internal_has_scan_code();
}
inline void ButtonInfo::clear_scan_code() {
  scan_code_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ButtonInfo::_internal_scan_code() const {
  return scan_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ButtonInfo::scan_code() const {
  // @@protoc_insertion_point(field_get:HU.ButtonInfo.scan_code)
  return _internal_scan_code();
}
inline void ButtonInfo::_internal_set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  scan_code_ = value;
}
inline void ButtonInfo::set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_scan_code(value);
  // @@protoc_insertion_point(field_set:HU.ButtonInfo.scan_code)
}

// required bool is_pressed = 2;
inline bool ButtonInfo::_internal_has_is_pressed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ButtonInfo::has_is_pressed() const {
  return _internal_has_is_pressed();
}
inline void ButtonInfo::clear_is_pressed() {
  is_pressed_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ButtonInfo::_internal_is_pressed() const {
  return is_pressed_;
}
inline bool ButtonInfo::is_pressed() const {
  // @@protoc_insertion_point(field_get:HU.ButtonInfo.is_pressed)
  return _internal_is_pressed();
}
inline void ButtonInfo::_internal_set_is_pressed(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_pressed_ = value;
}
inline void ButtonInfo::set_is_pressed(bool value) {
  _internal_set_is_pressed(value);
  // @@protoc_insertion_point(field_set:HU.ButtonInfo.is_pressed)
}

// required uint32 meta = 3;
inline bool ButtonInfo::_internal_has_meta() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ButtonInfo::has_meta() const {
  return _internal_has_meta();
}
inline void ButtonInfo::clear_meta() {
  meta_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ButtonInfo::_internal_meta() const {
  return meta_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ButtonInfo::meta() const {
  // @@protoc_insertion_point(field_get:HU.ButtonInfo.meta)
  return _internal_meta();
}
inline void ButtonInfo::_internal_set_meta(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  meta_ = value;
}
inline void ButtonInfo::set_meta(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_meta(value);
  // @@protoc_insertion_point(field_set:HU.ButtonInfo.meta)
}

// required bool long_press = 4;
inline bool ButtonInfo::_internal_has_long_press() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ButtonInfo::has_long_press() const {
  return _internal_has_long_press();
}
inline void ButtonInfo::clear_long_press() {
  long_press_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ButtonInfo::_internal_long_press() const {
  return long_press_;
}
inline bool ButtonInfo::long_press() const {
  // @@protoc_insertion_point(field_get:HU.ButtonInfo.long_press)
  return _internal_long_press();
}
inline void ButtonInfo::_internal_set_long_press(bool value) {
  _has_bits_[0] |= 0x00000008u;
  long_press_ = value;
}
inline void ButtonInfo::set_long_press(bool value) {
  _internal_set_long_press(value);
  // @@protoc_insertion_point(field_set:HU.ButtonInfo.long_press)
}

// -------------------------------------------------------------------

// ButtonInfoWrapper

// repeated .HU.ButtonInfo button = 1;
inline int ButtonInfoWrapper::_internal_button_size() const {
  return button_.size();
}
inline int ButtonInfoWrapper::button_size() const {
  return _internal_button_size();
}
inline void ButtonInfoWrapper::clear_button() {
  button_.Clear();
}
inline ::HU::ButtonInfo* ButtonInfoWrapper::mutable_button(int index) {
  // @@protoc_insertion_point(field_mutable:HU.ButtonInfoWrapper.button)
  return button_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ButtonInfo >*
ButtonInfoWrapper::mutable_button() {
  // @@protoc_insertion_point(field_mutable_list:HU.ButtonInfoWrapper.button)
  return &button_;
}
inline const ::HU::ButtonInfo& ButtonInfoWrapper::_internal_button(int index) const {
  return button_.Get(index);
}
inline const ::HU::ButtonInfo& ButtonInfoWrapper::button(int index) const {
  // @@protoc_insertion_point(field_get:HU.ButtonInfoWrapper.button)
  return _internal_button(index);
}
inline ::HU::ButtonInfo* ButtonInfoWrapper::_internal_add_button() {
  return button_.Add();
}
inline ::HU::ButtonInfo* ButtonInfoWrapper::add_button() {
  // @@protoc_insertion_point(field_add:HU.ButtonInfoWrapper.button)
  return _internal_add_button();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ButtonInfo >&
ButtonInfoWrapper::button() const {
  // @@protoc_insertion_point(field_list:HU.ButtonInfoWrapper.button)
  return button_;
}

// -------------------------------------------------------------------

// TouchInfo_Location

// required uint32 x = 1;
inline bool TouchInfo_Location::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TouchInfo_Location::has_x() const {
  return _internal_has_x();
}
inline void TouchInfo_Location::clear_x() {
  x_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TouchInfo_Location::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TouchInfo_Location::x() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.Location.x)
  return _internal_x();
}
inline void TouchInfo_Location::_internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void TouchInfo_Location::set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.Location.x)
}

// required uint32 y = 2;
inline bool TouchInfo_Location::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TouchInfo_Location::has_y() const {
  return _internal_has_y();
}
inline void TouchInfo_Location::clear_y() {
  y_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TouchInfo_Location::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TouchInfo_Location::y() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.Location.y)
  return _internal_y();
}
inline void TouchInfo_Location::_internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void TouchInfo_Location::set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.Location.y)
}

// required uint32 pointer_id = 3;
inline bool TouchInfo_Location::_internal_has_pointer_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TouchInfo_Location::has_pointer_id() const {
  return _internal_has_pointer_id();
}
inline void TouchInfo_Location::clear_pointer_id() {
  pointer_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TouchInfo_Location::_internal_pointer_id() const {
  return pointer_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TouchInfo_Location::pointer_id() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.Location.pointer_id)
  return _internal_pointer_id();
}
inline void TouchInfo_Location::_internal_set_pointer_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  pointer_id_ = value;
}
inline void TouchInfo_Location::set_pointer_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_pointer_id(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.Location.pointer_id)
}

// -------------------------------------------------------------------

// TouchInfo

// repeated .HU.TouchInfo.Location location = 1;
inline int TouchInfo::_internal_location_size() const {
  return location_.size();
}
inline int TouchInfo::location_size() const {
  return _internal_location_size();
}
inline void TouchInfo::clear_location() {
  location_.Clear();
}
inline ::HU::TouchInfo_Location* TouchInfo::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:HU.TouchInfo.location)
  return location_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::TouchInfo_Location >*
TouchInfo::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:HU.TouchInfo.location)
  return &location_;
}
inline const ::HU::TouchInfo_Location& TouchInfo::_internal_location(int index) const {
  return location_.Get(index);
}
inline const ::HU::TouchInfo_Location& TouchInfo::location(int index) const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.location)
  return _internal_location(index);
}
inline ::HU::TouchInfo_Location* TouchInfo::_internal_add_location() {
  return location_.Add();
}
inline ::HU::TouchInfo_Location* TouchInfo::add_location() {
  // @@protoc_insertion_point(field_add:HU.TouchInfo.location)
  return _internal_add_location();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::TouchInfo_Location >&
TouchInfo::location() const {
  // @@protoc_insertion_point(field_list:HU.TouchInfo.location)
  return location_;
}

// optional uint32 action_index = 2;
inline bool TouchInfo::_internal_has_action_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TouchInfo::has_action_index() const {
  return _internal_has_action_index();
}
inline void TouchInfo::clear_action_index() {
  action_index_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TouchInfo::_internal_action_index() const {
  return action_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TouchInfo::action_index() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.action_index)
  return _internal_action_index();
}
inline void TouchInfo::_internal_set_action_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  action_index_ = value;
}
inline void TouchInfo::set_action_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_action_index(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.action_index)
}

// required .HU.TouchInfo.TOUCH_ACTION action = 3;
inline bool TouchInfo::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TouchInfo::has_action() const {
  return _internal_has_action();
}
inline void TouchInfo::clear_action() {
  action_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::HU::TouchInfo_TOUCH_ACTION TouchInfo::_internal_action() const {
  return static_cast< ::HU::TouchInfo_TOUCH_ACTION >(action_);
}
inline ::HU::TouchInfo_TOUCH_ACTION TouchInfo::action() const {
  // @@protoc_insertion_point(field_get:HU.TouchInfo.action)
  return _internal_action();
}
inline void TouchInfo::_internal_set_action(::HU::TouchInfo_TOUCH_ACTION value) {
  assert(::HU::TouchInfo_TOUCH_ACTION_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  action_ = value;
}
inline void TouchInfo::set_action(::HU::TouchInfo_TOUCH_ACTION value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:HU.TouchInfo.action)
}

// -------------------------------------------------------------------

// RelativeInputEvent

// optional uint32 scan_code = 1;
inline bool RelativeInputEvent::_internal_has_scan_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RelativeInputEvent::has_scan_code() const {
  return _internal_has_scan_code();
}
inline void RelativeInputEvent::clear_scan_code() {
  scan_code_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RelativeInputEvent::_internal_scan_code() const {
  return scan_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RelativeInputEvent::scan_code() const {
  // @@protoc_insertion_point(field_get:HU.RelativeInputEvent.scan_code)
  return _internal_scan_code();
}
inline void RelativeInputEvent::_internal_set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  scan_code_ = value;
}
inline void RelativeInputEvent::set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_scan_code(value);
  // @@protoc_insertion_point(field_set:HU.RelativeInputEvent.scan_code)
}

// optional int32 delta = 2;
inline bool RelativeInputEvent::_internal_has_delta() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RelativeInputEvent::has_delta() const {
  return _internal_has_delta();
}
inline void RelativeInputEvent::clear_delta() {
  delta_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelativeInputEvent::_internal_delta() const {
  return delta_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RelativeInputEvent::delta() const {
  // @@protoc_insertion_point(field_get:HU.RelativeInputEvent.delta)
  return _internal_delta();
}
inline void RelativeInputEvent::_internal_set_delta(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  delta_ = value;
}
inline void RelativeInputEvent::set_delta(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_delta(value);
  // @@protoc_insertion_point(field_set:HU.RelativeInputEvent.delta)
}

// -------------------------------------------------------------------

// AbsoluteInputEvent

// optional uint32 scan_code = 1;
inline bool AbsoluteInputEvent::_internal_has_scan_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AbsoluteInputEvent::has_scan_code() const {
  return _internal_has_scan_code();
}
inline void AbsoluteInputEvent::clear_scan_code() {
  scan_code_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbsoluteInputEvent::_internal_scan_code() const {
  return scan_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbsoluteInputEvent::scan_code() const {
  // @@protoc_insertion_point(field_get:HU.AbsoluteInputEvent.scan_code)
  return _internal_scan_code();
}
inline void AbsoluteInputEvent::_internal_set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  scan_code_ = value;
}
inline void AbsoluteInputEvent::set_scan_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_scan_code(value);
  // @@protoc_insertion_point(field_set:HU.AbsoluteInputEvent.scan_code)
}

// optional int32 value = 2;
inline bool AbsoluteInputEvent::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AbsoluteInputEvent::has_value() const {
  return _internal_has_value();
}
inline void AbsoluteInputEvent::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AbsoluteInputEvent::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AbsoluteInputEvent::value() const {
  // @@protoc_insertion_point(field_get:HU.AbsoluteInputEvent.value)
  return _internal_value();
}
inline void AbsoluteInputEvent::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void AbsoluteInputEvent::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:HU.AbsoluteInputEvent.value)
}

// -------------------------------------------------------------------

// AbsoluteInputEventWrapper

// required .HU.AbsoluteInputEvent event = 1;
inline bool AbsoluteInputEventWrapper::_internal_has_event() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || event_ != nullptr);
  return value;
}
inline bool AbsoluteInputEventWrapper::has_event() const {
  return _internal_has_event();
}
inline void AbsoluteInputEventWrapper::clear_event() {
  if (event_ != nullptr) event_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::AbsoluteInputEvent& AbsoluteInputEventWrapper::_internal_event() const {
  const ::HU::AbsoluteInputEvent* p = event_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::AbsoluteInputEvent*>(
      &::HU::_AbsoluteInputEvent_default_instance_);
}
inline const ::HU::AbsoluteInputEvent& AbsoluteInputEventWrapper::event() const {
  // @@protoc_insertion_point(field_get:HU.AbsoluteInputEventWrapper.event)
  return _internal_event();
}
inline void AbsoluteInputEventWrapper::unsafe_arena_set_allocated_event(
    ::HU::AbsoluteInputEvent* event) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.AbsoluteInputEventWrapper.event)
}
inline ::HU::AbsoluteInputEvent* AbsoluteInputEventWrapper::release_event() {
  auto temp = unsafe_arena_release_event();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::AbsoluteInputEvent* AbsoluteInputEventWrapper::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:HU.AbsoluteInputEventWrapper.event)
  _has_bits_[0] &= ~0x00000001u;
  ::HU::AbsoluteInputEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::HU::AbsoluteInputEvent* AbsoluteInputEventWrapper::_internal_mutable_event() {
  _has_bits_[0] |= 0x00000001u;
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::AbsoluteInputEvent>(GetArena());
    event_ = p;
  }
  return event_;
}
inline ::HU::AbsoluteInputEvent* AbsoluteInputEventWrapper::mutable_event() {
  // @@protoc_insertion_point(field_mutable:HU.AbsoluteInputEventWrapper.event)
  return _internal_mutable_event();
}
inline void AbsoluteInputEventWrapper::set_allocated_event(::HU::AbsoluteInputEvent* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:HU.AbsoluteInputEventWrapper.event)
}

// -------------------------------------------------------------------

// RelativeInputEventWrapper

// required .HU.RelativeInputEvent event = 1;
inline bool RelativeInputEventWrapper::_internal_has_event() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || event_ != nullptr);
  return value;
}
inline bool RelativeInputEventWrapper::has_event() const {
  return _internal_has_event();
}
inline void RelativeInputEventWrapper::clear_event() {
  if (event_ != nullptr) event_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::RelativeInputEvent& RelativeInputEventWrapper::_internal_event() const {
  const ::HU::RelativeInputEvent* p = event_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::RelativeInputEvent*>(
      &::HU::_RelativeInputEvent_default_instance_);
}
inline const ::HU::RelativeInputEvent& RelativeInputEventWrapper::event() const {
  // @@protoc_insertion_point(field_get:HU.RelativeInputEventWrapper.event)
  return _internal_event();
}
inline void RelativeInputEventWrapper::unsafe_arena_set_allocated_event(
    ::HU::RelativeInputEvent* event) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.RelativeInputEventWrapper.event)
}
inline ::HU::RelativeInputEvent* RelativeInputEventWrapper::release_event() {
  auto temp = unsafe_arena_release_event();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::RelativeInputEvent* RelativeInputEventWrapper::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:HU.RelativeInputEventWrapper.event)
  _has_bits_[0] &= ~0x00000001u;
  ::HU::RelativeInputEvent* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::HU::RelativeInputEvent* RelativeInputEventWrapper::_internal_mutable_event() {
  _has_bits_[0] |= 0x00000001u;
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::RelativeInputEvent>(GetArena());
    event_ = p;
  }
  return event_;
}
inline ::HU::RelativeInputEvent* RelativeInputEventWrapper::mutable_event() {
  // @@protoc_insertion_point(field_mutable:HU.RelativeInputEventWrapper.event)
  return _internal_mutable_event();
}
inline void RelativeInputEventWrapper::set_allocated_event(::HU::RelativeInputEvent* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:HU.RelativeInputEventWrapper.event)
}

// -------------------------------------------------------------------

// InputEvent

// required uint64 timestamp = 1;
inline bool InputEvent::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InputEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void InputEvent::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InputEvent::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InputEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:HU.InputEvent.timestamp)
  return _internal_timestamp();
}
inline void InputEvent::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  timestamp_ = value;
}
inline void InputEvent::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:HU.InputEvent.timestamp)
}

// optional int32 disp_channel = 2;
inline bool InputEvent::_internal_has_disp_channel() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InputEvent::has_disp_channel() const {
  return _internal_has_disp_channel();
}
inline void InputEvent::clear_disp_channel() {
  disp_channel_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InputEvent::_internal_disp_channel() const {
  return disp_channel_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InputEvent::disp_channel() const {
  // @@protoc_insertion_point(field_get:HU.InputEvent.disp_channel)
  return _internal_disp_channel();
}
inline void InputEvent::_internal_set_disp_channel(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  disp_channel_ = value;
}
inline void InputEvent::set_disp_channel(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_disp_channel(value);
  // @@protoc_insertion_point(field_set:HU.InputEvent.disp_channel)
}

// optional .HU.TouchInfo touch = 3;
inline bool InputEvent::_internal_has_touch() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || touch_ != nullptr);
  return value;
}
inline bool InputEvent::has_touch() const {
  return _internal_has_touch();
}
inline void InputEvent::clear_touch() {
  if (touch_ != nullptr) touch_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::TouchInfo& InputEvent::_internal_touch() const {
  const ::HU::TouchInfo* p = touch_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::TouchInfo*>(
      &::HU::_TouchInfo_default_instance_);
}
inline const ::HU::TouchInfo& InputEvent::touch() const {
  // @@protoc_insertion_point(field_get:HU.InputEvent.touch)
  return _internal_touch();
}
inline void InputEvent::unsafe_arena_set_allocated_touch(
    ::HU::TouchInfo* touch) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(touch_);
  }
  touch_ = touch;
  if (touch) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.InputEvent.touch)
}
inline ::HU::TouchInfo* InputEvent::release_touch() {
  auto temp = unsafe_arena_release_touch();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::TouchInfo* InputEvent::unsafe_arena_release_touch() {
  // @@protoc_insertion_point(field_release:HU.InputEvent.touch)
  _has_bits_[0] &= ~0x00000001u;
  ::HU::TouchInfo* temp = touch_;
  touch_ = nullptr;
  return temp;
}
inline ::HU::TouchInfo* InputEvent::_internal_mutable_touch() {
  _has_bits_[0] |= 0x00000001u;
  if (touch_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::TouchInfo>(GetArena());
    touch_ = p;
  }
  return touch_;
}
inline ::HU::TouchInfo* InputEvent::mutable_touch() {
  // @@protoc_insertion_point(field_mutable:HU.InputEvent.touch)
  return _internal_mutable_touch();
}
inline void InputEvent::set_allocated_touch(::HU::TouchInfo* touch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete touch_;
  }
  if (touch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(touch);
    if (message_arena != submessage_arena) {
      touch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, touch, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  touch_ = touch;
  // @@protoc_insertion_point(field_set_allocated:HU.InputEvent.touch)
}

// optional .HU.ButtonInfoWrapper button = 4;
inline bool InputEvent::_internal_has_button() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || button_ != nullptr);
  return value;
}
inline bool InputEvent::has_button() const {
  return _internal_has_button();
}
inline void InputEvent::clear_button() {
  if (button_ != nullptr) button_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::HU::ButtonInfoWrapper& InputEvent::_internal_button() const {
  const ::HU::ButtonInfoWrapper* p = button_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ButtonInfoWrapper*>(
      &::HU::_ButtonInfoWrapper_default_instance_);
}
inline const ::HU::ButtonInfoWrapper& InputEvent::button() const {
  // @@protoc_insertion_point(field_get:HU.InputEvent.button)
  return _internal_button();
}
inline void InputEvent::unsafe_arena_set_allocated_button(
    ::HU::ButtonInfoWrapper* button) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(button_);
  }
  button_ = button;
  if (button) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.InputEvent.button)
}
inline ::HU::ButtonInfoWrapper* InputEvent::release_button() {
  auto temp = unsafe_arena_release_button();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ButtonInfoWrapper* InputEvent::unsafe_arena_release_button() {
  // @@protoc_insertion_point(field_release:HU.InputEvent.button)
  _has_bits_[0] &= ~0x00000002u;
  ::HU::ButtonInfoWrapper* temp = button_;
  button_ = nullptr;
  return temp;
}
inline ::HU::ButtonInfoWrapper* InputEvent::_internal_mutable_button() {
  _has_bits_[0] |= 0x00000002u;
  if (button_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ButtonInfoWrapper>(GetArena());
    button_ = p;
  }
  return button_;
}
inline ::HU::ButtonInfoWrapper* InputEvent::mutable_button() {
  // @@protoc_insertion_point(field_mutable:HU.InputEvent.button)
  return _internal_mutable_button();
}
inline void InputEvent::set_allocated_button(::HU::ButtonInfoWrapper* button) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete button_;
  }
  if (button) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(button);
    if (message_arena != submessage_arena) {
      button = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, button, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  button_ = button;
  // @@protoc_insertion_point(field_set_allocated:HU.InputEvent.button)
}

// optional .HU.AbsoluteInputEventWrapper abs_event = 5;
inline bool InputEvent::_internal_has_abs_event() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || abs_event_ != nullptr);
  return value;
}
inline bool InputEvent::has_abs_event() const {
  return _internal_has_abs_event();
}
inline void InputEvent::clear_abs_event() {
  if (abs_event_ != nullptr) abs_event_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::HU::AbsoluteInputEventWrapper& InputEvent::_internal_abs_event() const {
  const ::HU::AbsoluteInputEventWrapper* p = abs_event_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::AbsoluteInputEventWrapper*>(
      &::HU::_AbsoluteInputEventWrapper_default_instance_);
}
inline const ::HU::AbsoluteInputEventWrapper& InputEvent::abs_event() const {
  // @@protoc_insertion_point(field_get:HU.InputEvent.abs_event)
  return _internal_abs_event();
}
inline void InputEvent::unsafe_arena_set_allocated_abs_event(
    ::HU::AbsoluteInputEventWrapper* abs_event) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(abs_event_);
  }
  abs_event_ = abs_event;
  if (abs_event) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.InputEvent.abs_event)
}
inline ::HU::AbsoluteInputEventWrapper* InputEvent::release_abs_event() {
  auto temp = unsafe_arena_release_abs_event();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::AbsoluteInputEventWrapper* InputEvent::unsafe_arena_release_abs_event() {
  // @@protoc_insertion_point(field_release:HU.InputEvent.abs_event)
  _has_bits_[0] &= ~0x00000004u;
  ::HU::AbsoluteInputEventWrapper* temp = abs_event_;
  abs_event_ = nullptr;
  return temp;
}
inline ::HU::AbsoluteInputEventWrapper* InputEvent::_internal_mutable_abs_event() {
  _has_bits_[0] |= 0x00000004u;
  if (abs_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::AbsoluteInputEventWrapper>(GetArena());
    abs_event_ = p;
  }
  return abs_event_;
}
inline ::HU::AbsoluteInputEventWrapper* InputEvent::mutable_abs_event() {
  // @@protoc_insertion_point(field_mutable:HU.InputEvent.abs_event)
  return _internal_mutable_abs_event();
}
inline void InputEvent::set_allocated_abs_event(::HU::AbsoluteInputEventWrapper* abs_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete abs_event_;
  }
  if (abs_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(abs_event);
    if (message_arena != submessage_arena) {
      abs_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abs_event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  abs_event_ = abs_event;
  // @@protoc_insertion_point(field_set_allocated:HU.InputEvent.abs_event)
}

// optional .HU.RelativeInputEventWrapper rel_event = 6;
inline bool InputEvent::_internal_has_rel_event() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || rel_event_ != nullptr);
  return value;
}
inline bool InputEvent::has_rel_event() const {
  return _internal_has_rel_event();
}
inline void InputEvent::clear_rel_event() {
  if (rel_event_ != nullptr) rel_event_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::HU::RelativeInputEventWrapper& InputEvent::_internal_rel_event() const {
  const ::HU::RelativeInputEventWrapper* p = rel_event_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::RelativeInputEventWrapper*>(
      &::HU::_RelativeInputEventWrapper_default_instance_);
}
inline const ::HU::RelativeInputEventWrapper& InputEvent::rel_event() const {
  // @@protoc_insertion_point(field_get:HU.InputEvent.rel_event)
  return _internal_rel_event();
}
inline void InputEvent::unsafe_arena_set_allocated_rel_event(
    ::HU::RelativeInputEventWrapper* rel_event) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rel_event_);
  }
  rel_event_ = rel_event;
  if (rel_event) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.InputEvent.rel_event)
}
inline ::HU::RelativeInputEventWrapper* InputEvent::release_rel_event() {
  auto temp = unsafe_arena_release_rel_event();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::RelativeInputEventWrapper* InputEvent::unsafe_arena_release_rel_event() {
  // @@protoc_insertion_point(field_release:HU.InputEvent.rel_event)
  _has_bits_[0] &= ~0x00000008u;
  ::HU::RelativeInputEventWrapper* temp = rel_event_;
  rel_event_ = nullptr;
  return temp;
}
inline ::HU::RelativeInputEventWrapper* InputEvent::_internal_mutable_rel_event() {
  _has_bits_[0] |= 0x00000008u;
  if (rel_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::RelativeInputEventWrapper>(GetArena());
    rel_event_ = p;
  }
  return rel_event_;
}
inline ::HU::RelativeInputEventWrapper* InputEvent::mutable_rel_event() {
  // @@protoc_insertion_point(field_mutable:HU.InputEvent.rel_event)
  return _internal_mutable_rel_event();
}
inline void InputEvent::set_allocated_rel_event(::HU::RelativeInputEventWrapper* rel_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rel_event_;
  }
  if (rel_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rel_event);
    if (message_arena != submessage_arena) {
      rel_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rel_event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  rel_event_ = rel_event;
  // @@protoc_insertion_point(field_set_allocated:HU.InputEvent.rel_event)
}

// -------------------------------------------------------------------

// BindingRequest

// repeated int32 scan_codes = 1;
inline int BindingRequest::_internal_scan_codes_size() const {
  return scan_codes_.size();
}
inline int BindingRequest::scan_codes_size() const {
  return _internal_scan_codes_size();
}
inline void BindingRequest::clear_scan_codes() {
  scan_codes_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BindingRequest::_internal_scan_codes(int index) const {
  return scan_codes_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BindingRequest::scan_codes(int index) const {
  // @@protoc_insertion_point(field_get:HU.BindingRequest.scan_codes)
  return _internal_scan_codes(index);
}
inline void BindingRequest::set_scan_codes(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  scan_codes_.Set(index, value);
  // @@protoc_insertion_point(field_set:HU.BindingRequest.scan_codes)
}
inline void BindingRequest::_internal_add_scan_codes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  scan_codes_.Add(value);
}
inline void BindingRequest::add_scan_codes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_scan_codes(value);
  // @@protoc_insertion_point(field_add:HU.BindingRequest.scan_codes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
BindingRequest::_internal_scan_codes() const {
  return scan_codes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
BindingRequest::scan_codes() const {
  // @@protoc_insertion_point(field_list:HU.BindingRequest.scan_codes)
  return _internal_scan_codes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
BindingRequest::_internal_mutable_scan_codes() {
  return &scan_codes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
BindingRequest::mutable_scan_codes() {
  // @@protoc_insertion_point(field_mutable_list:HU.BindingRequest.scan_codes)
  return _internal_mutable_scan_codes();
}

// -------------------------------------------------------------------

// BindingResponse

// required .HU.STATUS status = 1;
inline bool BindingResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BindingResponse::has_status() const {
  return _internal_has_status();
}
inline void BindingResponse::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::STATUS BindingResponse::_internal_status() const {
  return static_cast< ::HU::STATUS >(status_);
}
inline ::HU::STATUS BindingResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.BindingResponse.status)
  return _internal_status();
}
inline void BindingResponse::_internal_set_status(::HU::STATUS value) {
  assert(::HU::STATUS_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void BindingResponse::set_status(::HU::STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.BindingResponse.status)
}

// -------------------------------------------------------------------

// SensorEvent_LocationData

// optional uint64 timestamp = 1;
inline bool SensorEvent_LocationData::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_LocationData::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void SensorEvent_LocationData::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SensorEvent_LocationData::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SensorEvent_LocationData::timestamp() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.timestamp)
  return _internal_timestamp();
}
inline void SensorEvent_LocationData::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
}
inline void SensorEvent_LocationData::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.timestamp)
}

// optional int32 latitude = 2;
inline bool SensorEvent_LocationData::_internal_has_latitude() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_LocationData::has_latitude() const {
  return _internal_has_latitude();
}
inline void SensorEvent_LocationData::clear_latitude() {
  latitude_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::_internal_latitude() const {
  return latitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::latitude() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.latitude)
  return _internal_latitude();
}
inline void SensorEvent_LocationData::_internal_set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  latitude_ = value;
}
inline void SensorEvent_LocationData::set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.latitude)
}

// optional int32 longitude = 3;
inline bool SensorEvent_LocationData::_internal_has_longitude() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorEvent_LocationData::has_longitude() const {
  return _internal_has_longitude();
}
inline void SensorEvent_LocationData::clear_longitude() {
  longitude_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::_internal_longitude() const {
  return longitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::longitude() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.longitude)
  return _internal_longitude();
}
inline void SensorEvent_LocationData::_internal_set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  longitude_ = value;
}
inline void SensorEvent_LocationData::set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.longitude)
}

// optional uint32 accuracy = 4;
inline bool SensorEvent_LocationData::_internal_has_accuracy() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SensorEvent_LocationData::has_accuracy() const {
  return _internal_has_accuracy();
}
inline void SensorEvent_LocationData::clear_accuracy() {
  accuracy_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorEvent_LocationData::_internal_accuracy() const {
  return accuracy_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorEvent_LocationData::accuracy() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.accuracy)
  return _internal_accuracy();
}
inline void SensorEvent_LocationData::_internal_set_accuracy(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  accuracy_ = value;
}
inline void SensorEvent_LocationData::set_accuracy(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_accuracy(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.accuracy)
}

// optional int32 altitude = 5;
inline bool SensorEvent_LocationData::_internal_has_altitude() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SensorEvent_LocationData::has_altitude() const {
  return _internal_has_altitude();
}
inline void SensorEvent_LocationData::clear_altitude() {
  altitude_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::_internal_altitude() const {
  return altitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::altitude() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.altitude)
  return _internal_altitude();
}
inline void SensorEvent_LocationData::_internal_set_altitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  altitude_ = value;
}
inline void SensorEvent_LocationData::set_altitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.altitude)
}

// optional int32 speed = 6;
inline bool SensorEvent_LocationData::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SensorEvent_LocationData::has_speed() const {
  return _internal_has_speed();
}
inline void SensorEvent_LocationData::clear_speed() {
  speed_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::_internal_speed() const {
  return speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::speed() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.speed)
  return _internal_speed();
}
inline void SensorEvent_LocationData::_internal_set_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  speed_ = value;
}
inline void SensorEvent_LocationData::set_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.speed)
}

// optional int32 bearing = 7;
inline bool SensorEvent_LocationData::_internal_has_bearing() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SensorEvent_LocationData::has_bearing() const {
  return _internal_has_bearing();
}
inline void SensorEvent_LocationData::clear_bearing() {
  bearing_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::_internal_bearing() const {
  return bearing_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_LocationData::bearing() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.LocationData.bearing)
  return _internal_bearing();
}
inline void SensorEvent_LocationData::_internal_set_bearing(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  bearing_ = value;
}
inline void SensorEvent_LocationData::set_bearing(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bearing(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.LocationData.bearing)
}

// -------------------------------------------------------------------

// SensorEvent_NightMode

// required bool is_night = 1;
inline bool SensorEvent_NightMode::_internal_has_is_night() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_NightMode::has_is_night() const {
  return _internal_has_is_night();
}
inline void SensorEvent_NightMode::clear_is_night() {
  is_night_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SensorEvent_NightMode::_internal_is_night() const {
  return is_night_;
}
inline bool SensorEvent_NightMode::is_night() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.NightMode.is_night)
  return _internal_is_night();
}
inline void SensorEvent_NightMode::_internal_set_is_night(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_night_ = value;
}
inline void SensorEvent_NightMode::set_is_night(bool value) {
  _internal_set_is_night(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.NightMode.is_night)
}

// -------------------------------------------------------------------

// SensorEvent_RPM

// required int32 rpm = 1;
inline bool SensorEvent_RPM::_internal_has_rpm() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_RPM::has_rpm() const {
  return _internal_has_rpm();
}
inline void SensorEvent_RPM::clear_rpm() {
  rpm_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_RPM::_internal_rpm() const {
  return rpm_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_RPM::rpm() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.RPM.rpm)
  return _internal_rpm();
}
inline void SensorEvent_RPM::_internal_set_rpm(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  rpm_ = value;
}
inline void SensorEvent_RPM::set_rpm(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rpm(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.RPM.rpm)
}

// -------------------------------------------------------------------

// SensorEvent_FuelLevel

// required int32 fuel_level = 1;
inline bool SensorEvent_FuelLevel::_internal_has_fuel_level() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_FuelLevel::has_fuel_level() const {
  return _internal_has_fuel_level();
}
inline void SensorEvent_FuelLevel::clear_fuel_level() {
  fuel_level_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_FuelLevel::_internal_fuel_level() const {
  return fuel_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_FuelLevel::fuel_level() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.FuelLevel.fuel_level)
  return _internal_fuel_level();
}
inline void SensorEvent_FuelLevel::_internal_set_fuel_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  fuel_level_ = value;
}
inline void SensorEvent_FuelLevel::set_fuel_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fuel_level(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.FuelLevel.fuel_level)
}

// optional int32 range = 2;
inline bool SensorEvent_FuelLevel::_internal_has_range() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_FuelLevel::has_range() const {
  return _internal_has_range();
}
inline void SensorEvent_FuelLevel::clear_range() {
  range_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_FuelLevel::_internal_range() const {
  return range_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_FuelLevel::range() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.FuelLevel.range)
  return _internal_range();
}
inline void SensorEvent_FuelLevel::_internal_set_range(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  range_ = value;
}
inline void SensorEvent_FuelLevel::set_range(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_range(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.FuelLevel.range)
}

// optional bool low_fuel = 3;
inline bool SensorEvent_FuelLevel::_internal_has_low_fuel() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorEvent_FuelLevel::has_low_fuel() const {
  return _internal_has_low_fuel();
}
inline void SensorEvent_FuelLevel::clear_low_fuel() {
  low_fuel_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SensorEvent_FuelLevel::_internal_low_fuel() const {
  return low_fuel_;
}
inline bool SensorEvent_FuelLevel::low_fuel() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.FuelLevel.low_fuel)
  return _internal_low_fuel();
}
inline void SensorEvent_FuelLevel::_internal_set_low_fuel(bool value) {
  _has_bits_[0] |= 0x00000004u;
  low_fuel_ = value;
}
inline void SensorEvent_FuelLevel::set_low_fuel(bool value) {
  _internal_set_low_fuel(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.FuelLevel.low_fuel)
}

// -------------------------------------------------------------------

// SensorEvent_DrivingStatus

// required int32 status = 1;
inline bool SensorEvent_DrivingStatus::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_DrivingStatus::has_status() const {
  return _internal_has_status();
}
inline void SensorEvent_DrivingStatus::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_DrivingStatus::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_DrivingStatus::status() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.DrivingStatus.status)
  return _internal_status();
}
inline void SensorEvent_DrivingStatus::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void SensorEvent_DrivingStatus::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.DrivingStatus.status)
}

// -------------------------------------------------------------------

// SensorEvent_DeadReckoning

// optional int32 steering_angel = 1;
inline bool SensorEvent_DeadReckoning::_internal_has_steering_angel() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_DeadReckoning::has_steering_angel() const {
  return _internal_has_steering_angel();
}
inline void SensorEvent_DeadReckoning::clear_steering_angel() {
  steering_angel_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_DeadReckoning::_internal_steering_angel() const {
  return steering_angel_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_DeadReckoning::steering_angel() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.DeadReckoning.steering_angel)
  return _internal_steering_angel();
}
inline void SensorEvent_DeadReckoning::_internal_set_steering_angel(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  steering_angel_ = value;
}
inline void SensorEvent_DeadReckoning::set_steering_angel(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_steering_angel(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.DeadReckoning.steering_angel)
}

// optional int32 wheel_speed = 2;
inline bool SensorEvent_DeadReckoning::_internal_has_wheel_speed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_DeadReckoning::has_wheel_speed() const {
  return _internal_has_wheel_speed();
}
inline void SensorEvent_DeadReckoning::clear_wheel_speed() {
  wheel_speed_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_DeadReckoning::_internal_wheel_speed() const {
  return wheel_speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_DeadReckoning::wheel_speed() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.DeadReckoning.wheel_speed)
  return _internal_wheel_speed();
}
inline void SensorEvent_DeadReckoning::_internal_set_wheel_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  wheel_speed_ = value;
}
inline void SensorEvent_DeadReckoning::set_wheel_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_wheel_speed(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.DeadReckoning.wheel_speed)
}

// -------------------------------------------------------------------

// SensorEvent_CompassData

// optional int32 bearing_e6 = 1;
inline bool SensorEvent_CompassData::_internal_has_bearing_e6() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_CompassData::has_bearing_e6() const {
  return _internal_has_bearing_e6();
}
inline void SensorEvent_CompassData::clear_bearing_e6() {
  bearing_e6_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_CompassData::_internal_bearing_e6() const {
  return bearing_e6_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_CompassData::bearing_e6() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.CompassData.bearing_e6)
  return _internal_bearing_e6();
}
inline void SensorEvent_CompassData::_internal_set_bearing_e6(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  bearing_e6_ = value;
}
inline void SensorEvent_CompassData::set_bearing_e6(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bearing_e6(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.CompassData.bearing_e6)
}

// optional int32 pitch_e6 = 2;
inline bool SensorEvent_CompassData::_internal_has_pitch_e6() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_CompassData::has_pitch_e6() const {
  return _internal_has_pitch_e6();
}
inline void SensorEvent_CompassData::clear_pitch_e6() {
  pitch_e6_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_CompassData::_internal_pitch_e6() const {
  return pitch_e6_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_CompassData::pitch_e6() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.CompassData.pitch_e6)
  return _internal_pitch_e6();
}
inline void SensorEvent_CompassData::_internal_set_pitch_e6(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pitch_e6_ = value;
}
inline void SensorEvent_CompassData::set_pitch_e6(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pitch_e6(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.CompassData.pitch_e6)
}

// optional int32 roll_e6 = 3;
inline bool SensorEvent_CompassData::_internal_has_roll_e6() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorEvent_CompassData::has_roll_e6() const {
  return _internal_has_roll_e6();
}
inline void SensorEvent_CompassData::clear_roll_e6() {
  roll_e6_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_CompassData::_internal_roll_e6() const {
  return roll_e6_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_CompassData::roll_e6() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.CompassData.roll_e6)
  return _internal_roll_e6();
}
inline void SensorEvent_CompassData::_internal_set_roll_e6(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  roll_e6_ = value;
}
inline void SensorEvent_CompassData::set_roll_e6(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_roll_e6(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.CompassData.roll_e6)
}

// -------------------------------------------------------------------

// SensorEvent_SpeedData

// optional int32 speed_e6 = 1;
inline bool SensorEvent_SpeedData::_internal_has_speed_e6() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_SpeedData::has_speed_e6() const {
  return _internal_has_speed_e6();
}
inline void SensorEvent_SpeedData::clear_speed_e6() {
  speed_e6_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_SpeedData::_internal_speed_e6() const {
  return speed_e6_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_SpeedData::speed_e6() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.SpeedData.speed_e6)
  return _internal_speed_e6();
}
inline void SensorEvent_SpeedData::_internal_set_speed_e6(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  speed_e6_ = value;
}
inline void SensorEvent_SpeedData::set_speed_e6(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_speed_e6(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.SpeedData.speed_e6)
}

// optional bool cruise_engaged = 2;
inline bool SensorEvent_SpeedData::_internal_has_cruise_engaged() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_SpeedData::has_cruise_engaged() const {
  return _internal_has_cruise_engaged();
}
inline void SensorEvent_SpeedData::clear_cruise_engaged() {
  cruise_engaged_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SensorEvent_SpeedData::_internal_cruise_engaged() const {
  return cruise_engaged_;
}
inline bool SensorEvent_SpeedData::cruise_engaged() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.SpeedData.cruise_engaged)
  return _internal_cruise_engaged();
}
inline void SensorEvent_SpeedData::_internal_set_cruise_engaged(bool value) {
  _has_bits_[0] |= 0x00000002u;
  cruise_engaged_ = value;
}
inline void SensorEvent_SpeedData::set_cruise_engaged(bool value) {
  _internal_set_cruise_engaged(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.SpeedData.cruise_engaged)
}

// optional bool cruise_set_speed = 3;
inline bool SensorEvent_SpeedData::_internal_has_cruise_set_speed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorEvent_SpeedData::has_cruise_set_speed() const {
  return _internal_has_cruise_set_speed();
}
inline void SensorEvent_SpeedData::clear_cruise_set_speed() {
  cruise_set_speed_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SensorEvent_SpeedData::_internal_cruise_set_speed() const {
  return cruise_set_speed_;
}
inline bool SensorEvent_SpeedData::cruise_set_speed() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.SpeedData.cruise_set_speed)
  return _internal_cruise_set_speed();
}
inline void SensorEvent_SpeedData::_internal_set_cruise_set_speed(bool value) {
  _has_bits_[0] |= 0x00000004u;
  cruise_set_speed_ = value;
}
inline void SensorEvent_SpeedData::set_cruise_set_speed(bool value) {
  _internal_set_cruise_set_speed(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.SpeedData.cruise_set_speed)
}

// -------------------------------------------------------------------

// SensorEvent_OdometerData

// optional int32 kms_el = 1;
inline bool SensorEvent_OdometerData::_internal_has_kms_el() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_OdometerData::has_kms_el() const {
  return _internal_has_kms_el();
}
inline void SensorEvent_OdometerData::clear_kms_el() {
  kms_el_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_OdometerData::_internal_kms_el() const {
  return kms_el_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_OdometerData::kms_el() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.OdometerData.kms_el)
  return _internal_kms_el();
}
inline void SensorEvent_OdometerData::_internal_set_kms_el(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  kms_el_ = value;
}
inline void SensorEvent_OdometerData::set_kms_el(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_kms_el(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.OdometerData.kms_el)
}

// optional int32 trip_kms_el = 2;
inline bool SensorEvent_OdometerData::_internal_has_trip_kms_el() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_OdometerData::has_trip_kms_el() const {
  return _internal_has_trip_kms_el();
}
inline void SensorEvent_OdometerData::clear_trip_kms_el() {
  trip_kms_el_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_OdometerData::_internal_trip_kms_el() const {
  return trip_kms_el_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_OdometerData::trip_kms_el() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.OdometerData.trip_kms_el)
  return _internal_trip_kms_el();
}
inline void SensorEvent_OdometerData::_internal_set_trip_kms_el(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  trip_kms_el_ = value;
}
inline void SensorEvent_OdometerData::set_trip_kms_el(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_trip_kms_el(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.OdometerData.trip_kms_el)
}

// -------------------------------------------------------------------

// SensorEvent_ParkingBreak

// optional bool parking_breake = 1;
inline bool SensorEvent_ParkingBreak::_internal_has_parking_breake() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_ParkingBreak::has_parking_breake() const {
  return _internal_has_parking_breake();
}
inline void SensorEvent_ParkingBreak::clear_parking_breake() {
  parking_breake_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SensorEvent_ParkingBreak::_internal_parking_breake() const {
  return parking_breake_;
}
inline bool SensorEvent_ParkingBreak::parking_breake() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.ParkingBreak.parking_breake)
  return _internal_parking_breake();
}
inline void SensorEvent_ParkingBreak::_internal_set_parking_breake(bool value) {
  _has_bits_[0] |= 0x00000001u;
  parking_breake_ = value;
}
inline void SensorEvent_ParkingBreak::set_parking_breake(bool value) {
  _internal_set_parking_breake(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.ParkingBreak.parking_breake)
}

// -------------------------------------------------------------------

// SensorEvent_Passenger

// optional bool passenger_present = 1;
inline bool SensorEvent_Passenger::_internal_has_passenger_present() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_Passenger::has_passenger_present() const {
  return _internal_has_passenger_present();
}
inline void SensorEvent_Passenger::clear_passenger_present() {
  passenger_present_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SensorEvent_Passenger::_internal_passenger_present() const {
  return passenger_present_;
}
inline bool SensorEvent_Passenger::passenger_present() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Passenger.passenger_present)
  return _internal_passenger_present();
}
inline void SensorEvent_Passenger::_internal_set_passenger_present(bool value) {
  _has_bits_[0] |= 0x00000001u;
  passenger_present_ = value;
}
inline void SensorEvent_Passenger::set_passenger_present(bool value) {
  _internal_set_passenger_present(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Passenger.passenger_present)
}

// -------------------------------------------------------------------

// SensorEvent_Diagnostics

// optional bytes diagnostics_byte = 1;
inline bool SensorEvent_Diagnostics::_internal_has_diagnostics_byte() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_Diagnostics::has_diagnostics_byte() const {
  return _internal_has_diagnostics_byte();
}
inline void SensorEvent_Diagnostics::clear_diagnostics_byte() {
  diagnostics_byte_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SensorEvent_Diagnostics::diagnostics_byte() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Diagnostics.diagnostics_byte)
  return _internal_diagnostics_byte();
}
inline void SensorEvent_Diagnostics::set_diagnostics_byte(const std::string& value) {
  _internal_set_diagnostics_byte(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Diagnostics.diagnostics_byte)
}
inline std::string* SensorEvent_Diagnostics::mutable_diagnostics_byte() {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.Diagnostics.diagnostics_byte)
  return _internal_mutable_diagnostics_byte();
}
inline const std::string& SensorEvent_Diagnostics::_internal_diagnostics_byte() const {
  return diagnostics_byte_.Get();
}
inline void SensorEvent_Diagnostics::_internal_set_diagnostics_byte(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  diagnostics_byte_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SensorEvent_Diagnostics::set_diagnostics_byte(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  diagnostics_byte_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.SensorEvent.Diagnostics.diagnostics_byte)
}
inline void SensorEvent_Diagnostics::set_diagnostics_byte(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  diagnostics_byte_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.SensorEvent.Diagnostics.diagnostics_byte)
}
inline void SensorEvent_Diagnostics::set_diagnostics_byte(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  diagnostics_byte_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.SensorEvent.Diagnostics.diagnostics_byte)
}
inline std::string* SensorEvent_Diagnostics::_internal_mutable_diagnostics_byte() {
  _has_bits_[0] |= 0x00000001u;
  return diagnostics_byte_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SensorEvent_Diagnostics::release_diagnostics_byte() {
  // @@protoc_insertion_point(field_release:HU.SensorEvent.Diagnostics.diagnostics_byte)
  if (!_internal_has_diagnostics_byte()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return diagnostics_byte_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SensorEvent_Diagnostics::set_allocated_diagnostics_byte(std::string* diagnostics_byte) {
  if (diagnostics_byte != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  diagnostics_byte_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), diagnostics_byte,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.SensorEvent.Diagnostics.diagnostics_byte)
}
inline std::string* SensorEvent_Diagnostics::unsafe_arena_release_diagnostics_byte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.SensorEvent.Diagnostics.diagnostics_byte)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return diagnostics_byte_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void SensorEvent_Diagnostics::unsafe_arena_set_allocated_diagnostics_byte(
    std::string* diagnostics_byte) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (diagnostics_byte != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  diagnostics_byte_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      diagnostics_byte, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.SensorEvent.Diagnostics.diagnostics_byte)
}

// -------------------------------------------------------------------

// SensorEvent_Environment

// optional int32 temperature_e3 = 1;
inline bool SensorEvent_Environment::_internal_has_temperature_e3() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_Environment::has_temperature_e3() const {
  return _internal_has_temperature_e3();
}
inline void SensorEvent_Environment::clear_temperature_e3() {
  temperature_e3_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Environment::_internal_temperature_e3() const {
  return temperature_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Environment::temperature_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Environment.temperature_e3)
  return _internal_temperature_e3();
}
inline void SensorEvent_Environment::_internal_set_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  temperature_e3_ = value;
}
inline void SensorEvent_Environment::set_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_temperature_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Environment.temperature_e3)
}

// optional int32 pressure_e3 = 2;
inline bool SensorEvent_Environment::_internal_has_pressure_e3() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_Environment::has_pressure_e3() const {
  return _internal_has_pressure_e3();
}
inline void SensorEvent_Environment::clear_pressure_e3() {
  pressure_e3_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Environment::_internal_pressure_e3() const {
  return pressure_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Environment::pressure_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Environment.pressure_e3)
  return _internal_pressure_e3();
}
inline void SensorEvent_Environment::_internal_set_pressure_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  pressure_e3_ = value;
}
inline void SensorEvent_Environment::set_pressure_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pressure_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Environment.pressure_e3)
}

// optional int32 rain = 3;
inline bool SensorEvent_Environment::_internal_has_rain() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorEvent_Environment::has_rain() const {
  return _internal_has_rain();
}
inline void SensorEvent_Environment::clear_rain() {
  rain_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Environment::_internal_rain() const {
  return rain_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Environment::rain() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Environment.rain)
  return _internal_rain();
}
inline void SensorEvent_Environment::_internal_set_rain(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  rain_ = value;
}
inline void SensorEvent_Environment::set_rain(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rain(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Environment.rain)
}

// -------------------------------------------------------------------

// SensorEvent_HVAC

// optional int32 target_temperature_e3 = 1;
inline bool SensorEvent_HVAC::_internal_has_target_temperature_e3() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_HVAC::has_target_temperature_e3() const {
  return _internal_has_target_temperature_e3();
}
inline void SensorEvent_HVAC::clear_target_temperature_e3() {
  target_temperature_e3_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_HVAC::_internal_target_temperature_e3() const {
  return target_temperature_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_HVAC::target_temperature_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.HVAC.target_temperature_e3)
  return _internal_target_temperature_e3();
}
inline void SensorEvent_HVAC::_internal_set_target_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  target_temperature_e3_ = value;
}
inline void SensorEvent_HVAC::set_target_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_target_temperature_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.HVAC.target_temperature_e3)
}

// optional int32 current_temperature_e3 = 2;
inline bool SensorEvent_HVAC::_internal_has_current_temperature_e3() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_HVAC::has_current_temperature_e3() const {
  return _internal_has_current_temperature_e3();
}
inline void SensorEvent_HVAC::clear_current_temperature_e3() {
  current_temperature_e3_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_HVAC::_internal_current_temperature_e3() const {
  return current_temperature_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_HVAC::current_temperature_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.HVAC.current_temperature_e3)
  return _internal_current_temperature_e3();
}
inline void SensorEvent_HVAC::_internal_set_current_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  current_temperature_e3_ = value;
}
inline void SensorEvent_HVAC::set_current_temperature_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_current_temperature_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.HVAC.current_temperature_e3)
}

// -------------------------------------------------------------------

// SensorEvent_Accel

// optional int32 acceleration_x_e3 = 1;
inline bool SensorEvent_Accel::_internal_has_acceleration_x_e3() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_Accel::has_acceleration_x_e3() const {
  return _internal_has_acceleration_x_e3();
}
inline void SensorEvent_Accel::clear_acceleration_x_e3() {
  acceleration_x_e3_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Accel::_internal_acceleration_x_e3() const {
  return acceleration_x_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Accel::acceleration_x_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Accel.acceleration_x_e3)
  return _internal_acceleration_x_e3();
}
inline void SensorEvent_Accel::_internal_set_acceleration_x_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  acceleration_x_e3_ = value;
}
inline void SensorEvent_Accel::set_acceleration_x_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_acceleration_x_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Accel.acceleration_x_e3)
}

// optional int32 acceleration_y_e3 = 2;
inline bool SensorEvent_Accel::_internal_has_acceleration_y_e3() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_Accel::has_acceleration_y_e3() const {
  return _internal_has_acceleration_y_e3();
}
inline void SensorEvent_Accel::clear_acceleration_y_e3() {
  acceleration_y_e3_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Accel::_internal_acceleration_y_e3() const {
  return acceleration_y_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Accel::acceleration_y_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Accel.acceleration_y_e3)
  return _internal_acceleration_y_e3();
}
inline void SensorEvent_Accel::_internal_set_acceleration_y_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  acceleration_y_e3_ = value;
}
inline void SensorEvent_Accel::set_acceleration_y_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_acceleration_y_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Accel.acceleration_y_e3)
}

// optional int32 acceleration_z_e3 = 3;
inline bool SensorEvent_Accel::_internal_has_acceleration_z_e3() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorEvent_Accel::has_acceleration_z_e3() const {
  return _internal_has_acceleration_z_e3();
}
inline void SensorEvent_Accel::clear_acceleration_z_e3() {
  acceleration_z_e3_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Accel::_internal_acceleration_z_e3() const {
  return acceleration_z_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Accel::acceleration_z_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Accel.acceleration_z_e3)
  return _internal_acceleration_z_e3();
}
inline void SensorEvent_Accel::_internal_set_acceleration_z_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  acceleration_z_e3_ = value;
}
inline void SensorEvent_Accel::set_acceleration_z_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_acceleration_z_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Accel.acceleration_z_e3)
}

// -------------------------------------------------------------------

// SensorEvent_Gyro

// optional int32 rotation_speed_x_e3 = 1;
inline bool SensorEvent_Gyro::_internal_has_rotation_speed_x_e3() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_Gyro::has_rotation_speed_x_e3() const {
  return _internal_has_rotation_speed_x_e3();
}
inline void SensorEvent_Gyro::clear_rotation_speed_x_e3() {
  rotation_speed_x_e3_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Gyro::_internal_rotation_speed_x_e3() const {
  return rotation_speed_x_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Gyro::rotation_speed_x_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Gyro.rotation_speed_x_e3)
  return _internal_rotation_speed_x_e3();
}
inline void SensorEvent_Gyro::_internal_set_rotation_speed_x_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  rotation_speed_x_e3_ = value;
}
inline void SensorEvent_Gyro::set_rotation_speed_x_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rotation_speed_x_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Gyro.rotation_speed_x_e3)
}

// optional int32 rotation_speed_y_e3 = 2;
inline bool SensorEvent_Gyro::_internal_has_rotation_speed_y_e3() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_Gyro::has_rotation_speed_y_e3() const {
  return _internal_has_rotation_speed_y_e3();
}
inline void SensorEvent_Gyro::clear_rotation_speed_y_e3() {
  rotation_speed_y_e3_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Gyro::_internal_rotation_speed_y_e3() const {
  return rotation_speed_y_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Gyro::rotation_speed_y_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Gyro.rotation_speed_y_e3)
  return _internal_rotation_speed_y_e3();
}
inline void SensorEvent_Gyro::_internal_set_rotation_speed_y_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  rotation_speed_y_e3_ = value;
}
inline void SensorEvent_Gyro::set_rotation_speed_y_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rotation_speed_y_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Gyro.rotation_speed_y_e3)
}

// optional int32 rotation_speed_z_e3 = 3;
inline bool SensorEvent_Gyro::_internal_has_rotation_speed_z_e3() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorEvent_Gyro::has_rotation_speed_z_e3() const {
  return _internal_has_rotation_speed_z_e3();
}
inline void SensorEvent_Gyro::clear_rotation_speed_z_e3() {
  rotation_speed_z_e3_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Gyro::_internal_rotation_speed_z_e3() const {
  return rotation_speed_z_e3_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SensorEvent_Gyro::rotation_speed_z_e3() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Gyro.rotation_speed_z_e3)
  return _internal_rotation_speed_z_e3();
}
inline void SensorEvent_Gyro::_internal_set_rotation_speed_z_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  rotation_speed_z_e3_ = value;
}
inline void SensorEvent_Gyro::set_rotation_speed_z_e3(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rotation_speed_z_e3(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Gyro.rotation_speed_z_e3)
}

// -------------------------------------------------------------------

// SensorEvent_Door

// optional bool hood_open = 1;
inline bool SensorEvent_Door::_internal_has_hood_open() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_Door::has_hood_open() const {
  return _internal_has_hood_open();
}
inline void SensorEvent_Door::clear_hood_open() {
  hood_open_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SensorEvent_Door::_internal_hood_open() const {
  return hood_open_;
}
inline bool SensorEvent_Door::hood_open() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Door.hood_open)
  return _internal_hood_open();
}
inline void SensorEvent_Door::_internal_set_hood_open(bool value) {
  _has_bits_[0] |= 0x00000001u;
  hood_open_ = value;
}
inline void SensorEvent_Door::set_hood_open(bool value) {
  _internal_set_hood_open(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Door.hood_open)
}

// optional bool boot_open = 2;
inline bool SensorEvent_Door::_internal_has_boot_open() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_Door::has_boot_open() const {
  return _internal_has_boot_open();
}
inline void SensorEvent_Door::clear_boot_open() {
  boot_open_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SensorEvent_Door::_internal_boot_open() const {
  return boot_open_;
}
inline bool SensorEvent_Door::boot_open() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Door.boot_open)
  return _internal_boot_open();
}
inline void SensorEvent_Door::_internal_set_boot_open(bool value) {
  _has_bits_[0] |= 0x00000002u;
  boot_open_ = value;
}
inline void SensorEvent_Door::set_boot_open(bool value) {
  _internal_set_boot_open(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Door.boot_open)
}

// repeated bool door_open = 3;
inline int SensorEvent_Door::_internal_door_open_size() const {
  return door_open_.size();
}
inline int SensorEvent_Door::door_open_size() const {
  return _internal_door_open_size();
}
inline void SensorEvent_Door::clear_door_open() {
  door_open_.Clear();
}
inline bool SensorEvent_Door::_internal_door_open(int index) const {
  return door_open_.Get(index);
}
inline bool SensorEvent_Door::door_open(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Door.door_open)
  return _internal_door_open(index);
}
inline void SensorEvent_Door::set_door_open(int index, bool value) {
  door_open_.Set(index, value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Door.door_open)
}
inline void SensorEvent_Door::_internal_add_door_open(bool value) {
  door_open_.Add(value);
}
inline void SensorEvent_Door::add_door_open(bool value) {
  _internal_add_door_open(value);
  // @@protoc_insertion_point(field_add:HU.SensorEvent.Door.door_open)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SensorEvent_Door::_internal_door_open() const {
  return door_open_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
SensorEvent_Door::door_open() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.Door.door_open)
  return _internal_door_open();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SensorEvent_Door::_internal_mutable_door_open() {
  return &door_open_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
SensorEvent_Door::mutable_door_open() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.Door.door_open)
  return _internal_mutable_door_open();
}

// -------------------------------------------------------------------

// SensorEvent_Light

// optional .HU.SensorEvent.Light.HEADLIGHT_STATE headlight = 1;
inline bool SensorEvent_Light::_internal_has_headlight() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_Light::has_headlight() const {
  return _internal_has_headlight();
}
inline void SensorEvent_Light::clear_headlight() {
  headlight_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::SensorEvent_Light_HEADLIGHT_STATE SensorEvent_Light::_internal_headlight() const {
  return static_cast< ::HU::SensorEvent_Light_HEADLIGHT_STATE >(headlight_);
}
inline ::HU::SensorEvent_Light_HEADLIGHT_STATE SensorEvent_Light::headlight() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Light.headlight)
  return _internal_headlight();
}
inline void SensorEvent_Light::_internal_set_headlight(::HU::SensorEvent_Light_HEADLIGHT_STATE value) {
  assert(::HU::SensorEvent_Light_HEADLIGHT_STATE_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  headlight_ = value;
}
inline void SensorEvent_Light::set_headlight(::HU::SensorEvent_Light_HEADLIGHT_STATE value) {
  _internal_set_headlight(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Light.headlight)
}

// optional .HU.SensorEvent.Light.TURN_INDICATOR_STATE turn_indicator = 2;
inline bool SensorEvent_Light::_internal_has_turn_indicator() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorEvent_Light::has_turn_indicator() const {
  return _internal_has_turn_indicator();
}
inline void SensorEvent_Light::clear_turn_indicator() {
  turn_indicator_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::HU::SensorEvent_Light_TURN_INDICATOR_STATE SensorEvent_Light::_internal_turn_indicator() const {
  return static_cast< ::HU::SensorEvent_Light_TURN_INDICATOR_STATE >(turn_indicator_);
}
inline ::HU::SensorEvent_Light_TURN_INDICATOR_STATE SensorEvent_Light::turn_indicator() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Light.turn_indicator)
  return _internal_turn_indicator();
}
inline void SensorEvent_Light::_internal_set_turn_indicator(::HU::SensorEvent_Light_TURN_INDICATOR_STATE value) {
  assert(::HU::SensorEvent_Light_TURN_INDICATOR_STATE_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  turn_indicator_ = value;
}
inline void SensorEvent_Light::set_turn_indicator(::HU::SensorEvent_Light_TURN_INDICATOR_STATE value) {
  _internal_set_turn_indicator(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Light.turn_indicator)
}

// optional bool hazard_light_on = 3;
inline bool SensorEvent_Light::_internal_has_hazard_light_on() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SensorEvent_Light::has_hazard_light_on() const {
  return _internal_has_hazard_light_on();
}
inline void SensorEvent_Light::clear_hazard_light_on() {
  hazard_light_on_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SensorEvent_Light::_internal_hazard_light_on() const {
  return hazard_light_on_;
}
inline bool SensorEvent_Light::hazard_light_on() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.Light.hazard_light_on)
  return _internal_hazard_light_on();
}
inline void SensorEvent_Light::_internal_set_hazard_light_on(bool value) {
  _has_bits_[0] |= 0x00000004u;
  hazard_light_on_ = value;
}
inline void SensorEvent_Light::set_hazard_light_on(bool value) {
  _internal_set_hazard_light_on(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.Light.hazard_light_on)
}

// -------------------------------------------------------------------

// SensorEvent_GearData

// required .HU.SensorEvent.GearData.GEAR gear = 1;
inline bool SensorEvent_GearData::_internal_has_gear() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorEvent_GearData::has_gear() const {
  return _internal_has_gear();
}
inline void SensorEvent_GearData::clear_gear() {
  gear_ = 100;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::SensorEvent_GearData_GEAR SensorEvent_GearData::_internal_gear() const {
  return static_cast< ::HU::SensorEvent_GearData_GEAR >(gear_);
}
inline ::HU::SensorEvent_GearData_GEAR SensorEvent_GearData::gear() const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.GearData.gear)
  return _internal_gear();
}
inline void SensorEvent_GearData::_internal_set_gear(::HU::SensorEvent_GearData_GEAR value) {
  assert(::HU::SensorEvent_GearData_GEAR_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  gear_ = value;
}
inline void SensorEvent_GearData::set_gear(::HU::SensorEvent_GearData_GEAR value) {
  _internal_set_gear(value);
  // @@protoc_insertion_point(field_set:HU.SensorEvent.GearData.gear)
}

// -------------------------------------------------------------------

// SensorEvent

// repeated .HU.SensorEvent.LocationData location_data = 1;
inline int SensorEvent::_internal_location_data_size() const {
  return location_data_.size();
}
inline int SensorEvent::location_data_size() const {
  return _internal_location_data_size();
}
inline void SensorEvent::clear_location_data() {
  location_data_.Clear();
}
inline ::HU::SensorEvent_LocationData* SensorEvent::mutable_location_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.location_data)
  return location_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_LocationData >*
SensorEvent::mutable_location_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.location_data)
  return &location_data_;
}
inline const ::HU::SensorEvent_LocationData& SensorEvent::_internal_location_data(int index) const {
  return location_data_.Get(index);
}
inline const ::HU::SensorEvent_LocationData& SensorEvent::location_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.location_data)
  return _internal_location_data(index);
}
inline ::HU::SensorEvent_LocationData* SensorEvent::_internal_add_location_data() {
  return location_data_.Add();
}
inline ::HU::SensorEvent_LocationData* SensorEvent::add_location_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.location_data)
  return _internal_add_location_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_LocationData >&
SensorEvent::location_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.location_data)
  return location_data_;
}

// repeated .HU.SensorEvent.CompassData compass_data = 2;
inline int SensorEvent::_internal_compass_data_size() const {
  return compass_data_.size();
}
inline int SensorEvent::compass_data_size() const {
  return _internal_compass_data_size();
}
inline void SensorEvent::clear_compass_data() {
  compass_data_.Clear();
}
inline ::HU::SensorEvent_CompassData* SensorEvent::mutable_compass_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.compass_data)
  return compass_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_CompassData >*
SensorEvent::mutable_compass_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.compass_data)
  return &compass_data_;
}
inline const ::HU::SensorEvent_CompassData& SensorEvent::_internal_compass_data(int index) const {
  return compass_data_.Get(index);
}
inline const ::HU::SensorEvent_CompassData& SensorEvent::compass_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.compass_data)
  return _internal_compass_data(index);
}
inline ::HU::SensorEvent_CompassData* SensorEvent::_internal_add_compass_data() {
  return compass_data_.Add();
}
inline ::HU::SensorEvent_CompassData* SensorEvent::add_compass_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.compass_data)
  return _internal_add_compass_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_CompassData >&
SensorEvent::compass_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.compass_data)
  return compass_data_;
}

// repeated .HU.SensorEvent.SpeedData speed_data = 3;
inline int SensorEvent::_internal_speed_data_size() const {
  return speed_data_.size();
}
inline int SensorEvent::speed_data_size() const {
  return _internal_speed_data_size();
}
inline void SensorEvent::clear_speed_data() {
  speed_data_.Clear();
}
inline ::HU::SensorEvent_SpeedData* SensorEvent::mutable_speed_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.speed_data)
  return speed_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_SpeedData >*
SensorEvent::mutable_speed_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.speed_data)
  return &speed_data_;
}
inline const ::HU::SensorEvent_SpeedData& SensorEvent::_internal_speed_data(int index) const {
  return speed_data_.Get(index);
}
inline const ::HU::SensorEvent_SpeedData& SensorEvent::speed_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.speed_data)
  return _internal_speed_data(index);
}
inline ::HU::SensorEvent_SpeedData* SensorEvent::_internal_add_speed_data() {
  return speed_data_.Add();
}
inline ::HU::SensorEvent_SpeedData* SensorEvent::add_speed_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.speed_data)
  return _internal_add_speed_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_SpeedData >&
SensorEvent::speed_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.speed_data)
  return speed_data_;
}

// repeated .HU.SensorEvent.RPM rpm = 4;
inline int SensorEvent::_internal_rpm_size() const {
  return rpm_.size();
}
inline int SensorEvent::rpm_size() const {
  return _internal_rpm_size();
}
inline void SensorEvent::clear_rpm() {
  rpm_.Clear();
}
inline ::HU::SensorEvent_RPM* SensorEvent::mutable_rpm(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.rpm)
  return rpm_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_RPM >*
SensorEvent::mutable_rpm() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.rpm)
  return &rpm_;
}
inline const ::HU::SensorEvent_RPM& SensorEvent::_internal_rpm(int index) const {
  return rpm_.Get(index);
}
inline const ::HU::SensorEvent_RPM& SensorEvent::rpm(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.rpm)
  return _internal_rpm(index);
}
inline ::HU::SensorEvent_RPM* SensorEvent::_internal_add_rpm() {
  return rpm_.Add();
}
inline ::HU::SensorEvent_RPM* SensorEvent::add_rpm() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.rpm)
  return _internal_add_rpm();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_RPM >&
SensorEvent::rpm() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.rpm)
  return rpm_;
}

// repeated .HU.SensorEvent.OdometerData odometer_data = 5;
inline int SensorEvent::_internal_odometer_data_size() const {
  return odometer_data_.size();
}
inline int SensorEvent::odometer_data_size() const {
  return _internal_odometer_data_size();
}
inline void SensorEvent::clear_odometer_data() {
  odometer_data_.Clear();
}
inline ::HU::SensorEvent_OdometerData* SensorEvent::mutable_odometer_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.odometer_data)
  return odometer_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_OdometerData >*
SensorEvent::mutable_odometer_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.odometer_data)
  return &odometer_data_;
}
inline const ::HU::SensorEvent_OdometerData& SensorEvent::_internal_odometer_data(int index) const {
  return odometer_data_.Get(index);
}
inline const ::HU::SensorEvent_OdometerData& SensorEvent::odometer_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.odometer_data)
  return _internal_odometer_data(index);
}
inline ::HU::SensorEvent_OdometerData* SensorEvent::_internal_add_odometer_data() {
  return odometer_data_.Add();
}
inline ::HU::SensorEvent_OdometerData* SensorEvent::add_odometer_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.odometer_data)
  return _internal_add_odometer_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_OdometerData >&
SensorEvent::odometer_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.odometer_data)
  return odometer_data_;
}

// repeated .HU.SensorEvent.FuelLevel fuel_data = 6;
inline int SensorEvent::_internal_fuel_data_size() const {
  return fuel_data_.size();
}
inline int SensorEvent::fuel_data_size() const {
  return _internal_fuel_data_size();
}
inline void SensorEvent::clear_fuel_data() {
  fuel_data_.Clear();
}
inline ::HU::SensorEvent_FuelLevel* SensorEvent::mutable_fuel_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.fuel_data)
  return fuel_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_FuelLevel >*
SensorEvent::mutable_fuel_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.fuel_data)
  return &fuel_data_;
}
inline const ::HU::SensorEvent_FuelLevel& SensorEvent::_internal_fuel_data(int index) const {
  return fuel_data_.Get(index);
}
inline const ::HU::SensorEvent_FuelLevel& SensorEvent::fuel_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.fuel_data)
  return _internal_fuel_data(index);
}
inline ::HU::SensorEvent_FuelLevel* SensorEvent::_internal_add_fuel_data() {
  return fuel_data_.Add();
}
inline ::HU::SensorEvent_FuelLevel* SensorEvent::add_fuel_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.fuel_data)
  return _internal_add_fuel_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_FuelLevel >&
SensorEvent::fuel_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.fuel_data)
  return fuel_data_;
}

// repeated .HU.SensorEvent.ParkingBreak parkingbrake_data = 7;
inline int SensorEvent::_internal_parkingbrake_data_size() const {
  return parkingbrake_data_.size();
}
inline int SensorEvent::parkingbrake_data_size() const {
  return _internal_parkingbrake_data_size();
}
inline void SensorEvent::clear_parkingbrake_data() {
  parkingbrake_data_.Clear();
}
inline ::HU::SensorEvent_ParkingBreak* SensorEvent::mutable_parkingbrake_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.parkingbrake_data)
  return parkingbrake_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_ParkingBreak >*
SensorEvent::mutable_parkingbrake_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.parkingbrake_data)
  return &parkingbrake_data_;
}
inline const ::HU::SensorEvent_ParkingBreak& SensorEvent::_internal_parkingbrake_data(int index) const {
  return parkingbrake_data_.Get(index);
}
inline const ::HU::SensorEvent_ParkingBreak& SensorEvent::parkingbrake_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.parkingbrake_data)
  return _internal_parkingbrake_data(index);
}
inline ::HU::SensorEvent_ParkingBreak* SensorEvent::_internal_add_parkingbrake_data() {
  return parkingbrake_data_.Add();
}
inline ::HU::SensorEvent_ParkingBreak* SensorEvent::add_parkingbrake_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.parkingbrake_data)
  return _internal_add_parkingbrake_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_ParkingBreak >&
SensorEvent::parkingbrake_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.parkingbrake_data)
  return parkingbrake_data_;
}

// repeated .HU.SensorEvent.GearData gear_data = 8;
inline int SensorEvent::_internal_gear_data_size() const {
  return gear_data_.size();
}
inline int SensorEvent::gear_data_size() const {
  return _internal_gear_data_size();
}
inline void SensorEvent::clear_gear_data() {
  gear_data_.Clear();
}
inline ::HU::SensorEvent_GearData* SensorEvent::mutable_gear_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.gear_data)
  return gear_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_GearData >*
SensorEvent::mutable_gear_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.gear_data)
  return &gear_data_;
}
inline const ::HU::SensorEvent_GearData& SensorEvent::_internal_gear_data(int index) const {
  return gear_data_.Get(index);
}
inline const ::HU::SensorEvent_GearData& SensorEvent::gear_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.gear_data)
  return _internal_gear_data(index);
}
inline ::HU::SensorEvent_GearData* SensorEvent::_internal_add_gear_data() {
  return gear_data_.Add();
}
inline ::HU::SensorEvent_GearData* SensorEvent::add_gear_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.gear_data)
  return _internal_add_gear_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_GearData >&
SensorEvent::gear_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.gear_data)
  return gear_data_;
}

// repeated .HU.SensorEvent.Diagnostics diagnostics_data = 9;
inline int SensorEvent::_internal_diagnostics_data_size() const {
  return diagnostics_data_.size();
}
inline int SensorEvent::diagnostics_data_size() const {
  return _internal_diagnostics_data_size();
}
inline void SensorEvent::clear_diagnostics_data() {
  diagnostics_data_.Clear();
}
inline ::HU::SensorEvent_Diagnostics* SensorEvent::mutable_diagnostics_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.diagnostics_data)
  return diagnostics_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Diagnostics >*
SensorEvent::mutable_diagnostics_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.diagnostics_data)
  return &diagnostics_data_;
}
inline const ::HU::SensorEvent_Diagnostics& SensorEvent::_internal_diagnostics_data(int index) const {
  return diagnostics_data_.Get(index);
}
inline const ::HU::SensorEvent_Diagnostics& SensorEvent::diagnostics_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.diagnostics_data)
  return _internal_diagnostics_data(index);
}
inline ::HU::SensorEvent_Diagnostics* SensorEvent::_internal_add_diagnostics_data() {
  return diagnostics_data_.Add();
}
inline ::HU::SensorEvent_Diagnostics* SensorEvent::add_diagnostics_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.diagnostics_data)
  return _internal_add_diagnostics_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Diagnostics >&
SensorEvent::diagnostics_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.diagnostics_data)
  return diagnostics_data_;
}

// repeated .HU.SensorEvent.NightMode night_mode = 10;
inline int SensorEvent::_internal_night_mode_size() const {
  return night_mode_.size();
}
inline int SensorEvent::night_mode_size() const {
  return _internal_night_mode_size();
}
inline void SensorEvent::clear_night_mode() {
  night_mode_.Clear();
}
inline ::HU::SensorEvent_NightMode* SensorEvent::mutable_night_mode(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.night_mode)
  return night_mode_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_NightMode >*
SensorEvent::mutable_night_mode() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.night_mode)
  return &night_mode_;
}
inline const ::HU::SensorEvent_NightMode& SensorEvent::_internal_night_mode(int index) const {
  return night_mode_.Get(index);
}
inline const ::HU::SensorEvent_NightMode& SensorEvent::night_mode(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.night_mode)
  return _internal_night_mode(index);
}
inline ::HU::SensorEvent_NightMode* SensorEvent::_internal_add_night_mode() {
  return night_mode_.Add();
}
inline ::HU::SensorEvent_NightMode* SensorEvent::add_night_mode() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.night_mode)
  return _internal_add_night_mode();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_NightMode >&
SensorEvent::night_mode() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.night_mode)
  return night_mode_;
}

// repeated .HU.SensorEvent.Environment enviorment_data = 11;
inline int SensorEvent::_internal_enviorment_data_size() const {
  return enviorment_data_.size();
}
inline int SensorEvent::enviorment_data_size() const {
  return _internal_enviorment_data_size();
}
inline void SensorEvent::clear_enviorment_data() {
  enviorment_data_.Clear();
}
inline ::HU::SensorEvent_Environment* SensorEvent::mutable_enviorment_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.enviorment_data)
  return enviorment_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Environment >*
SensorEvent::mutable_enviorment_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.enviorment_data)
  return &enviorment_data_;
}
inline const ::HU::SensorEvent_Environment& SensorEvent::_internal_enviorment_data(int index) const {
  return enviorment_data_.Get(index);
}
inline const ::HU::SensorEvent_Environment& SensorEvent::enviorment_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.enviorment_data)
  return _internal_enviorment_data(index);
}
inline ::HU::SensorEvent_Environment* SensorEvent::_internal_add_enviorment_data() {
  return enviorment_data_.Add();
}
inline ::HU::SensorEvent_Environment* SensorEvent::add_enviorment_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.enviorment_data)
  return _internal_add_enviorment_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Environment >&
SensorEvent::enviorment_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.enviorment_data)
  return enviorment_data_;
}

// repeated .HU.SensorEvent.HVAC hvac_data = 12;
inline int SensorEvent::_internal_hvac_data_size() const {
  return hvac_data_.size();
}
inline int SensorEvent::hvac_data_size() const {
  return _internal_hvac_data_size();
}
inline void SensorEvent::clear_hvac_data() {
  hvac_data_.Clear();
}
inline ::HU::SensorEvent_HVAC* SensorEvent::mutable_hvac_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.hvac_data)
  return hvac_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_HVAC >*
SensorEvent::mutable_hvac_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.hvac_data)
  return &hvac_data_;
}
inline const ::HU::SensorEvent_HVAC& SensorEvent::_internal_hvac_data(int index) const {
  return hvac_data_.Get(index);
}
inline const ::HU::SensorEvent_HVAC& SensorEvent::hvac_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.hvac_data)
  return _internal_hvac_data(index);
}
inline ::HU::SensorEvent_HVAC* SensorEvent::_internal_add_hvac_data() {
  return hvac_data_.Add();
}
inline ::HU::SensorEvent_HVAC* SensorEvent::add_hvac_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.hvac_data)
  return _internal_add_hvac_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_HVAC >&
SensorEvent::hvac_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.hvac_data)
  return hvac_data_;
}

// repeated .HU.SensorEvent.DrivingStatus driving_status = 13;
inline int SensorEvent::_internal_driving_status_size() const {
  return driving_status_.size();
}
inline int SensorEvent::driving_status_size() const {
  return _internal_driving_status_size();
}
inline void SensorEvent::clear_driving_status() {
  driving_status_.Clear();
}
inline ::HU::SensorEvent_DrivingStatus* SensorEvent::mutable_driving_status(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.driving_status)
  return driving_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DrivingStatus >*
SensorEvent::mutable_driving_status() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.driving_status)
  return &driving_status_;
}
inline const ::HU::SensorEvent_DrivingStatus& SensorEvent::_internal_driving_status(int index) const {
  return driving_status_.Get(index);
}
inline const ::HU::SensorEvent_DrivingStatus& SensorEvent::driving_status(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.driving_status)
  return _internal_driving_status(index);
}
inline ::HU::SensorEvent_DrivingStatus* SensorEvent::_internal_add_driving_status() {
  return driving_status_.Add();
}
inline ::HU::SensorEvent_DrivingStatus* SensorEvent::add_driving_status() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.driving_status)
  return _internal_add_driving_status();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DrivingStatus >&
SensorEvent::driving_status() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.driving_status)
  return driving_status_;
}

// repeated .HU.SensorEvent.DeadReckoning dead_reckoning = 14;
inline int SensorEvent::_internal_dead_reckoning_size() const {
  return dead_reckoning_.size();
}
inline int SensorEvent::dead_reckoning_size() const {
  return _internal_dead_reckoning_size();
}
inline void SensorEvent::clear_dead_reckoning() {
  dead_reckoning_.Clear();
}
inline ::HU::SensorEvent_DeadReckoning* SensorEvent::mutable_dead_reckoning(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.dead_reckoning)
  return dead_reckoning_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DeadReckoning >*
SensorEvent::mutable_dead_reckoning() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.dead_reckoning)
  return &dead_reckoning_;
}
inline const ::HU::SensorEvent_DeadReckoning& SensorEvent::_internal_dead_reckoning(int index) const {
  return dead_reckoning_.Get(index);
}
inline const ::HU::SensorEvent_DeadReckoning& SensorEvent::dead_reckoning(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.dead_reckoning)
  return _internal_dead_reckoning(index);
}
inline ::HU::SensorEvent_DeadReckoning* SensorEvent::_internal_add_dead_reckoning() {
  return dead_reckoning_.Add();
}
inline ::HU::SensorEvent_DeadReckoning* SensorEvent::add_dead_reckoning() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.dead_reckoning)
  return _internal_add_dead_reckoning();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_DeadReckoning >&
SensorEvent::dead_reckoning() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.dead_reckoning)
  return dead_reckoning_;
}

// repeated .HU.SensorEvent.Passenger passenger_data = 15;
inline int SensorEvent::_internal_passenger_data_size() const {
  return passenger_data_.size();
}
inline int SensorEvent::passenger_data_size() const {
  return _internal_passenger_data_size();
}
inline void SensorEvent::clear_passenger_data() {
  passenger_data_.Clear();
}
inline ::HU::SensorEvent_Passenger* SensorEvent::mutable_passenger_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.passenger_data)
  return passenger_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Passenger >*
SensorEvent::mutable_passenger_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.passenger_data)
  return &passenger_data_;
}
inline const ::HU::SensorEvent_Passenger& SensorEvent::_internal_passenger_data(int index) const {
  return passenger_data_.Get(index);
}
inline const ::HU::SensorEvent_Passenger& SensorEvent::passenger_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.passenger_data)
  return _internal_passenger_data(index);
}
inline ::HU::SensorEvent_Passenger* SensorEvent::_internal_add_passenger_data() {
  return passenger_data_.Add();
}
inline ::HU::SensorEvent_Passenger* SensorEvent::add_passenger_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.passenger_data)
  return _internal_add_passenger_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Passenger >&
SensorEvent::passenger_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.passenger_data)
  return passenger_data_;
}

// repeated .HU.SensorEvent.Door door_data = 16;
inline int SensorEvent::_internal_door_data_size() const {
  return door_data_.size();
}
inline int SensorEvent::door_data_size() const {
  return _internal_door_data_size();
}
inline void SensorEvent::clear_door_data() {
  door_data_.Clear();
}
inline ::HU::SensorEvent_Door* SensorEvent::mutable_door_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.door_data)
  return door_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Door >*
SensorEvent::mutable_door_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.door_data)
  return &door_data_;
}
inline const ::HU::SensorEvent_Door& SensorEvent::_internal_door_data(int index) const {
  return door_data_.Get(index);
}
inline const ::HU::SensorEvent_Door& SensorEvent::door_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.door_data)
  return _internal_door_data(index);
}
inline ::HU::SensorEvent_Door* SensorEvent::_internal_add_door_data() {
  return door_data_.Add();
}
inline ::HU::SensorEvent_Door* SensorEvent::add_door_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.door_data)
  return _internal_add_door_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Door >&
SensorEvent::door_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.door_data)
  return door_data_;
}

// repeated .HU.SensorEvent.Light light_data = 17;
inline int SensorEvent::_internal_light_data_size() const {
  return light_data_.size();
}
inline int SensorEvent::light_data_size() const {
  return _internal_light_data_size();
}
inline void SensorEvent::clear_light_data() {
  light_data_.Clear();
}
inline ::HU::SensorEvent_Light* SensorEvent::mutable_light_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.light_data)
  return light_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Light >*
SensorEvent::mutable_light_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.light_data)
  return &light_data_;
}
inline const ::HU::SensorEvent_Light& SensorEvent::_internal_light_data(int index) const {
  return light_data_.Get(index);
}
inline const ::HU::SensorEvent_Light& SensorEvent::light_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.light_data)
  return _internal_light_data(index);
}
inline ::HU::SensorEvent_Light* SensorEvent::_internal_add_light_data() {
  return light_data_.Add();
}
inline ::HU::SensorEvent_Light* SensorEvent::add_light_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.light_data)
  return _internal_add_light_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Light >&
SensorEvent::light_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.light_data)
  return light_data_;
}

// repeated .HU.SensorEvent.Accel accel_data = 19;
inline int SensorEvent::_internal_accel_data_size() const {
  return accel_data_.size();
}
inline int SensorEvent::accel_data_size() const {
  return _internal_accel_data_size();
}
inline void SensorEvent::clear_accel_data() {
  accel_data_.Clear();
}
inline ::HU::SensorEvent_Accel* SensorEvent::mutable_accel_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.accel_data)
  return accel_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Accel >*
SensorEvent::mutable_accel_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.accel_data)
  return &accel_data_;
}
inline const ::HU::SensorEvent_Accel& SensorEvent::_internal_accel_data(int index) const {
  return accel_data_.Get(index);
}
inline const ::HU::SensorEvent_Accel& SensorEvent::accel_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.accel_data)
  return _internal_accel_data(index);
}
inline ::HU::SensorEvent_Accel* SensorEvent::_internal_add_accel_data() {
  return accel_data_.Add();
}
inline ::HU::SensorEvent_Accel* SensorEvent::add_accel_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.accel_data)
  return _internal_add_accel_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Accel >&
SensorEvent::accel_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.accel_data)
  return accel_data_;
}

// repeated .HU.SensorEvent.Gyro gyro_data = 20;
inline int SensorEvent::_internal_gyro_data_size() const {
  return gyro_data_.size();
}
inline int SensorEvent::gyro_data_size() const {
  return _internal_gyro_data_size();
}
inline void SensorEvent::clear_gyro_data() {
  gyro_data_.Clear();
}
inline ::HU::SensorEvent_Gyro* SensorEvent::mutable_gyro_data(int index) {
  // @@protoc_insertion_point(field_mutable:HU.SensorEvent.gyro_data)
  return gyro_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Gyro >*
SensorEvent::mutable_gyro_data() {
  // @@protoc_insertion_point(field_mutable_list:HU.SensorEvent.gyro_data)
  return &gyro_data_;
}
inline const ::HU::SensorEvent_Gyro& SensorEvent::_internal_gyro_data(int index) const {
  return gyro_data_.Get(index);
}
inline const ::HU::SensorEvent_Gyro& SensorEvent::gyro_data(int index) const {
  // @@protoc_insertion_point(field_get:HU.SensorEvent.gyro_data)
  return _internal_gyro_data(index);
}
inline ::HU::SensorEvent_Gyro* SensorEvent::_internal_add_gyro_data() {
  return gyro_data_.Add();
}
inline ::HU::SensorEvent_Gyro* SensorEvent::add_gyro_data() {
  // @@protoc_insertion_point(field_add:HU.SensorEvent.gyro_data)
  return _internal_add_gyro_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::SensorEvent_Gyro >&
SensorEvent::gyro_data() const {
  // @@protoc_insertion_point(field_list:HU.SensorEvent.gyro_data)
  return gyro_data_;
}

// -------------------------------------------------------------------

// AudioCofig

// required uint32 sample_rate = 1;
inline bool AudioCofig::_internal_has_sample_rate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioCofig::has_sample_rate() const {
  return _internal_has_sample_rate();
}
inline void AudioCofig::clear_sample_rate() {
  sample_rate_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioCofig::_internal_sample_rate() const {
  return sample_rate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioCofig::sample_rate() const {
  // @@protoc_insertion_point(field_get:HU.AudioCofig.sample_rate)
  return _internal_sample_rate();
}
inline void AudioCofig::_internal_set_sample_rate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  sample_rate_ = value;
}
inline void AudioCofig::set_sample_rate(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:HU.AudioCofig.sample_rate)
}

// required uint32 bit_depth = 2;
inline bool AudioCofig::_internal_has_bit_depth() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioCofig::has_bit_depth() const {
  return _internal_has_bit_depth();
}
inline void AudioCofig::clear_bit_depth() {
  bit_depth_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioCofig::_internal_bit_depth() const {
  return bit_depth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioCofig::bit_depth() const {
  // @@protoc_insertion_point(field_get:HU.AudioCofig.bit_depth)
  return _internal_bit_depth();
}
inline void AudioCofig::_internal_set_bit_depth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  bit_depth_ = value;
}
inline void AudioCofig::set_bit_depth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_bit_depth(value);
  // @@protoc_insertion_point(field_set:HU.AudioCofig.bit_depth)
}

// required uint32 channel_count = 3;
inline bool AudioCofig::_internal_has_channel_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioCofig::has_channel_count() const {
  return _internal_has_channel_count();
}
inline void AudioCofig::clear_channel_count() {
  channel_count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioCofig::_internal_channel_count() const {
  return channel_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AudioCofig::channel_count() const {
  // @@protoc_insertion_point(field_get:HU.AudioCofig.channel_count)
  return _internal_channel_count();
}
inline void AudioCofig::_internal_set_channel_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  channel_count_ = value;
}
inline void AudioCofig::set_channel_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_count(value);
  // @@protoc_insertion_point(field_set:HU.AudioCofig.channel_count)
}

// -------------------------------------------------------------------

// ChannelDescriptor_SensorChannel_Sensor

// optional .HU.SENSOR_TYPE type = 1;
inline bool ChannelDescriptor_SensorChannel_Sensor::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelDescriptor_SensorChannel_Sensor::has_type() const {
  return _internal_has_type();
}
inline void ChannelDescriptor_SensorChannel_Sensor::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::SENSOR_TYPE ChannelDescriptor_SensorChannel_Sensor::_internal_type() const {
  return static_cast< ::HU::SENSOR_TYPE >(type_);
}
inline ::HU::SENSOR_TYPE ChannelDescriptor_SensorChannel_Sensor::type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.SensorChannel.Sensor.type)
  return _internal_type();
}
inline void ChannelDescriptor_SensorChannel_Sensor::_internal_set_type(::HU::SENSOR_TYPE value) {
  assert(::HU::SENSOR_TYPE_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void ChannelDescriptor_SensorChannel_Sensor::set_type(::HU::SENSOR_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.SensorChannel.Sensor.type)
}

// -------------------------------------------------------------------

// ChannelDescriptor_SensorChannel

// repeated .HU.ChannelDescriptor.SensorChannel.Sensor sensor_list = 1;
inline int ChannelDescriptor_SensorChannel::_internal_sensor_list_size() const {
  return sensor_list_.size();
}
inline int ChannelDescriptor_SensorChannel::sensor_list_size() const {
  return _internal_sensor_list_size();
}
inline void ChannelDescriptor_SensorChannel::clear_sensor_list() {
  sensor_list_.Clear();
}
inline ::HU::ChannelDescriptor_SensorChannel_Sensor* ChannelDescriptor_SensorChannel::mutable_sensor_list(int index) {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.SensorChannel.sensor_list)
  return sensor_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_SensorChannel_Sensor >*
ChannelDescriptor_SensorChannel::mutable_sensor_list() {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.SensorChannel.sensor_list)
  return &sensor_list_;
}
inline const ::HU::ChannelDescriptor_SensorChannel_Sensor& ChannelDescriptor_SensorChannel::_internal_sensor_list(int index) const {
  return sensor_list_.Get(index);
}
inline const ::HU::ChannelDescriptor_SensorChannel_Sensor& ChannelDescriptor_SensorChannel::sensor_list(int index) const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.SensorChannel.sensor_list)
  return _internal_sensor_list(index);
}
inline ::HU::ChannelDescriptor_SensorChannel_Sensor* ChannelDescriptor_SensorChannel::_internal_add_sensor_list() {
  return sensor_list_.Add();
}
inline ::HU::ChannelDescriptor_SensorChannel_Sensor* ChannelDescriptor_SensorChannel::add_sensor_list() {
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.SensorChannel.sensor_list)
  return _internal_add_sensor_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_SensorChannel_Sensor >&
ChannelDescriptor_SensorChannel::sensor_list() const {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.SensorChannel.sensor_list)
  return sensor_list_;
}

// -------------------------------------------------------------------

// ChannelDescriptor_OutputStreamChannel_VideoConfig

// required .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.VIDEO_RESOLUTION resolution = 1;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_has_resolution() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_resolution() const {
  return _internal_has_resolution();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_resolution() {
  resolution_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_resolution() const {
  return static_cast< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION >(resolution_);
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION ChannelDescriptor_OutputStreamChannel_VideoConfig::resolution() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.resolution)
  return _internal_resolution();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_resolution(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION value) {
  assert(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  resolution_ = value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_resolution(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.resolution)
}

// required .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.VIDEO_FPS frame_rate = 2;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_has_frame_rate() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_frame_rate() const {
  return _internal_has_frame_rate();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_frame_rate() {
  frame_rate_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_frame_rate() const {
  return static_cast< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS >(frame_rate_);
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS ChannelDescriptor_OutputStreamChannel_VideoConfig::frame_rate() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.frame_rate)
  return _internal_frame_rate();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_frame_rate(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS value) {
  assert(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  frame_rate_ = value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_frame_rate(::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS value) {
  _internal_set_frame_rate(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.frame_rate)
}

// required uint32 margin_width = 3;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_has_margin_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_margin_width() const {
  return _internal_has_margin_width();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_margin_width() {
  margin_width_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_margin_width() const {
  return margin_width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_OutputStreamChannel_VideoConfig::margin_width() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.margin_width)
  return _internal_margin_width();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_margin_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  margin_width_ = value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_margin_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_margin_width(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.margin_width)
}

// required uint32 margin_height = 4;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_has_margin_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_margin_height() const {
  return _internal_has_margin_height();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_margin_height() {
  margin_height_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_margin_height() const {
  return margin_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_OutputStreamChannel_VideoConfig::margin_height() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.margin_height)
  return _internal_margin_height();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_margin_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  margin_height_ = value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_margin_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_margin_height(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.margin_height)
}

// required uint32 dpi = 5;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_has_dpi() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_dpi() const {
  return _internal_has_dpi();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_dpi() {
  dpi_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_dpi() const {
  return dpi_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_OutputStreamChannel_VideoConfig::dpi() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.dpi)
  return _internal_dpi();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_dpi(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  dpi_ = value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_dpi(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_dpi(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.dpi)
}

// optional uint32 additional_depth = 6;
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_has_additional_depth() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ChannelDescriptor_OutputStreamChannel_VideoConfig::has_additional_depth() const {
  return _internal_has_additional_depth();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::clear_additional_depth() {
  additional_depth_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_additional_depth() const {
  return additional_depth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_OutputStreamChannel_VideoConfig::additional_depth() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.additional_depth)
  return _internal_additional_depth();
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::_internal_set_additional_depth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  additional_depth_ = value;
}
inline void ChannelDescriptor_OutputStreamChannel_VideoConfig::set_additional_depth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_additional_depth(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.VideoConfig.additional_depth)
}

// -------------------------------------------------------------------

// ChannelDescriptor_OutputStreamChannel

// required .HU.STREAM_TYPE type = 1;
inline bool ChannelDescriptor_OutputStreamChannel::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChannelDescriptor_OutputStreamChannel::has_type() const {
  return _internal_has_type();
}
inline void ChannelDescriptor_OutputStreamChannel::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::HU::STREAM_TYPE ChannelDescriptor_OutputStreamChannel::_internal_type() const {
  return static_cast< ::HU::STREAM_TYPE >(type_);
}
inline ::HU::STREAM_TYPE ChannelDescriptor_OutputStreamChannel::type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.type)
  return _internal_type();
}
inline void ChannelDescriptor_OutputStreamChannel::_internal_set_type(::HU::STREAM_TYPE value) {
  assert(::HU::STREAM_TYPE_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void ChannelDescriptor_OutputStreamChannel::set_type(::HU::STREAM_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.type)
}

// optional .HU.AUDIO_TYPE audio_type = 2;
inline bool ChannelDescriptor_OutputStreamChannel::_internal_has_audio_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChannelDescriptor_OutputStreamChannel::has_audio_type() const {
  return _internal_has_audio_type();
}
inline void ChannelDescriptor_OutputStreamChannel::clear_audio_type() {
  audio_type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::HU::AUDIO_TYPE ChannelDescriptor_OutputStreamChannel::_internal_audio_type() const {
  return static_cast< ::HU::AUDIO_TYPE >(audio_type_);
}
inline ::HU::AUDIO_TYPE ChannelDescriptor_OutputStreamChannel::audio_type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.audio_type)
  return _internal_audio_type();
}
inline void ChannelDescriptor_OutputStreamChannel::_internal_set_audio_type(::HU::AUDIO_TYPE value) {
  assert(::HU::AUDIO_TYPE_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  audio_type_ = value;
}
inline void ChannelDescriptor_OutputStreamChannel::set_audio_type(::HU::AUDIO_TYPE value) {
  _internal_set_audio_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.audio_type)
}

// repeated .HU.AudioCofig audio_configs = 3;
inline int ChannelDescriptor_OutputStreamChannel::_internal_audio_configs_size() const {
  return audio_configs_.size();
}
inline int ChannelDescriptor_OutputStreamChannel::audio_configs_size() const {
  return _internal_audio_configs_size();
}
inline void ChannelDescriptor_OutputStreamChannel::clear_audio_configs() {
  audio_configs_.Clear();
}
inline ::HU::AudioCofig* ChannelDescriptor_OutputStreamChannel::mutable_audio_configs(int index) {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  return audio_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::AudioCofig >*
ChannelDescriptor_OutputStreamChannel::mutable_audio_configs() {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  return &audio_configs_;
}
inline const ::HU::AudioCofig& ChannelDescriptor_OutputStreamChannel::_internal_audio_configs(int index) const {
  return audio_configs_.Get(index);
}
inline const ::HU::AudioCofig& ChannelDescriptor_OutputStreamChannel::audio_configs(int index) const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  return _internal_audio_configs(index);
}
inline ::HU::AudioCofig* ChannelDescriptor_OutputStreamChannel::_internal_add_audio_configs() {
  return audio_configs_.Add();
}
inline ::HU::AudioCofig* ChannelDescriptor_OutputStreamChannel::add_audio_configs() {
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  return _internal_add_audio_configs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::AudioCofig >&
ChannelDescriptor_OutputStreamChannel::audio_configs() const {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.OutputStreamChannel.audio_configs)
  return audio_configs_;
}

// repeated .HU.ChannelDescriptor.OutputStreamChannel.VideoConfig video_configs = 4;
inline int ChannelDescriptor_OutputStreamChannel::_internal_video_configs_size() const {
  return video_configs_.size();
}
inline int ChannelDescriptor_OutputStreamChannel::video_configs_size() const {
  return _internal_video_configs_size();
}
inline void ChannelDescriptor_OutputStreamChannel::clear_video_configs() {
  video_configs_.Clear();
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* ChannelDescriptor_OutputStreamChannel::mutable_video_configs(int index) {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  return video_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig >*
ChannelDescriptor_OutputStreamChannel::mutable_video_configs() {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  return &video_configs_;
}
inline const ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig& ChannelDescriptor_OutputStreamChannel::_internal_video_configs(int index) const {
  return video_configs_.Get(index);
}
inline const ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig& ChannelDescriptor_OutputStreamChannel::video_configs(int index) const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  return _internal_video_configs(index);
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* ChannelDescriptor_OutputStreamChannel::_internal_add_video_configs() {
  return video_configs_.Add();
}
inline ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig* ChannelDescriptor_OutputStreamChannel::add_video_configs() {
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  return _internal_add_video_configs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig >&
ChannelDescriptor_OutputStreamChannel::video_configs() const {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.OutputStreamChannel.video_configs)
  return video_configs_;
}

// optional bool available_while_in_call = 5;
inline bool ChannelDescriptor_OutputStreamChannel::_internal_has_available_while_in_call() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelDescriptor_OutputStreamChannel::has_available_while_in_call() const {
  return _internal_has_available_while_in_call();
}
inline void ChannelDescriptor_OutputStreamChannel::clear_available_while_in_call() {
  available_while_in_call_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ChannelDescriptor_OutputStreamChannel::_internal_available_while_in_call() const {
  return available_while_in_call_;
}
inline bool ChannelDescriptor_OutputStreamChannel::available_while_in_call() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.OutputStreamChannel.available_while_in_call)
  return _internal_available_while_in_call();
}
inline void ChannelDescriptor_OutputStreamChannel::_internal_set_available_while_in_call(bool value) {
  _has_bits_[0] |= 0x00000001u;
  available_while_in_call_ = value;
}
inline void ChannelDescriptor_OutputStreamChannel::set_available_while_in_call(bool value) {
  _internal_set_available_while_in_call(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.OutputStreamChannel.available_while_in_call)
}

// -------------------------------------------------------------------

// ChannelDescriptor_InputEventChannel_TouchScreenConfig

// required uint32 width = 1;
inline bool ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelDescriptor_InputEventChannel_TouchScreenConfig::has_width() const {
  return _internal_has_width();
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_InputEventChannel_TouchScreenConfig::width() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig.width)
  return _internal_width();
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig.width)
}

// required uint32 height = 2;
inline bool ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChannelDescriptor_InputEventChannel_TouchScreenConfig::has_height() const {
  return _internal_has_height();
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_InputEventChannel_TouchScreenConfig::height() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig.height)
  return _internal_height();
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
}
inline void ChannelDescriptor_InputEventChannel_TouchScreenConfig::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig.height)
}

// -------------------------------------------------------------------

// ChannelDescriptor_InputEventChannel

// repeated uint32 keycodes_supported = 1;
inline int ChannelDescriptor_InputEventChannel::_internal_keycodes_supported_size() const {
  return keycodes_supported_.size();
}
inline int ChannelDescriptor_InputEventChannel::keycodes_supported_size() const {
  return _internal_keycodes_supported_size();
}
inline void ChannelDescriptor_InputEventChannel::clear_keycodes_supported() {
  keycodes_supported_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_InputEventChannel::_internal_keycodes_supported(int index) const {
  return keycodes_supported_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_InputEventChannel::keycodes_supported(int index) const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
  return _internal_keycodes_supported(index);
}
inline void ChannelDescriptor_InputEventChannel::set_keycodes_supported(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  keycodes_supported_.Set(index, value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
}
inline void ChannelDescriptor_InputEventChannel::_internal_add_keycodes_supported(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  keycodes_supported_.Add(value);
}
inline void ChannelDescriptor_InputEventChannel::add_keycodes_supported(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_keycodes_supported(value);
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ChannelDescriptor_InputEventChannel::_internal_keycodes_supported() const {
  return keycodes_supported_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ChannelDescriptor_InputEventChannel::keycodes_supported() const {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
  return _internal_keycodes_supported();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ChannelDescriptor_InputEventChannel::_internal_mutable_keycodes_supported() {
  return &keycodes_supported_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ChannelDescriptor_InputEventChannel::mutable_keycodes_supported() {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.InputEventChannel.keycodes_supported)
  return _internal_mutable_keycodes_supported();
}

// optional .HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig touch_screen_config = 2;
inline bool ChannelDescriptor_InputEventChannel::_internal_has_touch_screen_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || touch_screen_config_ != nullptr);
  return value;
}
inline bool ChannelDescriptor_InputEventChannel::has_touch_screen_config() const {
  return _internal_has_touch_screen_config();
}
inline void ChannelDescriptor_InputEventChannel::clear_touch_screen_config() {
  if (touch_screen_config_ != nullptr) touch_screen_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& ChannelDescriptor_InputEventChannel::_internal_touch_screen_config() const {
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* p = touch_screen_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(
      &::HU::_ChannelDescriptor_InputEventChannel_TouchScreenConfig_default_instance_);
}
inline const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& ChannelDescriptor_InputEventChannel::touch_screen_config() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)
  return _internal_touch_screen_config();
}
inline void ChannelDescriptor_InputEventChannel::unsafe_arena_set_allocated_touch_screen_config(
    ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_screen_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(touch_screen_config_);
  }
  touch_screen_config_ = touch_screen_config;
  if (touch_screen_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::release_touch_screen_config() {
  auto temp = unsafe_arena_release_touch_screen_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::unsafe_arena_release_touch_screen_config() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)
  _has_bits_[0] &= ~0x00000001u;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* temp = touch_screen_config_;
  touch_screen_config_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::_internal_mutable_touch_screen_config() {
  _has_bits_[0] |= 0x00000001u;
  if (touch_screen_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig>(GetArena());
    touch_screen_config_ = p;
  }
  return touch_screen_config_;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::mutable_touch_screen_config() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)
  return _internal_mutable_touch_screen_config();
}
inline void ChannelDescriptor_InputEventChannel::set_allocated_touch_screen_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_screen_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete touch_screen_config_;
  }
  if (touch_screen_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(touch_screen_config);
    if (message_arena != submessage_arena) {
      touch_screen_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, touch_screen_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  touch_screen_config_ = touch_screen_config;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.InputEventChannel.touch_screen_config)
}

// optional .HU.ChannelDescriptor.InputEventChannel.TouchScreenConfig touch_pad_config = 3;
inline bool ChannelDescriptor_InputEventChannel::_internal_has_touch_pad_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || touch_pad_config_ != nullptr);
  return value;
}
inline bool ChannelDescriptor_InputEventChannel::has_touch_pad_config() const {
  return _internal_has_touch_pad_config();
}
inline void ChannelDescriptor_InputEventChannel::clear_touch_pad_config() {
  if (touch_pad_config_ != nullptr) touch_pad_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& ChannelDescriptor_InputEventChannel::_internal_touch_pad_config() const {
  const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* p = touch_pad_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig*>(
      &::HU::_ChannelDescriptor_InputEventChannel_TouchScreenConfig_default_instance_);
}
inline const ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig& ChannelDescriptor_InputEventChannel::touch_pad_config() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)
  return _internal_touch_pad_config();
}
inline void ChannelDescriptor_InputEventChannel::unsafe_arena_set_allocated_touch_pad_config(
    ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_pad_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(touch_pad_config_);
  }
  touch_pad_config_ = touch_pad_config;
  if (touch_pad_config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::release_touch_pad_config() {
  auto temp = unsafe_arena_release_touch_pad_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::unsafe_arena_release_touch_pad_config() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)
  _has_bits_[0] &= ~0x00000002u;
  ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* temp = touch_pad_config_;
  touch_pad_config_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::_internal_mutable_touch_pad_config() {
  _has_bits_[0] |= 0x00000002u;
  if (touch_pad_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig>(GetArena());
    touch_pad_config_ = p;
  }
  return touch_pad_config_;
}
inline ::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* ChannelDescriptor_InputEventChannel::mutable_touch_pad_config() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)
  return _internal_mutable_touch_pad_config();
}
inline void ChannelDescriptor_InputEventChannel::set_allocated_touch_pad_config(::HU::ChannelDescriptor_InputEventChannel_TouchScreenConfig* touch_pad_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete touch_pad_config_;
  }
  if (touch_pad_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(touch_pad_config);
    if (message_arena != submessage_arena) {
      touch_pad_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, touch_pad_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  touch_pad_config_ = touch_pad_config;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.InputEventChannel.touch_pad_config)
}

// -------------------------------------------------------------------

// ChannelDescriptor_InputStreamChannel

// required .HU.STREAM_TYPE type = 1;
inline bool ChannelDescriptor_InputStreamChannel::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChannelDescriptor_InputStreamChannel::has_type() const {
  return _internal_has_type();
}
inline void ChannelDescriptor_InputStreamChannel::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::HU::STREAM_TYPE ChannelDescriptor_InputStreamChannel::_internal_type() const {
  return static_cast< ::HU::STREAM_TYPE >(type_);
}
inline ::HU::STREAM_TYPE ChannelDescriptor_InputStreamChannel::type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputStreamChannel.type)
  return _internal_type();
}
inline void ChannelDescriptor_InputStreamChannel::_internal_set_type(::HU::STREAM_TYPE value) {
  assert(::HU::STREAM_TYPE_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void ChannelDescriptor_InputStreamChannel::set_type(::HU::STREAM_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputStreamChannel.type)
}

// required .HU.AudioCofig audio_config = 2;
inline bool ChannelDescriptor_InputStreamChannel::_internal_has_audio_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || audio_config_ != nullptr);
  return value;
}
inline bool ChannelDescriptor_InputStreamChannel::has_audio_config() const {
  return _internal_has_audio_config();
}
inline void ChannelDescriptor_InputStreamChannel::clear_audio_config() {
  if (audio_config_ != nullptr) audio_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::AudioCofig& ChannelDescriptor_InputStreamChannel::_internal_audio_config() const {
  const ::HU::AudioCofig* p = audio_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::AudioCofig*>(
      &::HU::_AudioCofig_default_instance_);
}
inline const ::HU::AudioCofig& ChannelDescriptor_InputStreamChannel::audio_config() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputStreamChannel.audio_config)
  return _internal_audio_config();
}
inline void ChannelDescriptor_InputStreamChannel::unsafe_arena_set_allocated_audio_config(
    ::HU::AudioCofig* audio_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_config_);
  }
  audio_config_ = audio_config;
  if (audio_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.InputStreamChannel.audio_config)
}
inline ::HU::AudioCofig* ChannelDescriptor_InputStreamChannel::release_audio_config() {
  auto temp = unsafe_arena_release_audio_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::AudioCofig* ChannelDescriptor_InputStreamChannel::unsafe_arena_release_audio_config() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.InputStreamChannel.audio_config)
  _has_bits_[0] &= ~0x00000001u;
  ::HU::AudioCofig* temp = audio_config_;
  audio_config_ = nullptr;
  return temp;
}
inline ::HU::AudioCofig* ChannelDescriptor_InputStreamChannel::_internal_mutable_audio_config() {
  _has_bits_[0] |= 0x00000001u;
  if (audio_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::AudioCofig>(GetArena());
    audio_config_ = p;
  }
  return audio_config_;
}
inline ::HU::AudioCofig* ChannelDescriptor_InputStreamChannel::mutable_audio_config() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.InputStreamChannel.audio_config)
  return _internal_mutable_audio_config();
}
inline void ChannelDescriptor_InputStreamChannel::set_allocated_audio_config(::HU::AudioCofig* audio_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audio_config_;
  }
  if (audio_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audio_config);
    if (message_arena != submessage_arena) {
      audio_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  audio_config_ = audio_config;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.InputStreamChannel.audio_config)
}

// optional bool available_while_in_call = 3;
inline bool ChannelDescriptor_InputStreamChannel::_internal_has_available_while_in_call() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChannelDescriptor_InputStreamChannel::has_available_while_in_call() const {
  return _internal_has_available_while_in_call();
}
inline void ChannelDescriptor_InputStreamChannel::clear_available_while_in_call() {
  available_while_in_call_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ChannelDescriptor_InputStreamChannel::_internal_available_while_in_call() const {
  return available_while_in_call_;
}
inline bool ChannelDescriptor_InputStreamChannel::available_while_in_call() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.InputStreamChannel.available_while_in_call)
  return _internal_available_while_in_call();
}
inline void ChannelDescriptor_InputStreamChannel::_internal_set_available_while_in_call(bool value) {
  _has_bits_[0] |= 0x00000002u;
  available_while_in_call_ = value;
}
inline void ChannelDescriptor_InputStreamChannel::set_available_while_in_call(bool value) {
  _internal_set_available_while_in_call(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.InputStreamChannel.available_while_in_call)
}

// -------------------------------------------------------------------

// ChannelDescriptor_BluetoothService

// required string car_address = 1;
inline bool ChannelDescriptor_BluetoothService::_internal_has_car_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelDescriptor_BluetoothService::has_car_address() const {
  return _internal_has_car_address();
}
inline void ChannelDescriptor_BluetoothService::clear_car_address() {
  car_address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChannelDescriptor_BluetoothService::car_address() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.BluetoothService.car_address)
  return _internal_car_address();
}
inline void ChannelDescriptor_BluetoothService::set_car_address(const std::string& value) {
  _internal_set_car_address(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.BluetoothService.car_address)
}
inline std::string* ChannelDescriptor_BluetoothService::mutable_car_address() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.BluetoothService.car_address)
  return _internal_mutable_car_address();
}
inline const std::string& ChannelDescriptor_BluetoothService::_internal_car_address() const {
  return car_address_.Get();
}
inline void ChannelDescriptor_BluetoothService::_internal_set_car_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  car_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChannelDescriptor_BluetoothService::set_car_address(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  car_address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ChannelDescriptor.BluetoothService.car_address)
}
inline void ChannelDescriptor_BluetoothService::set_car_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  car_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ChannelDescriptor.BluetoothService.car_address)
}
inline void ChannelDescriptor_BluetoothService::set_car_address(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  car_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ChannelDescriptor.BluetoothService.car_address)
}
inline std::string* ChannelDescriptor_BluetoothService::_internal_mutable_car_address() {
  _has_bits_[0] |= 0x00000001u;
  return car_address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChannelDescriptor_BluetoothService::release_car_address() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.BluetoothService.car_address)
  if (!_internal_has_car_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return car_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelDescriptor_BluetoothService::set_allocated_car_address(std::string* car_address) {
  if (car_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  car_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), car_address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.BluetoothService.car_address)
}
inline std::string* ChannelDescriptor_BluetoothService::unsafe_arena_release_car_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ChannelDescriptor.BluetoothService.car_address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return car_address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ChannelDescriptor_BluetoothService::unsafe_arena_set_allocated_car_address(
    std::string* car_address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (car_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  car_address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      car_address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.BluetoothService.car_address)
}

// repeated .HU.BluetoothPairingMethod supported_pairing_methods = 2;
inline int ChannelDescriptor_BluetoothService::_internal_supported_pairing_methods_size() const {
  return supported_pairing_methods_.size();
}
inline int ChannelDescriptor_BluetoothService::supported_pairing_methods_size() const {
  return _internal_supported_pairing_methods_size();
}
inline void ChannelDescriptor_BluetoothService::clear_supported_pairing_methods() {
  supported_pairing_methods_.Clear();
}
inline ::HU::BluetoothPairingMethod ChannelDescriptor_BluetoothService::_internal_supported_pairing_methods(int index) const {
  return static_cast< ::HU::BluetoothPairingMethod >(supported_pairing_methods_.Get(index));
}
inline ::HU::BluetoothPairingMethod ChannelDescriptor_BluetoothService::supported_pairing_methods(int index) const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
  return _internal_supported_pairing_methods(index);
}
inline void ChannelDescriptor_BluetoothService::set_supported_pairing_methods(int index, ::HU::BluetoothPairingMethod value) {
  assert(::HU::BluetoothPairingMethod_IsValid(value));
  supported_pairing_methods_.Set(index, value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
}
inline void ChannelDescriptor_BluetoothService::_internal_add_supported_pairing_methods(::HU::BluetoothPairingMethod value) {
  assert(::HU::BluetoothPairingMethod_IsValid(value));
  supported_pairing_methods_.Add(value);
}
inline void ChannelDescriptor_BluetoothService::add_supported_pairing_methods(::HU::BluetoothPairingMethod value) {
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
  _internal_add_supported_pairing_methods(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ChannelDescriptor_BluetoothService::supported_pairing_methods() const {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
  return supported_pairing_methods_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ChannelDescriptor_BluetoothService::_internal_mutable_supported_pairing_methods() {
  return &supported_pairing_methods_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ChannelDescriptor_BluetoothService::mutable_supported_pairing_methods() {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.BluetoothService.supported_pairing_methods)
  return _internal_mutable_supported_pairing_methods();
}

// -------------------------------------------------------------------

// ChannelDescriptor_NavigationStatusService_ImageOptions

// required int32 width = 1;
inline bool ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelDescriptor_NavigationStatusService_ImageOptions::has_width() const {
  return _internal_has_width();
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelDescriptor_NavigationStatusService_ImageOptions::width() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.width)
  return _internal_width();
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::set_width(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.width)
}

// required int32 height = 2;
inline bool ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChannelDescriptor_NavigationStatusService_ImageOptions::has_height() const {
  return _internal_has_height();
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelDescriptor_NavigationStatusService_ImageOptions::height() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.height)
  return _internal_height();
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::set_height(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.height)
}

// required int32 colour_depth_bits = 3;
inline bool ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_has_colour_depth_bits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChannelDescriptor_NavigationStatusService_ImageOptions::has_colour_depth_bits() const {
  return _internal_has_colour_depth_bits();
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::clear_colour_depth_bits() {
  colour_depth_bits_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_colour_depth_bits() const {
  return colour_depth_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelDescriptor_NavigationStatusService_ImageOptions::colour_depth_bits() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.colour_depth_bits)
  return _internal_colour_depth_bits();
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::_internal_set_colour_depth_bits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  colour_depth_bits_ = value;
}
inline void ChannelDescriptor_NavigationStatusService_ImageOptions::set_colour_depth_bits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_colour_depth_bits(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.ImageOptions.colour_depth_bits)
}

// -------------------------------------------------------------------

// ChannelDescriptor_NavigationStatusService

// required uint32 minimum_interval_ms = 1;
inline bool ChannelDescriptor_NavigationStatusService::_internal_has_minimum_interval_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChannelDescriptor_NavigationStatusService::has_minimum_interval_ms() const {
  return _internal_has_minimum_interval_ms();
}
inline void ChannelDescriptor_NavigationStatusService::clear_minimum_interval_ms() {
  minimum_interval_ms_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_NavigationStatusService::_internal_minimum_interval_ms() const {
  return minimum_interval_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor_NavigationStatusService::minimum_interval_ms() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.minimum_interval_ms)
  return _internal_minimum_interval_ms();
}
inline void ChannelDescriptor_NavigationStatusService::_internal_set_minimum_interval_ms(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  minimum_interval_ms_ = value;
}
inline void ChannelDescriptor_NavigationStatusService::set_minimum_interval_ms(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_minimum_interval_ms(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.minimum_interval_ms)
}

// required .HU.ChannelDescriptor.NavigationStatusService.CLUSTER_TYPE type = 2;
inline bool ChannelDescriptor_NavigationStatusService::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ChannelDescriptor_NavigationStatusService::has_type() const {
  return _internal_has_type();
}
inline void ChannelDescriptor_NavigationStatusService::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE ChannelDescriptor_NavigationStatusService::_internal_type() const {
  return static_cast< ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE >(type_);
}
inline ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE ChannelDescriptor_NavigationStatusService::type() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.type)
  return _internal_type();
}
inline void ChannelDescriptor_NavigationStatusService::_internal_set_type(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE value) {
  assert(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void ChannelDescriptor_NavigationStatusService::set_type(::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.NavigationStatusService.type)
}

// optional .HU.ChannelDescriptor.NavigationStatusService.ImageOptions image_options = 3;
inline bool ChannelDescriptor_NavigationStatusService::_internal_has_image_options() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || image_options_ != nullptr);
  return value;
}
inline bool ChannelDescriptor_NavigationStatusService::has_image_options() const {
  return _internal_has_image_options();
}
inline void ChannelDescriptor_NavigationStatusService::clear_image_options() {
  if (image_options_ != nullptr) image_options_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions& ChannelDescriptor_NavigationStatusService::_internal_image_options() const {
  const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* p = image_options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions*>(
      &::HU::_ChannelDescriptor_NavigationStatusService_ImageOptions_default_instance_);
}
inline const ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions& ChannelDescriptor_NavigationStatusService::image_options() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.NavigationStatusService.image_options)
  return _internal_image_options();
}
inline void ChannelDescriptor_NavigationStatusService::unsafe_arena_set_allocated_image_options(
    ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* image_options) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_options_);
  }
  image_options_ = image_options;
  if (image_options) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.NavigationStatusService.image_options)
}
inline ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* ChannelDescriptor_NavigationStatusService::release_image_options() {
  auto temp = unsafe_arena_release_image_options();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* ChannelDescriptor_NavigationStatusService::unsafe_arena_release_image_options() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.NavigationStatusService.image_options)
  _has_bits_[0] &= ~0x00000001u;
  ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* temp = image_options_;
  image_options_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* ChannelDescriptor_NavigationStatusService::_internal_mutable_image_options() {
  _has_bits_[0] |= 0x00000001u;
  if (image_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_NavigationStatusService_ImageOptions>(GetArena());
    image_options_ = p;
  }
  return image_options_;
}
inline ::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* ChannelDescriptor_NavigationStatusService::mutable_image_options() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.NavigationStatusService.image_options)
  return _internal_mutable_image_options();
}
inline void ChannelDescriptor_NavigationStatusService::set_allocated_image_options(::HU::ChannelDescriptor_NavigationStatusService_ImageOptions* image_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete image_options_;
  }
  if (image_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(image_options);
    if (message_arena != submessage_arena) {
      image_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_options, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_options_ = image_options;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.NavigationStatusService.image_options)
}

// -------------------------------------------------------------------

// ChannelDescriptor_PhoneStatusService

// -------------------------------------------------------------------

// ChannelDescriptor_VendorExtensionService

// optional string name = 1;
inline bool ChannelDescriptor_VendorExtensionService::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelDescriptor_VendorExtensionService::has_name() const {
  return _internal_has_name();
}
inline void ChannelDescriptor_VendorExtensionService::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChannelDescriptor_VendorExtensionService::name() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.VendorExtensionService.name)
  return _internal_name();
}
inline void ChannelDescriptor_VendorExtensionService::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.VendorExtensionService.name)
}
inline std::string* ChannelDescriptor_VendorExtensionService::mutable_name() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.VendorExtensionService.name)
  return _internal_mutable_name();
}
inline const std::string& ChannelDescriptor_VendorExtensionService::_internal_name() const {
  return name_.Get();
}
inline void ChannelDescriptor_VendorExtensionService::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChannelDescriptor_VendorExtensionService::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ChannelDescriptor.VendorExtensionService.name)
}
inline void ChannelDescriptor_VendorExtensionService::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ChannelDescriptor.VendorExtensionService.name)
}
inline void ChannelDescriptor_VendorExtensionService::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ChannelDescriptor.VendorExtensionService.name)
}
inline std::string* ChannelDescriptor_VendorExtensionService::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChannelDescriptor_VendorExtensionService::release_name() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.VendorExtensionService.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelDescriptor_VendorExtensionService::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.VendorExtensionService.name)
}
inline std::string* ChannelDescriptor_VendorExtensionService::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ChannelDescriptor.VendorExtensionService.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ChannelDescriptor_VendorExtensionService::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.VendorExtensionService.name)
}

// repeated string package_white_list = 2;
inline int ChannelDescriptor_VendorExtensionService::_internal_package_white_list_size() const {
  return package_white_list_.size();
}
inline int ChannelDescriptor_VendorExtensionService::package_white_list_size() const {
  return _internal_package_white_list_size();
}
inline void ChannelDescriptor_VendorExtensionService::clear_package_white_list() {
  package_white_list_.Clear();
}
inline std::string* ChannelDescriptor_VendorExtensionService::add_package_white_list() {
  // @@protoc_insertion_point(field_add_mutable:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  return _internal_add_package_white_list();
}
inline const std::string& ChannelDescriptor_VendorExtensionService::_internal_package_white_list(int index) const {
  return package_white_list_.Get(index);
}
inline const std::string& ChannelDescriptor_VendorExtensionService::package_white_list(int index) const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  return _internal_package_white_list(index);
}
inline std::string* ChannelDescriptor_VendorExtensionService::mutable_package_white_list(int index) {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  return package_white_list_.Mutable(index);
}
inline void ChannelDescriptor_VendorExtensionService::set_package_white_list(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  package_white_list_.Mutable(index)->assign(value);
}
inline void ChannelDescriptor_VendorExtensionService::set_package_white_list(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  package_white_list_.Mutable(index)->assign(std::move(value));
}
inline void ChannelDescriptor_VendorExtensionService::set_package_white_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  package_white_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::set_package_white_list(int index, const char* value, size_t size) {
  package_white_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline std::string* ChannelDescriptor_VendorExtensionService::_internal_add_package_white_list() {
  return package_white_list_.Add();
}
inline void ChannelDescriptor_VendorExtensionService::add_package_white_list(const std::string& value) {
  package_white_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::add_package_white_list(std::string&& value) {
  package_white_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::add_package_white_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  package_white_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline void ChannelDescriptor_VendorExtensionService::add_package_white_list(const char* value, size_t size) {
  package_white_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ChannelDescriptor_VendorExtensionService::package_white_list() const {
  // @@protoc_insertion_point(field_list:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  return package_white_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ChannelDescriptor_VendorExtensionService::mutable_package_white_list() {
  // @@protoc_insertion_point(field_mutable_list:HU.ChannelDescriptor.VendorExtensionService.package_white_list)
  return &package_white_list_;
}

// optional bytes data = 3;
inline bool ChannelDescriptor_VendorExtensionService::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChannelDescriptor_VendorExtensionService::has_data() const {
  return _internal_has_data();
}
inline void ChannelDescriptor_VendorExtensionService::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChannelDescriptor_VendorExtensionService::data() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.VendorExtensionService.data)
  return _internal_data();
}
inline void ChannelDescriptor_VendorExtensionService::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.VendorExtensionService.data)
}
inline std::string* ChannelDescriptor_VendorExtensionService::mutable_data() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.VendorExtensionService.data)
  return _internal_mutable_data();
}
inline const std::string& ChannelDescriptor_VendorExtensionService::_internal_data() const {
  return data_.Get();
}
inline void ChannelDescriptor_VendorExtensionService::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChannelDescriptor_VendorExtensionService::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ChannelDescriptor.VendorExtensionService.data)
}
inline void ChannelDescriptor_VendorExtensionService::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ChannelDescriptor.VendorExtensionService.data)
}
inline void ChannelDescriptor_VendorExtensionService::set_data(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ChannelDescriptor.VendorExtensionService.data)
}
inline std::string* ChannelDescriptor_VendorExtensionService::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000002u;
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChannelDescriptor_VendorExtensionService::release_data() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.VendorExtensionService.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelDescriptor_VendorExtensionService::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.VendorExtensionService.data)
}
inline std::string* ChannelDescriptor_VendorExtensionService::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ChannelDescriptor.VendorExtensionService.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ChannelDescriptor_VendorExtensionService::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.VendorExtensionService.data)
}

// -------------------------------------------------------------------

// ChannelDescriptor_GenericNotificationService

// optional string name = 1;
inline bool ChannelDescriptor_GenericNotificationService::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelDescriptor_GenericNotificationService::has_name() const {
  return _internal_has_name();
}
inline void ChannelDescriptor_GenericNotificationService::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChannelDescriptor_GenericNotificationService::name() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.GenericNotificationService.name)
  return _internal_name();
}
inline void ChannelDescriptor_GenericNotificationService::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.GenericNotificationService.name)
}
inline std::string* ChannelDescriptor_GenericNotificationService::mutable_name() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.GenericNotificationService.name)
  return _internal_mutable_name();
}
inline const std::string& ChannelDescriptor_GenericNotificationService::_internal_name() const {
  return name_.Get();
}
inline void ChannelDescriptor_GenericNotificationService::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChannelDescriptor_GenericNotificationService::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ChannelDescriptor.GenericNotificationService.name)
}
inline void ChannelDescriptor_GenericNotificationService::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ChannelDescriptor.GenericNotificationService.name)
}
inline void ChannelDescriptor_GenericNotificationService::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ChannelDescriptor.GenericNotificationService.name)
}
inline std::string* ChannelDescriptor_GenericNotificationService::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChannelDescriptor_GenericNotificationService::release_name() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.GenericNotificationService.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChannelDescriptor_GenericNotificationService::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.GenericNotificationService.name)
}
inline std::string* ChannelDescriptor_GenericNotificationService::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ChannelDescriptor.GenericNotificationService.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ChannelDescriptor_GenericNotificationService::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.GenericNotificationService.name)
}

// -------------------------------------------------------------------

// ChannelDescriptor

// required uint32 channel_id = 1;
inline bool ChannelDescriptor::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ChannelDescriptor::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void ChannelDescriptor::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor::_internal_channel_id() const {
  return channel_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ChannelDescriptor::channel_id() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.channel_id)
  return _internal_channel_id();
}
inline void ChannelDescriptor::_internal_set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  channel_id_ = value;
}
inline void ChannelDescriptor::set_channel_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:HU.ChannelDescriptor.channel_id)
}

// optional .HU.ChannelDescriptor.SensorChannel sensor_channel = 2;
inline bool ChannelDescriptor::_internal_has_sensor_channel() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sensor_channel_ != nullptr);
  return value;
}
inline bool ChannelDescriptor::has_sensor_channel() const {
  return _internal_has_sensor_channel();
}
inline void ChannelDescriptor::clear_sensor_channel() {
  if (sensor_channel_ != nullptr) sensor_channel_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::HU::ChannelDescriptor_SensorChannel& ChannelDescriptor::_internal_sensor_channel() const {
  const ::HU::ChannelDescriptor_SensorChannel* p = sensor_channel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_SensorChannel*>(
      &::HU::_ChannelDescriptor_SensorChannel_default_instance_);
}
inline const ::HU::ChannelDescriptor_SensorChannel& ChannelDescriptor::sensor_channel() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.sensor_channel)
  return _internal_sensor_channel();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_sensor_channel(
    ::HU::ChannelDescriptor_SensorChannel* sensor_channel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_channel_);
  }
  sensor_channel_ = sensor_channel;
  if (sensor_channel) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.sensor_channel)
}
inline ::HU::ChannelDescriptor_SensorChannel* ChannelDescriptor::release_sensor_channel() {
  auto temp = unsafe_arena_release_sensor_channel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_SensorChannel* ChannelDescriptor::unsafe_arena_release_sensor_channel() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.sensor_channel)
  _has_bits_[0] &= ~0x00000001u;
  ::HU::ChannelDescriptor_SensorChannel* temp = sensor_channel_;
  sensor_channel_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_SensorChannel* ChannelDescriptor::_internal_mutable_sensor_channel() {
  _has_bits_[0] |= 0x00000001u;
  if (sensor_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_SensorChannel>(GetArena());
    sensor_channel_ = p;
  }
  return sensor_channel_;
}
inline ::HU::ChannelDescriptor_SensorChannel* ChannelDescriptor::mutable_sensor_channel() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.sensor_channel)
  return _internal_mutable_sensor_channel();
}
inline void ChannelDescriptor::set_allocated_sensor_channel(::HU::ChannelDescriptor_SensorChannel* sensor_channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sensor_channel_;
  }
  if (sensor_channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sensor_channel);
    if (message_arena != submessage_arena) {
      sensor_channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_channel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sensor_channel_ = sensor_channel;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.sensor_channel)
}

// optional .HU.ChannelDescriptor.OutputStreamChannel output_stream_channel = 3;
inline bool ChannelDescriptor::_internal_has_output_stream_channel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || output_stream_channel_ != nullptr);
  return value;
}
inline bool ChannelDescriptor::has_output_stream_channel() const {
  return _internal_has_output_stream_channel();
}
inline void ChannelDescriptor::clear_output_stream_channel() {
  if (output_stream_channel_ != nullptr) output_stream_channel_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::HU::ChannelDescriptor_OutputStreamChannel& ChannelDescriptor::_internal_output_stream_channel() const {
  const ::HU::ChannelDescriptor_OutputStreamChannel* p = output_stream_channel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_OutputStreamChannel*>(
      &::HU::_ChannelDescriptor_OutputStreamChannel_default_instance_);
}
inline const ::HU::ChannelDescriptor_OutputStreamChannel& ChannelDescriptor::output_stream_channel() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.output_stream_channel)
  return _internal_output_stream_channel();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_output_stream_channel(
    ::HU::ChannelDescriptor_OutputStreamChannel* output_stream_channel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_stream_channel_);
  }
  output_stream_channel_ = output_stream_channel;
  if (output_stream_channel) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.output_stream_channel)
}
inline ::HU::ChannelDescriptor_OutputStreamChannel* ChannelDescriptor::release_output_stream_channel() {
  auto temp = unsafe_arena_release_output_stream_channel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel* ChannelDescriptor::unsafe_arena_release_output_stream_channel() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.output_stream_channel)
  _has_bits_[0] &= ~0x00000002u;
  ::HU::ChannelDescriptor_OutputStreamChannel* temp = output_stream_channel_;
  output_stream_channel_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel* ChannelDescriptor::_internal_mutable_output_stream_channel() {
  _has_bits_[0] |= 0x00000002u;
  if (output_stream_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_OutputStreamChannel>(GetArena());
    output_stream_channel_ = p;
  }
  return output_stream_channel_;
}
inline ::HU::ChannelDescriptor_OutputStreamChannel* ChannelDescriptor::mutable_output_stream_channel() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.output_stream_channel)
  return _internal_mutable_output_stream_channel();
}
inline void ChannelDescriptor::set_allocated_output_stream_channel(::HU::ChannelDescriptor_OutputStreamChannel* output_stream_channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete output_stream_channel_;
  }
  if (output_stream_channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(output_stream_channel);
    if (message_arena != submessage_arena) {
      output_stream_channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output_stream_channel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  output_stream_channel_ = output_stream_channel;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.output_stream_channel)
}

// optional .HU.ChannelDescriptor.InputEventChannel input_event_channel = 4;
inline bool ChannelDescriptor::_internal_has_input_event_channel() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || input_event_channel_ != nullptr);
  return value;
}
inline bool ChannelDescriptor::has_input_event_channel() const {
  return _internal_has_input_event_channel();
}
inline void ChannelDescriptor::clear_input_event_channel() {
  if (input_event_channel_ != nullptr) input_event_channel_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::HU::ChannelDescriptor_InputEventChannel& ChannelDescriptor::_internal_input_event_channel() const {
  const ::HU::ChannelDescriptor_InputEventChannel* p = input_event_channel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_InputEventChannel*>(
      &::HU::_ChannelDescriptor_InputEventChannel_default_instance_);
}
inline const ::HU::ChannelDescriptor_InputEventChannel& ChannelDescriptor::input_event_channel() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.input_event_channel)
  return _internal_input_event_channel();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_input_event_channel(
    ::HU::ChannelDescriptor_InputEventChannel* input_event_channel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_event_channel_);
  }
  input_event_channel_ = input_event_channel;
  if (input_event_channel) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.input_event_channel)
}
inline ::HU::ChannelDescriptor_InputEventChannel* ChannelDescriptor::release_input_event_channel() {
  auto temp = unsafe_arena_release_input_event_channel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_InputEventChannel* ChannelDescriptor::unsafe_arena_release_input_event_channel() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.input_event_channel)
  _has_bits_[0] &= ~0x00000004u;
  ::HU::ChannelDescriptor_InputEventChannel* temp = input_event_channel_;
  input_event_channel_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_InputEventChannel* ChannelDescriptor::_internal_mutable_input_event_channel() {
  _has_bits_[0] |= 0x00000004u;
  if (input_event_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_InputEventChannel>(GetArena());
    input_event_channel_ = p;
  }
  return input_event_channel_;
}
inline ::HU::ChannelDescriptor_InputEventChannel* ChannelDescriptor::mutable_input_event_channel() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.input_event_channel)
  return _internal_mutable_input_event_channel();
}
inline void ChannelDescriptor::set_allocated_input_event_channel(::HU::ChannelDescriptor_InputEventChannel* input_event_channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete input_event_channel_;
  }
  if (input_event_channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(input_event_channel);
    if (message_arena != submessage_arena) {
      input_event_channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_event_channel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  input_event_channel_ = input_event_channel;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.input_event_channel)
}

// optional .HU.ChannelDescriptor.InputStreamChannel input_stream_channel = 5;
inline bool ChannelDescriptor::_internal_has_input_stream_channel() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || input_stream_channel_ != nullptr);
  return value;
}
inline bool ChannelDescriptor::has_input_stream_channel() const {
  return _internal_has_input_stream_channel();
}
inline void ChannelDescriptor::clear_input_stream_channel() {
  if (input_stream_channel_ != nullptr) input_stream_channel_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::HU::ChannelDescriptor_InputStreamChannel& ChannelDescriptor::_internal_input_stream_channel() const {
  const ::HU::ChannelDescriptor_InputStreamChannel* p = input_stream_channel_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_InputStreamChannel*>(
      &::HU::_ChannelDescriptor_InputStreamChannel_default_instance_);
}
inline const ::HU::ChannelDescriptor_InputStreamChannel& ChannelDescriptor::input_stream_channel() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.input_stream_channel)
  return _internal_input_stream_channel();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_input_stream_channel(
    ::HU::ChannelDescriptor_InputStreamChannel* input_stream_channel) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_stream_channel_);
  }
  input_stream_channel_ = input_stream_channel;
  if (input_stream_channel) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.input_stream_channel)
}
inline ::HU::ChannelDescriptor_InputStreamChannel* ChannelDescriptor::release_input_stream_channel() {
  auto temp = unsafe_arena_release_input_stream_channel();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_InputStreamChannel* ChannelDescriptor::unsafe_arena_release_input_stream_channel() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.input_stream_channel)
  _has_bits_[0] &= ~0x00000008u;
  ::HU::ChannelDescriptor_InputStreamChannel* temp = input_stream_channel_;
  input_stream_channel_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_InputStreamChannel* ChannelDescriptor::_internal_mutable_input_stream_channel() {
  _has_bits_[0] |= 0x00000008u;
  if (input_stream_channel_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_InputStreamChannel>(GetArena());
    input_stream_channel_ = p;
  }
  return input_stream_channel_;
}
inline ::HU::ChannelDescriptor_InputStreamChannel* ChannelDescriptor::mutable_input_stream_channel() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.input_stream_channel)
  return _internal_mutable_input_stream_channel();
}
inline void ChannelDescriptor::set_allocated_input_stream_channel(::HU::ChannelDescriptor_InputStreamChannel* input_stream_channel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete input_stream_channel_;
  }
  if (input_stream_channel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(input_stream_channel);
    if (message_arena != submessage_arena) {
      input_stream_channel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input_stream_channel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  input_stream_channel_ = input_stream_channel;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.input_stream_channel)
}

// optional .HU.ChannelDescriptor.BluetoothService bluetooth_service = 6;
inline bool ChannelDescriptor::_internal_has_bluetooth_service() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || bluetooth_service_ != nullptr);
  return value;
}
inline bool ChannelDescriptor::has_bluetooth_service() const {
  return _internal_has_bluetooth_service();
}
inline void ChannelDescriptor::clear_bluetooth_service() {
  if (bluetooth_service_ != nullptr) bluetooth_service_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::HU::ChannelDescriptor_BluetoothService& ChannelDescriptor::_internal_bluetooth_service() const {
  const ::HU::ChannelDescriptor_BluetoothService* p = bluetooth_service_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_BluetoothService*>(
      &::HU::_ChannelDescriptor_BluetoothService_default_instance_);
}
inline const ::HU::ChannelDescriptor_BluetoothService& ChannelDescriptor::bluetooth_service() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.bluetooth_service)
  return _internal_bluetooth_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_bluetooth_service(
    ::HU::ChannelDescriptor_BluetoothService* bluetooth_service) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bluetooth_service_);
  }
  bluetooth_service_ = bluetooth_service;
  if (bluetooth_service) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.bluetooth_service)
}
inline ::HU::ChannelDescriptor_BluetoothService* ChannelDescriptor::release_bluetooth_service() {
  auto temp = unsafe_arena_release_bluetooth_service();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_BluetoothService* ChannelDescriptor::unsafe_arena_release_bluetooth_service() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.bluetooth_service)
  _has_bits_[0] &= ~0x00000010u;
  ::HU::ChannelDescriptor_BluetoothService* temp = bluetooth_service_;
  bluetooth_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_BluetoothService* ChannelDescriptor::_internal_mutable_bluetooth_service() {
  _has_bits_[0] |= 0x00000010u;
  if (bluetooth_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_BluetoothService>(GetArena());
    bluetooth_service_ = p;
  }
  return bluetooth_service_;
}
inline ::HU::ChannelDescriptor_BluetoothService* ChannelDescriptor::mutable_bluetooth_service() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.bluetooth_service)
  return _internal_mutable_bluetooth_service();
}
inline void ChannelDescriptor::set_allocated_bluetooth_service(::HU::ChannelDescriptor_BluetoothService* bluetooth_service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bluetooth_service_;
  }
  if (bluetooth_service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bluetooth_service);
    if (message_arena != submessage_arena) {
      bluetooth_service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bluetooth_service, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  bluetooth_service_ = bluetooth_service;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.bluetooth_service)
}

// optional .HU.ChannelDescriptor.NavigationStatusService navigation_status_service = 8;
inline bool ChannelDescriptor::_internal_has_navigation_status_service() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || navigation_status_service_ != nullptr);
  return value;
}
inline bool ChannelDescriptor::has_navigation_status_service() const {
  return _internal_has_navigation_status_service();
}
inline void ChannelDescriptor::clear_navigation_status_service() {
  if (navigation_status_service_ != nullptr) navigation_status_service_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::HU::ChannelDescriptor_NavigationStatusService& ChannelDescriptor::_internal_navigation_status_service() const {
  const ::HU::ChannelDescriptor_NavigationStatusService* p = navigation_status_service_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_NavigationStatusService*>(
      &::HU::_ChannelDescriptor_NavigationStatusService_default_instance_);
}
inline const ::HU::ChannelDescriptor_NavigationStatusService& ChannelDescriptor::navigation_status_service() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.navigation_status_service)
  return _internal_navigation_status_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_navigation_status_service(
    ::HU::ChannelDescriptor_NavigationStatusService* navigation_status_service) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(navigation_status_service_);
  }
  navigation_status_service_ = navigation_status_service;
  if (navigation_status_service) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.navigation_status_service)
}
inline ::HU::ChannelDescriptor_NavigationStatusService* ChannelDescriptor::release_navigation_status_service() {
  auto temp = unsafe_arena_release_navigation_status_service();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_NavigationStatusService* ChannelDescriptor::unsafe_arena_release_navigation_status_service() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.navigation_status_service)
  _has_bits_[0] &= ~0x00000020u;
  ::HU::ChannelDescriptor_NavigationStatusService* temp = navigation_status_service_;
  navigation_status_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_NavigationStatusService* ChannelDescriptor::_internal_mutable_navigation_status_service() {
  _has_bits_[0] |= 0x00000020u;
  if (navigation_status_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_NavigationStatusService>(GetArena());
    navigation_status_service_ = p;
  }
  return navigation_status_service_;
}
inline ::HU::ChannelDescriptor_NavigationStatusService* ChannelDescriptor::mutable_navigation_status_service() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.navigation_status_service)
  return _internal_mutable_navigation_status_service();
}
inline void ChannelDescriptor::set_allocated_navigation_status_service(::HU::ChannelDescriptor_NavigationStatusService* navigation_status_service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete navigation_status_service_;
  }
  if (navigation_status_service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(navigation_status_service);
    if (message_arena != submessage_arena) {
      navigation_status_service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, navigation_status_service, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  navigation_status_service_ = navigation_status_service;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.navigation_status_service)
}

// optional .HU.ChannelDescriptor.PhoneStatusService phone_status_service = 10;
inline bool ChannelDescriptor::_internal_has_phone_status_service() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || phone_status_service_ != nullptr);
  return value;
}
inline bool ChannelDescriptor::has_phone_status_service() const {
  return _internal_has_phone_status_service();
}
inline void ChannelDescriptor::clear_phone_status_service() {
  if (phone_status_service_ != nullptr) phone_status_service_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::HU::ChannelDescriptor_PhoneStatusService& ChannelDescriptor::_internal_phone_status_service() const {
  const ::HU::ChannelDescriptor_PhoneStatusService* p = phone_status_service_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_PhoneStatusService*>(
      &::HU::_ChannelDescriptor_PhoneStatusService_default_instance_);
}
inline const ::HU::ChannelDescriptor_PhoneStatusService& ChannelDescriptor::phone_status_service() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.phone_status_service)
  return _internal_phone_status_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_phone_status_service(
    ::HU::ChannelDescriptor_PhoneStatusService* phone_status_service) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phone_status_service_);
  }
  phone_status_service_ = phone_status_service;
  if (phone_status_service) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.phone_status_service)
}
inline ::HU::ChannelDescriptor_PhoneStatusService* ChannelDescriptor::release_phone_status_service() {
  auto temp = unsafe_arena_release_phone_status_service();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_PhoneStatusService* ChannelDescriptor::unsafe_arena_release_phone_status_service() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.phone_status_service)
  _has_bits_[0] &= ~0x00000040u;
  ::HU::ChannelDescriptor_PhoneStatusService* temp = phone_status_service_;
  phone_status_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_PhoneStatusService* ChannelDescriptor::_internal_mutable_phone_status_service() {
  _has_bits_[0] |= 0x00000040u;
  if (phone_status_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_PhoneStatusService>(GetArena());
    phone_status_service_ = p;
  }
  return phone_status_service_;
}
inline ::HU::ChannelDescriptor_PhoneStatusService* ChannelDescriptor::mutable_phone_status_service() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.phone_status_service)
  return _internal_mutable_phone_status_service();
}
inline void ChannelDescriptor::set_allocated_phone_status_service(::HU::ChannelDescriptor_PhoneStatusService* phone_status_service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete phone_status_service_;
  }
  if (phone_status_service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(phone_status_service);
    if (message_arena != submessage_arena) {
      phone_status_service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phone_status_service, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  phone_status_service_ = phone_status_service;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.phone_status_service)
}

// optional .HU.ChannelDescriptor.VendorExtensionService vendor_extension_service = 12;
inline bool ChannelDescriptor::_internal_has_vendor_extension_service() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || vendor_extension_service_ != nullptr);
  return value;
}
inline bool ChannelDescriptor::has_vendor_extension_service() const {
  return _internal_has_vendor_extension_service();
}
inline void ChannelDescriptor::clear_vendor_extension_service() {
  if (vendor_extension_service_ != nullptr) vendor_extension_service_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::HU::ChannelDescriptor_VendorExtensionService& ChannelDescriptor::_internal_vendor_extension_service() const {
  const ::HU::ChannelDescriptor_VendorExtensionService* p = vendor_extension_service_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_VendorExtensionService*>(
      &::HU::_ChannelDescriptor_VendorExtensionService_default_instance_);
}
inline const ::HU::ChannelDescriptor_VendorExtensionService& ChannelDescriptor::vendor_extension_service() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.vendor_extension_service)
  return _internal_vendor_extension_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_vendor_extension_service(
    ::HU::ChannelDescriptor_VendorExtensionService* vendor_extension_service) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vendor_extension_service_);
  }
  vendor_extension_service_ = vendor_extension_service;
  if (vendor_extension_service) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.vendor_extension_service)
}
inline ::HU::ChannelDescriptor_VendorExtensionService* ChannelDescriptor::release_vendor_extension_service() {
  auto temp = unsafe_arena_release_vendor_extension_service();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_VendorExtensionService* ChannelDescriptor::unsafe_arena_release_vendor_extension_service() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.vendor_extension_service)
  _has_bits_[0] &= ~0x00000080u;
  ::HU::ChannelDescriptor_VendorExtensionService* temp = vendor_extension_service_;
  vendor_extension_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_VendorExtensionService* ChannelDescriptor::_internal_mutable_vendor_extension_service() {
  _has_bits_[0] |= 0x00000080u;
  if (vendor_extension_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_VendorExtensionService>(GetArena());
    vendor_extension_service_ = p;
  }
  return vendor_extension_service_;
}
inline ::HU::ChannelDescriptor_VendorExtensionService* ChannelDescriptor::mutable_vendor_extension_service() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.vendor_extension_service)
  return _internal_mutable_vendor_extension_service();
}
inline void ChannelDescriptor::set_allocated_vendor_extension_service(::HU::ChannelDescriptor_VendorExtensionService* vendor_extension_service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vendor_extension_service_;
  }
  if (vendor_extension_service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vendor_extension_service);
    if (message_arena != submessage_arena) {
      vendor_extension_service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vendor_extension_service, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  vendor_extension_service_ = vendor_extension_service;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.vendor_extension_service)
}

// optional .HU.ChannelDescriptor.GenericNotificationService generic_notification_service = 13;
inline bool ChannelDescriptor::_internal_has_generic_notification_service() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || generic_notification_service_ != nullptr);
  return value;
}
inline bool ChannelDescriptor::has_generic_notification_service() const {
  return _internal_has_generic_notification_service();
}
inline void ChannelDescriptor::clear_generic_notification_service() {
  if (generic_notification_service_ != nullptr) generic_notification_service_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::HU::ChannelDescriptor_GenericNotificationService& ChannelDescriptor::_internal_generic_notification_service() const {
  const ::HU::ChannelDescriptor_GenericNotificationService* p = generic_notification_service_;
  return p != nullptr ? *p : *reinterpret_cast<const ::HU::ChannelDescriptor_GenericNotificationService*>(
      &::HU::_ChannelDescriptor_GenericNotificationService_default_instance_);
}
inline const ::HU::ChannelDescriptor_GenericNotificationService& ChannelDescriptor::generic_notification_service() const {
  // @@protoc_insertion_point(field_get:HU.ChannelDescriptor.generic_notification_service)
  return _internal_generic_notification_service();
}
inline void ChannelDescriptor::unsafe_arena_set_allocated_generic_notification_service(
    ::HU::ChannelDescriptor_GenericNotificationService* generic_notification_service) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(generic_notification_service_);
  }
  generic_notification_service_ = generic_notification_service;
  if (generic_notification_service) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ChannelDescriptor.generic_notification_service)
}
inline ::HU::ChannelDescriptor_GenericNotificationService* ChannelDescriptor::release_generic_notification_service() {
  auto temp = unsafe_arena_release_generic_notification_service();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HU::ChannelDescriptor_GenericNotificationService* ChannelDescriptor::unsafe_arena_release_generic_notification_service() {
  // @@protoc_insertion_point(field_release:HU.ChannelDescriptor.generic_notification_service)
  _has_bits_[0] &= ~0x00000100u;
  ::HU::ChannelDescriptor_GenericNotificationService* temp = generic_notification_service_;
  generic_notification_service_ = nullptr;
  return temp;
}
inline ::HU::ChannelDescriptor_GenericNotificationService* ChannelDescriptor::_internal_mutable_generic_notification_service() {
  _has_bits_[0] |= 0x00000100u;
  if (generic_notification_service_ == nullptr) {
    auto* p = CreateMaybeMessage<::HU::ChannelDescriptor_GenericNotificationService>(GetArena());
    generic_notification_service_ = p;
  }
  return generic_notification_service_;
}
inline ::HU::ChannelDescriptor_GenericNotificationService* ChannelDescriptor::mutable_generic_notification_service() {
  // @@protoc_insertion_point(field_mutable:HU.ChannelDescriptor.generic_notification_service)
  return _internal_mutable_generic_notification_service();
}
inline void ChannelDescriptor::set_allocated_generic_notification_service(::HU::ChannelDescriptor_GenericNotificationService* generic_notification_service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete generic_notification_service_;
  }
  if (generic_notification_service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(generic_notification_service);
    if (message_arena != submessage_arena) {
      generic_notification_service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, generic_notification_service, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  generic_notification_service_ = generic_notification_service;
  // @@protoc_insertion_point(field_set_allocated:HU.ChannelDescriptor.generic_notification_service)
}

// -------------------------------------------------------------------

// ServiceDiscoveryRequest

// optional string phone_name = 4;
inline bool ServiceDiscoveryRequest::_internal_has_phone_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServiceDiscoveryRequest::has_phone_name() const {
  return _internal_has_phone_name();
}
inline void ServiceDiscoveryRequest::clear_phone_name() {
  phone_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceDiscoveryRequest::phone_name() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryRequest.phone_name)
  return _internal_phone_name();
}
inline void ServiceDiscoveryRequest::set_phone_name(const std::string& value) {
  _internal_set_phone_name(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryRequest.phone_name)
}
inline std::string* ServiceDiscoveryRequest::mutable_phone_name() {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryRequest.phone_name)
  return _internal_mutable_phone_name();
}
inline const std::string& ServiceDiscoveryRequest::_internal_phone_name() const {
  return phone_name_.Get();
}
inline void ServiceDiscoveryRequest::_internal_set_phone_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  phone_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServiceDiscoveryRequest::set_phone_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  phone_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ServiceDiscoveryRequest.phone_name)
}
inline void ServiceDiscoveryRequest::set_phone_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  phone_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ServiceDiscoveryRequest.phone_name)
}
inline void ServiceDiscoveryRequest::set_phone_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  phone_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ServiceDiscoveryRequest.phone_name)
}
inline std::string* ServiceDiscoveryRequest::_internal_mutable_phone_name() {
  _has_bits_[0] |= 0x00000001u;
  return phone_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServiceDiscoveryRequest::release_phone_name() {
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryRequest.phone_name)
  if (!_internal_has_phone_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return phone_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServiceDiscoveryRequest::set_allocated_phone_name(std::string* phone_name) {
  if (phone_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  phone_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phone_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryRequest.phone_name)
}
inline std::string* ServiceDiscoveryRequest::unsafe_arena_release_phone_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ServiceDiscoveryRequest.phone_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return phone_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServiceDiscoveryRequest::unsafe_arena_set_allocated_phone_name(
    std::string* phone_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (phone_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  phone_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      phone_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ServiceDiscoveryRequest.phone_name)
}

// -------------------------------------------------------------------

// ServiceDiscoveryResponse

// repeated .HU.ChannelDescriptor channels = 1;
inline int ServiceDiscoveryResponse::_internal_channels_size() const {
  return channels_.size();
}
inline int ServiceDiscoveryResponse::channels_size() const {
  return _internal_channels_size();
}
inline void ServiceDiscoveryResponse::clear_channels() {
  channels_.Clear();
}
inline ::HU::ChannelDescriptor* ServiceDiscoveryResponse::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.channels)
  return channels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor >*
ServiceDiscoveryResponse::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:HU.ServiceDiscoveryResponse.channels)
  return &channels_;
}
inline const ::HU::ChannelDescriptor& ServiceDiscoveryResponse::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline const ::HU::ChannelDescriptor& ServiceDiscoveryResponse::channels(int index) const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.channels)
  return _internal_channels(index);
}
inline ::HU::ChannelDescriptor* ServiceDiscoveryResponse::_internal_add_channels() {
  return channels_.Add();
}
inline ::HU::ChannelDescriptor* ServiceDiscoveryResponse::add_channels() {
  // @@protoc_insertion_point(field_add:HU.ServiceDiscoveryResponse.channels)
  return _internal_add_channels();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::ChannelDescriptor >&
ServiceDiscoveryResponse::channels() const {
  // @@protoc_insertion_point(field_list:HU.ServiceDiscoveryResponse.channels)
  return channels_;
}

// required string head_unit_name = 2;
inline bool ServiceDiscoveryResponse::_internal_has_head_unit_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_head_unit_name() const {
  return _internal_has_head_unit_name();
}
inline void ServiceDiscoveryResponse::clear_head_unit_name() {
  head_unit_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServiceDiscoveryResponse::head_unit_name() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.head_unit_name)
  return _internal_head_unit_name();
}
inline void ServiceDiscoveryResponse::set_head_unit_name(const std::string& value) {
  _internal_set_head_unit_name(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.head_unit_name)
}
inline std::string* ServiceDiscoveryResponse::mutable_head_unit_name() {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.head_unit_name)
  return _internal_mutable_head_unit_name();
}
inline const std::string& ServiceDiscoveryResponse::_internal_head_unit_name() const {
  return head_unit_name_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_head_unit_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  head_unit_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServiceDiscoveryResponse::set_head_unit_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  head_unit_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ServiceDiscoveryResponse.head_unit_name)
}
inline void ServiceDiscoveryResponse::set_head_unit_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  head_unit_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ServiceDiscoveryResponse.head_unit_name)
}
inline void ServiceDiscoveryResponse::set_head_unit_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  head_unit_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ServiceDiscoveryResponse.head_unit_name)
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_head_unit_name() {
  _has_bits_[0] |= 0x00000001u;
  return head_unit_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_head_unit_name() {
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.head_unit_name)
  if (!_internal_has_head_unit_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return head_unit_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServiceDiscoveryResponse::set_allocated_head_unit_name(std::string* head_unit_name) {
  if (head_unit_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  head_unit_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), head_unit_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.head_unit_name)
}
inline std::string* ServiceDiscoveryResponse::unsafe_arena_release_head_unit_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ServiceDiscoveryResponse.head_unit_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return head_unit_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServiceDiscoveryResponse::unsafe_arena_set_allocated_head_unit_name(
    std::string* head_unit_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (head_unit_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  head_unit_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      head_unit_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ServiceDiscoveryResponse.head_unit_name)
}

// required string car_model = 3;
inline bool ServiceDiscoveryResponse::_internal_has_car_model() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_car_model() const {
  return _internal_has_car_model();
}
inline void ServiceDiscoveryResponse::clear_car_model() {
  car_model_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServiceDiscoveryResponse::car_model() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.car_model)
  return _internal_car_model();
}
inline void ServiceDiscoveryResponse::set_car_model(const std::string& value) {
  _internal_set_car_model(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.car_model)
}
inline std::string* ServiceDiscoveryResponse::mutable_car_model() {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.car_model)
  return _internal_mutable_car_model();
}
inline const std::string& ServiceDiscoveryResponse::_internal_car_model() const {
  return car_model_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_car_model(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  car_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServiceDiscoveryResponse::set_car_model(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  car_model_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ServiceDiscoveryResponse.car_model)
}
inline void ServiceDiscoveryResponse::set_car_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  car_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ServiceDiscoveryResponse.car_model)
}
inline void ServiceDiscoveryResponse::set_car_model(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  car_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ServiceDiscoveryResponse.car_model)
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_car_model() {
  _has_bits_[0] |= 0x00000002u;
  return car_model_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_car_model() {
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.car_model)
  if (!_internal_has_car_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return car_model_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServiceDiscoveryResponse::set_allocated_car_model(std::string* car_model) {
  if (car_model != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  car_model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), car_model,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.car_model)
}
inline std::string* ServiceDiscoveryResponse::unsafe_arena_release_car_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ServiceDiscoveryResponse.car_model)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return car_model_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServiceDiscoveryResponse::unsafe_arena_set_allocated_car_model(
    std::string* car_model) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (car_model != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  car_model_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      car_model, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ServiceDiscoveryResponse.car_model)
}

// required string car_year = 4;
inline bool ServiceDiscoveryResponse::_internal_has_car_year() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_car_year() const {
  return _internal_has_car_year();
}
inline void ServiceDiscoveryResponse::clear_car_year() {
  car_year_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ServiceDiscoveryResponse::car_year() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.car_year)
  return _internal_car_year();
}
inline void ServiceDiscoveryResponse::set_car_year(const std::string& value) {
  _internal_set_car_year(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.car_year)
}
inline std::string* ServiceDiscoveryResponse::mutable_car_year() {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.car_year)
  return _internal_mutable_car_year();
}
inline const std::string& ServiceDiscoveryResponse::_internal_car_year() const {
  return car_year_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_car_year(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  car_year_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServiceDiscoveryResponse::set_car_year(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  car_year_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ServiceDiscoveryResponse.car_year)
}
inline void ServiceDiscoveryResponse::set_car_year(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  car_year_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ServiceDiscoveryResponse.car_year)
}
inline void ServiceDiscoveryResponse::set_car_year(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  car_year_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ServiceDiscoveryResponse.car_year)
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_car_year() {
  _has_bits_[0] |= 0x00000004u;
  return car_year_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_car_year() {
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.car_year)
  if (!_internal_has_car_year()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return car_year_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServiceDiscoveryResponse::set_allocated_car_year(std::string* car_year) {
  if (car_year != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  car_year_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), car_year,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.car_year)
}
inline std::string* ServiceDiscoveryResponse::unsafe_arena_release_car_year() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ServiceDiscoveryResponse.car_year)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return car_year_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServiceDiscoveryResponse::unsafe_arena_set_allocated_car_year(
    std::string* car_year) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (car_year != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  car_year_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      car_year, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ServiceDiscoveryResponse.car_year)
}

// required string car_serial = 5;
inline bool ServiceDiscoveryResponse::_internal_has_car_serial() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_car_serial() const {
  return _internal_has_car_serial();
}
inline void ServiceDiscoveryResponse::clear_car_serial() {
  car_serial_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ServiceDiscoveryResponse::car_serial() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.car_serial)
  return _internal_car_serial();
}
inline void ServiceDiscoveryResponse::set_car_serial(const std::string& value) {
  _internal_set_car_serial(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.car_serial)
}
inline std::string* ServiceDiscoveryResponse::mutable_car_serial() {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.car_serial)
  return _internal_mutable_car_serial();
}
inline const std::string& ServiceDiscoveryResponse::_internal_car_serial() const {
  return car_serial_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_car_serial(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  car_serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServiceDiscoveryResponse::set_car_serial(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  car_serial_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ServiceDiscoveryResponse.car_serial)
}
inline void ServiceDiscoveryResponse::set_car_serial(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  car_serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ServiceDiscoveryResponse.car_serial)
}
inline void ServiceDiscoveryResponse::set_car_serial(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  car_serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ServiceDiscoveryResponse.car_serial)
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_car_serial() {
  _has_bits_[0] |= 0x00000008u;
  return car_serial_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_car_serial() {
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.car_serial)
  if (!_internal_has_car_serial()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return car_serial_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServiceDiscoveryResponse::set_allocated_car_serial(std::string* car_serial) {
  if (car_serial != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  car_serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), car_serial,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.car_serial)
}
inline std::string* ServiceDiscoveryResponse::unsafe_arena_release_car_serial() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ServiceDiscoveryResponse.car_serial)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return car_serial_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServiceDiscoveryResponse::unsafe_arena_set_allocated_car_serial(
    std::string* car_serial) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (car_serial != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  car_serial_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      car_serial, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ServiceDiscoveryResponse.car_serial)
}

// required bool driver_pos = 6;
inline bool ServiceDiscoveryResponse::_internal_has_driver_pos() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_driver_pos() const {
  return _internal_has_driver_pos();
}
inline void ServiceDiscoveryResponse::clear_driver_pos() {
  driver_pos_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ServiceDiscoveryResponse::_internal_driver_pos() const {
  return driver_pos_;
}
inline bool ServiceDiscoveryResponse::driver_pos() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.driver_pos)
  return _internal_driver_pos();
}
inline void ServiceDiscoveryResponse::_internal_set_driver_pos(bool value) {
  _has_bits_[0] |= 0x00000100u;
  driver_pos_ = value;
}
inline void ServiceDiscoveryResponse::set_driver_pos(bool value) {
  _internal_set_driver_pos(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.driver_pos)
}

// required string headunit_make = 7;
inline bool ServiceDiscoveryResponse::_internal_has_headunit_make() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_headunit_make() const {
  return _internal_has_headunit_make();
}
inline void ServiceDiscoveryResponse::clear_headunit_make() {
  headunit_make_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ServiceDiscoveryResponse::headunit_make() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.headunit_make)
  return _internal_headunit_make();
}
inline void ServiceDiscoveryResponse::set_headunit_make(const std::string& value) {
  _internal_set_headunit_make(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.headunit_make)
}
inline std::string* ServiceDiscoveryResponse::mutable_headunit_make() {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.headunit_make)
  return _internal_mutable_headunit_make();
}
inline const std::string& ServiceDiscoveryResponse::_internal_headunit_make() const {
  return headunit_make_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_headunit_make(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  headunit_make_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServiceDiscoveryResponse::set_headunit_make(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  headunit_make_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ServiceDiscoveryResponse.headunit_make)
}
inline void ServiceDiscoveryResponse::set_headunit_make(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  headunit_make_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ServiceDiscoveryResponse.headunit_make)
}
inline void ServiceDiscoveryResponse::set_headunit_make(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  headunit_make_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ServiceDiscoveryResponse.headunit_make)
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_headunit_make() {
  _has_bits_[0] |= 0x00000010u;
  return headunit_make_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_headunit_make() {
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.headunit_make)
  if (!_internal_has_headunit_make()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return headunit_make_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServiceDiscoveryResponse::set_allocated_headunit_make(std::string* headunit_make) {
  if (headunit_make != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  headunit_make_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headunit_make,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.headunit_make)
}
inline std::string* ServiceDiscoveryResponse::unsafe_arena_release_headunit_make() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ServiceDiscoveryResponse.headunit_make)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000010u;
  return headunit_make_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServiceDiscoveryResponse::unsafe_arena_set_allocated_headunit_make(
    std::string* headunit_make) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (headunit_make != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  headunit_make_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      headunit_make, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ServiceDiscoveryResponse.headunit_make)
}

// required string headunit_model = 8;
inline bool ServiceDiscoveryResponse::_internal_has_headunit_model() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_headunit_model() const {
  return _internal_has_headunit_model();
}
inline void ServiceDiscoveryResponse::clear_headunit_model() {
  headunit_model_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ServiceDiscoveryResponse::headunit_model() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.headunit_model)
  return _internal_headunit_model();
}
inline void ServiceDiscoveryResponse::set_headunit_model(const std::string& value) {
  _internal_set_headunit_model(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.headunit_model)
}
inline std::string* ServiceDiscoveryResponse::mutable_headunit_model() {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.headunit_model)
  return _internal_mutable_headunit_model();
}
inline const std::string& ServiceDiscoveryResponse::_internal_headunit_model() const {
  return headunit_model_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_headunit_model(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  headunit_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServiceDiscoveryResponse::set_headunit_model(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  headunit_model_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ServiceDiscoveryResponse.headunit_model)
}
inline void ServiceDiscoveryResponse::set_headunit_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  headunit_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ServiceDiscoveryResponse.headunit_model)
}
inline void ServiceDiscoveryResponse::set_headunit_model(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  headunit_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ServiceDiscoveryResponse.headunit_model)
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_headunit_model() {
  _has_bits_[0] |= 0x00000020u;
  return headunit_model_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_headunit_model() {
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.headunit_model)
  if (!_internal_has_headunit_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return headunit_model_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServiceDiscoveryResponse::set_allocated_headunit_model(std::string* headunit_model) {
  if (headunit_model != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  headunit_model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headunit_model,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.headunit_model)
}
inline std::string* ServiceDiscoveryResponse::unsafe_arena_release_headunit_model() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ServiceDiscoveryResponse.headunit_model)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000020u;
  return headunit_model_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServiceDiscoveryResponse::unsafe_arena_set_allocated_headunit_model(
    std::string* headunit_model) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (headunit_model != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  headunit_model_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      headunit_model, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ServiceDiscoveryResponse.headunit_model)
}

// required string sw_build = 9;
inline bool ServiceDiscoveryResponse::_internal_has_sw_build() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_sw_build() const {
  return _internal_has_sw_build();
}
inline void ServiceDiscoveryResponse::clear_sw_build() {
  sw_build_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ServiceDiscoveryResponse::sw_build() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.sw_build)
  return _internal_sw_build();
}
inline void ServiceDiscoveryResponse::set_sw_build(const std::string& value) {
  _internal_set_sw_build(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.sw_build)
}
inline std::string* ServiceDiscoveryResponse::mutable_sw_build() {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.sw_build)
  return _internal_mutable_sw_build();
}
inline const std::string& ServiceDiscoveryResponse::_internal_sw_build() const {
  return sw_build_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_sw_build(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  sw_build_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServiceDiscoveryResponse::set_sw_build(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  sw_build_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ServiceDiscoveryResponse.sw_build)
}
inline void ServiceDiscoveryResponse::set_sw_build(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  sw_build_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ServiceDiscoveryResponse.sw_build)
}
inline void ServiceDiscoveryResponse::set_sw_build(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  sw_build_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ServiceDiscoveryResponse.sw_build)
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_sw_build() {
  _has_bits_[0] |= 0x00000040u;
  return sw_build_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_sw_build() {
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.sw_build)
  if (!_internal_has_sw_build()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return sw_build_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServiceDiscoveryResponse::set_allocated_sw_build(std::string* sw_build) {
  if (sw_build != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  sw_build_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sw_build,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.sw_build)
}
inline std::string* ServiceDiscoveryResponse::unsafe_arena_release_sw_build() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ServiceDiscoveryResponse.sw_build)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000040u;
  return sw_build_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServiceDiscoveryResponse::unsafe_arena_set_allocated_sw_build(
    std::string* sw_build) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sw_build != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  sw_build_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sw_build, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ServiceDiscoveryResponse.sw_build)
}

// required string sw_version = 10;
inline bool ServiceDiscoveryResponse::_internal_has_sw_version() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_sw_version() const {
  return _internal_has_sw_version();
}
inline void ServiceDiscoveryResponse::clear_sw_version() {
  sw_version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ServiceDiscoveryResponse::sw_version() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.sw_version)
  return _internal_sw_version();
}
inline void ServiceDiscoveryResponse::set_sw_version(const std::string& value) {
  _internal_set_sw_version(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.sw_version)
}
inline std::string* ServiceDiscoveryResponse::mutable_sw_version() {
  // @@protoc_insertion_point(field_mutable:HU.ServiceDiscoveryResponse.sw_version)
  return _internal_mutable_sw_version();
}
inline const std::string& ServiceDiscoveryResponse::_internal_sw_version() const {
  return sw_version_.Get();
}
inline void ServiceDiscoveryResponse::_internal_set_sw_version(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  sw_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ServiceDiscoveryResponse::set_sw_version(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  sw_version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.ServiceDiscoveryResponse.sw_version)
}
inline void ServiceDiscoveryResponse::set_sw_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  sw_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.ServiceDiscoveryResponse.sw_version)
}
inline void ServiceDiscoveryResponse::set_sw_version(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000080u;
  sw_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.ServiceDiscoveryResponse.sw_version)
}
inline std::string* ServiceDiscoveryResponse::_internal_mutable_sw_version() {
  _has_bits_[0] |= 0x00000080u;
  return sw_version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ServiceDiscoveryResponse::release_sw_version() {
  // @@protoc_insertion_point(field_release:HU.ServiceDiscoveryResponse.sw_version)
  if (!_internal_has_sw_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return sw_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ServiceDiscoveryResponse::set_allocated_sw_version(std::string* sw_version) {
  if (sw_version != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  sw_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sw_version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.ServiceDiscoveryResponse.sw_version)
}
inline std::string* ServiceDiscoveryResponse::unsafe_arena_release_sw_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.ServiceDiscoveryResponse.sw_version)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000080u;
  return sw_version_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ServiceDiscoveryResponse::unsafe_arena_set_allocated_sw_version(
    std::string* sw_version) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (sw_version != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  sw_version_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      sw_version, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.ServiceDiscoveryResponse.sw_version)
}

// required bool can_play_native_media_during_vr = 11;
inline bool ServiceDiscoveryResponse::_internal_has_can_play_native_media_during_vr() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_can_play_native_media_during_vr() const {
  return _internal_has_can_play_native_media_during_vr();
}
inline void ServiceDiscoveryResponse::clear_can_play_native_media_during_vr() {
  can_play_native_media_during_vr_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ServiceDiscoveryResponse::_internal_can_play_native_media_during_vr() const {
  return can_play_native_media_during_vr_;
}
inline bool ServiceDiscoveryResponse::can_play_native_media_during_vr() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.can_play_native_media_during_vr)
  return _internal_can_play_native_media_during_vr();
}
inline void ServiceDiscoveryResponse::_internal_set_can_play_native_media_during_vr(bool value) {
  _has_bits_[0] |= 0x00000200u;
  can_play_native_media_during_vr_ = value;
}
inline void ServiceDiscoveryResponse::set_can_play_native_media_during_vr(bool value) {
  _internal_set_can_play_native_media_during_vr(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.can_play_native_media_during_vr)
}

// required bool hide_clock = 12;
inline bool ServiceDiscoveryResponse::_internal_has_hide_clock() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ServiceDiscoveryResponse::has_hide_clock() const {
  return _internal_has_hide_clock();
}
inline void ServiceDiscoveryResponse::clear_hide_clock() {
  hide_clock_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool ServiceDiscoveryResponse::_internal_hide_clock() const {
  return hide_clock_;
}
inline bool ServiceDiscoveryResponse::hide_clock() const {
  // @@protoc_insertion_point(field_get:HU.ServiceDiscoveryResponse.hide_clock)
  return _internal_hide_clock();
}
inline void ServiceDiscoveryResponse::_internal_set_hide_clock(bool value) {
  _has_bits_[0] |= 0x00000400u;
  hide_clock_ = value;
}
inline void ServiceDiscoveryResponse::set_hide_clock(bool value) {
  _internal_set_hide_clock(value);
  // @@protoc_insertion_point(field_set:HU.ServiceDiscoveryResponse.hide_clock)
}

// -------------------------------------------------------------------

// ChannelOpenRequest

// optional int32 priority = 1;
inline bool ChannelOpenRequest::_internal_has_priority() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelOpenRequest::has_priority() const {
  return _internal_has_priority();
}
inline void ChannelOpenRequest::clear_priority() {
  priority_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelOpenRequest::_internal_priority() const {
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelOpenRequest::priority() const {
  // @@protoc_insertion_point(field_get:HU.ChannelOpenRequest.priority)
  return _internal_priority();
}
inline void ChannelOpenRequest::_internal_set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  priority_ = value;
}
inline void ChannelOpenRequest::set_priority(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:HU.ChannelOpenRequest.priority)
}

// optional int32 id = 2;
inline bool ChannelOpenRequest::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChannelOpenRequest::has_id() const {
  return _internal_has_id();
}
inline void ChannelOpenRequest::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelOpenRequest::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChannelOpenRequest::id() const {
  // @@protoc_insertion_point(field_get:HU.ChannelOpenRequest.id)
  return _internal_id();
}
inline void ChannelOpenRequest::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void ChannelOpenRequest::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:HU.ChannelOpenRequest.id)
}

// -------------------------------------------------------------------

// ChannelOpenResponse

// required .HU.STATUS status = 1;
inline bool ChannelOpenResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChannelOpenResponse::has_status() const {
  return _internal_has_status();
}
inline void ChannelOpenResponse::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::STATUS ChannelOpenResponse::_internal_status() const {
  return static_cast< ::HU::STATUS >(status_);
}
inline ::HU::STATUS ChannelOpenResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.ChannelOpenResponse.status)
  return _internal_status();
}
inline void ChannelOpenResponse::_internal_set_status(::HU::STATUS value) {
  assert(::HU::STATUS_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void ChannelOpenResponse::set_status(::HU::STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.ChannelOpenResponse.status)
}

// -------------------------------------------------------------------

// PingRequest

// required int64 timestamp = 1;
inline bool PingRequest::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PingRequest::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void PingRequest::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PingRequest::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PingRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:HU.PingRequest.timestamp)
  return _internal_timestamp();
}
inline void PingRequest::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
}
inline void PingRequest::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:HU.PingRequest.timestamp)
}

// -------------------------------------------------------------------

// PingResponse

// required int64 timestamp = 1;
inline bool PingResponse::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PingResponse::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void PingResponse::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PingResponse::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PingResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:HU.PingResponse.timestamp)
  return _internal_timestamp();
}
inline void PingResponse::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
}
inline void PingResponse::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:HU.PingResponse.timestamp)
}

// -------------------------------------------------------------------

// ShutdownRequest

// optional .HU.ShutdownRequest.REASON reason = 1;
inline bool ShutdownRequest::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ShutdownRequest::has_reason() const {
  return _internal_has_reason();
}
inline void ShutdownRequest::clear_reason() {
  reason_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::ShutdownRequest_REASON ShutdownRequest::_internal_reason() const {
  return static_cast< ::HU::ShutdownRequest_REASON >(reason_);
}
inline ::HU::ShutdownRequest_REASON ShutdownRequest::reason() const {
  // @@protoc_insertion_point(field_get:HU.ShutdownRequest.reason)
  return _internal_reason();
}
inline void ShutdownRequest::_internal_set_reason(::HU::ShutdownRequest_REASON value) {
  assert(::HU::ShutdownRequest_REASON_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  reason_ = value;
}
inline void ShutdownRequest::set_reason(::HU::ShutdownRequest_REASON value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:HU.ShutdownRequest.reason)
}

// -------------------------------------------------------------------

// ShutdownResponse

// -------------------------------------------------------------------

// MediaSetupRequest

// optional uint32 type = 1;
inline bool MediaSetupRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MediaSetupRequest::has_type() const {
  return _internal_has_type();
}
inline void MediaSetupRequest::clear_type() {
  type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaSetupRequest::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaSetupRequest::type() const {
  // @@protoc_insertion_point(field_get:HU.MediaSetupRequest.type)
  return _internal_type();
}
inline void MediaSetupRequest::_internal_set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void MediaSetupRequest::set_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.MediaSetupRequest.type)
}

// -------------------------------------------------------------------

// MediaSetupResponse

// required .HU.MediaSetupResponse.MEDIA_STATUS media_status = 1;
inline bool MediaSetupResponse::_internal_has_media_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MediaSetupResponse::has_media_status() const {
  return _internal_has_media_status();
}
inline void MediaSetupResponse::clear_media_status() {
  media_status_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::HU::MediaSetupResponse_MEDIA_STATUS MediaSetupResponse::_internal_media_status() const {
  return static_cast< ::HU::MediaSetupResponse_MEDIA_STATUS >(media_status_);
}
inline ::HU::MediaSetupResponse_MEDIA_STATUS MediaSetupResponse::media_status() const {
  // @@protoc_insertion_point(field_get:HU.MediaSetupResponse.media_status)
  return _internal_media_status();
}
inline void MediaSetupResponse::_internal_set_media_status(::HU::MediaSetupResponse_MEDIA_STATUS value) {
  assert(::HU::MediaSetupResponse_MEDIA_STATUS_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  media_status_ = value;
}
inline void MediaSetupResponse::set_media_status(::HU::MediaSetupResponse_MEDIA_STATUS value) {
  _internal_set_media_status(value);
  // @@protoc_insertion_point(field_set:HU.MediaSetupResponse.media_status)
}

// required uint32 max_unacked = 2;
inline bool MediaSetupResponse::_internal_has_max_unacked() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MediaSetupResponse::has_max_unacked() const {
  return _internal_has_max_unacked();
}
inline void MediaSetupResponse::clear_max_unacked() {
  max_unacked_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaSetupResponse::_internal_max_unacked() const {
  return max_unacked_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaSetupResponse::max_unacked() const {
  // @@protoc_insertion_point(field_get:HU.MediaSetupResponse.max_unacked)
  return _internal_max_unacked();
}
inline void MediaSetupResponse::_internal_set_max_unacked(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  max_unacked_ = value;
}
inline void MediaSetupResponse::set_max_unacked(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_max_unacked(value);
  // @@protoc_insertion_point(field_set:HU.MediaSetupResponse.max_unacked)
}

// repeated uint32 configs = 3;
inline int MediaSetupResponse::_internal_configs_size() const {
  return configs_.size();
}
inline int MediaSetupResponse::configs_size() const {
  return _internal_configs_size();
}
inline void MediaSetupResponse::clear_configs() {
  configs_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaSetupResponse::_internal_configs(int index) const {
  return configs_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaSetupResponse::configs(int index) const {
  // @@protoc_insertion_point(field_get:HU.MediaSetupResponse.configs)
  return _internal_configs(index);
}
inline void MediaSetupResponse::set_configs(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  configs_.Set(index, value);
  // @@protoc_insertion_point(field_set:HU.MediaSetupResponse.configs)
}
inline void MediaSetupResponse::_internal_add_configs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  configs_.Add(value);
}
inline void MediaSetupResponse::add_configs(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_configs(value);
  // @@protoc_insertion_point(field_add:HU.MediaSetupResponse.configs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
MediaSetupResponse::_internal_configs() const {
  return configs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
MediaSetupResponse::configs() const {
  // @@protoc_insertion_point(field_list:HU.MediaSetupResponse.configs)
  return _internal_configs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
MediaSetupResponse::_internal_mutable_configs() {
  return &configs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
MediaSetupResponse::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_list:HU.MediaSetupResponse.configs)
  return _internal_mutable_configs();
}

// -------------------------------------------------------------------

// MediaStopRequest

// -------------------------------------------------------------------

// MediaStartRequest

// required int32 session = 1;
inline bool MediaStartRequest::_internal_has_session() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MediaStartRequest::has_session() const {
  return _internal_has_session();
}
inline void MediaStartRequest::clear_session() {
  session_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MediaStartRequest::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MediaStartRequest::session() const {
  // @@protoc_insertion_point(field_get:HU.MediaStartRequest.session)
  return _internal_session();
}
inline void MediaStartRequest::_internal_set_session(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  session_ = value;
}
inline void MediaStartRequest::set_session(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:HU.MediaStartRequest.session)
}

// optional uint32 config = 2;
inline bool MediaStartRequest::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MediaStartRequest::has_config() const {
  return _internal_has_config();
}
inline void MediaStartRequest::clear_config() {
  config_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaStartRequest::_internal_config() const {
  return config_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaStartRequest::config() const {
  // @@protoc_insertion_point(field_get:HU.MediaStartRequest.config)
  return _internal_config();
}
inline void MediaStartRequest::_internal_set_config(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  config_ = value;
}
inline void MediaStartRequest::set_config(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_config(value);
  // @@protoc_insertion_point(field_set:HU.MediaStartRequest.config)
}

// -------------------------------------------------------------------

// MediaAck

// required int32 session = 1;
inline bool MediaAck::_internal_has_session() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MediaAck::has_session() const {
  return _internal_has_session();
}
inline void MediaAck::clear_session() {
  session_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MediaAck::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MediaAck::session() const {
  // @@protoc_insertion_point(field_get:HU.MediaAck.session)
  return _internal_session();
}
inline void MediaAck::_internal_set_session(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  session_ = value;
}
inline void MediaAck::set_session(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:HU.MediaAck.session)
}

// required uint32 value = 2;
inline bool MediaAck::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MediaAck::has_value() const {
  return _internal_has_value();
}
inline void MediaAck::clear_value() {
  value_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaAck::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MediaAck::value() const {
  // @@protoc_insertion_point(field_get:HU.MediaAck.value)
  return _internal_value();
}
inline void MediaAck::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void MediaAck::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:HU.MediaAck.value)
}

// -------------------------------------------------------------------

// MicRequest

// required bool open = 1;
inline bool MicRequest::_internal_has_open() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MicRequest::has_open() const {
  return _internal_has_open();
}
inline void MicRequest::clear_open() {
  open_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool MicRequest::_internal_open() const {
  return open_;
}
inline bool MicRequest::open() const {
  // @@protoc_insertion_point(field_get:HU.MicRequest.open)
  return _internal_open();
}
inline void MicRequest::_internal_set_open(bool value) {
  _has_bits_[0] |= 0x00000001u;
  open_ = value;
}
inline void MicRequest::set_open(bool value) {
  _internal_set_open(value);
  // @@protoc_insertion_point(field_set:HU.MicRequest.open)
}

// optional bool anc = 2;
inline bool MicRequest::_internal_has_anc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MicRequest::has_anc() const {
  return _internal_has_anc();
}
inline void MicRequest::clear_anc() {
  anc_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool MicRequest::_internal_anc() const {
  return anc_;
}
inline bool MicRequest::anc() const {
  // @@protoc_insertion_point(field_get:HU.MicRequest.anc)
  return _internal_anc();
}
inline void MicRequest::_internal_set_anc(bool value) {
  _has_bits_[0] |= 0x00000002u;
  anc_ = value;
}
inline void MicRequest::set_anc(bool value) {
  _internal_set_anc(value);
  // @@protoc_insertion_point(field_set:HU.MicRequest.anc)
}

// optional bool ec = 3;
inline bool MicRequest::_internal_has_ec() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MicRequest::has_ec() const {
  return _internal_has_ec();
}
inline void MicRequest::clear_ec() {
  ec_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool MicRequest::_internal_ec() const {
  return ec_;
}
inline bool MicRequest::ec() const {
  // @@protoc_insertion_point(field_get:HU.MicRequest.ec)
  return _internal_ec();
}
inline void MicRequest::_internal_set_ec(bool value) {
  _has_bits_[0] |= 0x00000004u;
  ec_ = value;
}
inline void MicRequest::set_ec(bool value) {
  _internal_set_ec(value);
  // @@protoc_insertion_point(field_set:HU.MicRequest.ec)
}

// optional int32 max_unacked = 4;
inline bool MicRequest::_internal_has_max_unacked() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MicRequest::has_max_unacked() const {
  return _internal_has_max_unacked();
}
inline void MicRequest::clear_max_unacked() {
  max_unacked_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MicRequest::_internal_max_unacked() const {
  return max_unacked_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MicRequest::max_unacked() const {
  // @@protoc_insertion_point(field_get:HU.MicRequest.max_unacked)
  return _internal_max_unacked();
}
inline void MicRequest::_internal_set_max_unacked(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  max_unacked_ = value;
}
inline void MicRequest::set_max_unacked(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_unacked(value);
  // @@protoc_insertion_point(field_set:HU.MicRequest.max_unacked)
}

// -------------------------------------------------------------------

// MicResponse

// required int32 session = 1;
inline bool MicResponse::_internal_has_session() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MicResponse::has_session() const {
  return _internal_has_session();
}
inline void MicResponse::clear_session() {
  session_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MicResponse::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MicResponse::session() const {
  // @@protoc_insertion_point(field_get:HU.MicResponse.session)
  return _internal_session();
}
inline void MicResponse::_internal_set_session(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  session_ = value;
}
inline void MicResponse::set_session(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:HU.MicResponse.session)
}

// required uint32 value = 2;
inline bool MicResponse::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MicResponse::has_value() const {
  return _internal_has_value();
}
inline void MicResponse::clear_value() {
  value_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MicResponse::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MicResponse::value() const {
  // @@protoc_insertion_point(field_get:HU.MicResponse.value)
  return _internal_value();
}
inline void MicResponse::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void MicResponse::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:HU.MicResponse.value)
}

// -------------------------------------------------------------------

// VideoFocusRequest

// optional int32 disp_index = 1;
inline bool VideoFocusRequest::_internal_has_disp_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoFocusRequest::has_disp_index() const {
  return _internal_has_disp_index();
}
inline void VideoFocusRequest::clear_disp_index() {
  disp_index_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoFocusRequest::_internal_disp_index() const {
  return disp_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VideoFocusRequest::disp_index() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocusRequest.disp_index)
  return _internal_disp_index();
}
inline void VideoFocusRequest::_internal_set_disp_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  disp_index_ = value;
}
inline void VideoFocusRequest::set_disp_index(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_disp_index(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocusRequest.disp_index)
}

// optional .HU.VIDEO_FOCUS_MODE mode = 2;
inline bool VideoFocusRequest::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoFocusRequest::has_mode() const {
  return _internal_has_mode();
}
inline void VideoFocusRequest::clear_mode() {
  mode_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::HU::VIDEO_FOCUS_MODE VideoFocusRequest::_internal_mode() const {
  return static_cast< ::HU::VIDEO_FOCUS_MODE >(mode_);
}
inline ::HU::VIDEO_FOCUS_MODE VideoFocusRequest::mode() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocusRequest.mode)
  return _internal_mode();
}
inline void VideoFocusRequest::_internal_set_mode(::HU::VIDEO_FOCUS_MODE value) {
  assert(::HU::VIDEO_FOCUS_MODE_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  mode_ = value;
}
inline void VideoFocusRequest::set_mode(::HU::VIDEO_FOCUS_MODE value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocusRequest.mode)
}

// optional .HU.VIDEO_FOCUS_REASON reason = 3;
inline bool VideoFocusRequest::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VideoFocusRequest::has_reason() const {
  return _internal_has_reason();
}
inline void VideoFocusRequest::clear_reason() {
  reason_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::HU::VIDEO_FOCUS_REASON VideoFocusRequest::_internal_reason() const {
  return static_cast< ::HU::VIDEO_FOCUS_REASON >(reason_);
}
inline ::HU::VIDEO_FOCUS_REASON VideoFocusRequest::reason() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocusRequest.reason)
  return _internal_reason();
}
inline void VideoFocusRequest::_internal_set_reason(::HU::VIDEO_FOCUS_REASON value) {
  assert(::HU::VIDEO_FOCUS_REASON_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  reason_ = value;
}
inline void VideoFocusRequest::set_reason(::HU::VIDEO_FOCUS_REASON value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocusRequest.reason)
}

// -------------------------------------------------------------------

// VideoFocus

// optional .HU.VIDEO_FOCUS_MODE mode = 1;
inline bool VideoFocus::_internal_has_mode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoFocus::has_mode() const {
  return _internal_has_mode();
}
inline void VideoFocus::clear_mode() {
  mode_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::HU::VIDEO_FOCUS_MODE VideoFocus::_internal_mode() const {
  return static_cast< ::HU::VIDEO_FOCUS_MODE >(mode_);
}
inline ::HU::VIDEO_FOCUS_MODE VideoFocus::mode() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocus.mode)
  return _internal_mode();
}
inline void VideoFocus::_internal_set_mode(::HU::VIDEO_FOCUS_MODE value) {
  assert(::HU::VIDEO_FOCUS_MODE_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  mode_ = value;
}
inline void VideoFocus::set_mode(::HU::VIDEO_FOCUS_MODE value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocus.mode)
}

// optional bool unrequested = 2;
inline bool VideoFocus::_internal_has_unrequested() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoFocus::has_unrequested() const {
  return _internal_has_unrequested();
}
inline void VideoFocus::clear_unrequested() {
  unrequested_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool VideoFocus::_internal_unrequested() const {
  return unrequested_;
}
inline bool VideoFocus::unrequested() const {
  // @@protoc_insertion_point(field_get:HU.VideoFocus.unrequested)
  return _internal_unrequested();
}
inline void VideoFocus::_internal_set_unrequested(bool value) {
  _has_bits_[0] |= 0x00000001u;
  unrequested_ = value;
}
inline void VideoFocus::set_unrequested(bool value) {
  _internal_set_unrequested(value);
  // @@protoc_insertion_point(field_set:HU.VideoFocus.unrequested)
}

// -------------------------------------------------------------------

// SensorStartRequest

// required .HU.SENSOR_TYPE type = 1;
inline bool SensorStartRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SensorStartRequest::has_type() const {
  return _internal_has_type();
}
inline void SensorStartRequest::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::HU::SENSOR_TYPE SensorStartRequest::_internal_type() const {
  return static_cast< ::HU::SENSOR_TYPE >(type_);
}
inline ::HU::SENSOR_TYPE SensorStartRequest::type() const {
  // @@protoc_insertion_point(field_get:HU.SensorStartRequest.type)
  return _internal_type();
}
inline void SensorStartRequest::_internal_set_type(::HU::SENSOR_TYPE value) {
  assert(::HU::SENSOR_TYPE_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void SensorStartRequest::set_type(::HU::SENSOR_TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:HU.SensorStartRequest.type)
}

// optional int64 refresh_interval = 2;
inline bool SensorStartRequest::_internal_has_refresh_interval() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorStartRequest::has_refresh_interval() const {
  return _internal_has_refresh_interval();
}
inline void SensorStartRequest::clear_refresh_interval() {
  refresh_interval_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SensorStartRequest::_internal_refresh_interval() const {
  return refresh_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SensorStartRequest::refresh_interval() const {
  // @@protoc_insertion_point(field_get:HU.SensorStartRequest.refresh_interval)
  return _internal_refresh_interval();
}
inline void SensorStartRequest::_internal_set_refresh_interval(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  refresh_interval_ = value;
}
inline void SensorStartRequest::set_refresh_interval(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_refresh_interval(value);
  // @@protoc_insertion_point(field_set:HU.SensorStartRequest.refresh_interval)
}

// -------------------------------------------------------------------

// SensorStartResponse

// required .HU.STATUS status = 1;
inline bool SensorStartResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SensorStartResponse::has_status() const {
  return _internal_has_status();
}
inline void SensorStartResponse::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::STATUS SensorStartResponse::_internal_status() const {
  return static_cast< ::HU::STATUS >(status_);
}
inline ::HU::STATUS SensorStartResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.SensorStartResponse.status)
  return _internal_status();
}
inline void SensorStartResponse::_internal_set_status(::HU::STATUS value) {
  assert(::HU::STATUS_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void SensorStartResponse::set_status(::HU::STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.SensorStartResponse.status)
}

// -------------------------------------------------------------------

// NavigationFocusRequest

// optional uint32 focus_type = 1;
inline bool NavigationFocusRequest::_internal_has_focus_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NavigationFocusRequest::has_focus_type() const {
  return _internal_has_focus_type();
}
inline void NavigationFocusRequest::clear_focus_type() {
  focus_type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavigationFocusRequest::_internal_focus_type() const {
  return focus_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavigationFocusRequest::focus_type() const {
  // @@protoc_insertion_point(field_get:HU.NavigationFocusRequest.focus_type)
  return _internal_focus_type();
}
inline void NavigationFocusRequest::_internal_set_focus_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  focus_type_ = value;
}
inline void NavigationFocusRequest::set_focus_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_focus_type(value);
  // @@protoc_insertion_point(field_set:HU.NavigationFocusRequest.focus_type)
}

// -------------------------------------------------------------------

// NavigationFocusResponse

// optional uint32 focus_type = 1;
inline bool NavigationFocusResponse::_internal_has_focus_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NavigationFocusResponse::has_focus_type() const {
  return _internal_has_focus_type();
}
inline void NavigationFocusResponse::clear_focus_type() {
  focus_type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavigationFocusResponse::_internal_focus_type() const {
  return focus_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 NavigationFocusResponse::focus_type() const {
  // @@protoc_insertion_point(field_get:HU.NavigationFocusResponse.focus_type)
  return _internal_focus_type();
}
inline void NavigationFocusResponse::_internal_set_focus_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  focus_type_ = value;
}
inline void NavigationFocusResponse::set_focus_type(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_focus_type(value);
  // @@protoc_insertion_point(field_set:HU.NavigationFocusResponse.focus_type)
}

// -------------------------------------------------------------------

// VoiceSessionRequest

// optional .HU.VoiceSessionRequest.VOICE_STATUS voice_status = 1;
inline bool VoiceSessionRequest::_internal_has_voice_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VoiceSessionRequest::has_voice_status() const {
  return _internal_has_voice_status();
}
inline void VoiceSessionRequest::clear_voice_status() {
  voice_status_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::VoiceSessionRequest_VOICE_STATUS VoiceSessionRequest::_internal_voice_status() const {
  return static_cast< ::HU::VoiceSessionRequest_VOICE_STATUS >(voice_status_);
}
inline ::HU::VoiceSessionRequest_VOICE_STATUS VoiceSessionRequest::voice_status() const {
  // @@protoc_insertion_point(field_get:HU.VoiceSessionRequest.voice_status)
  return _internal_voice_status();
}
inline void VoiceSessionRequest::_internal_set_voice_status(::HU::VoiceSessionRequest_VOICE_STATUS value) {
  assert(::HU::VoiceSessionRequest_VOICE_STATUS_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  voice_status_ = value;
}
inline void VoiceSessionRequest::set_voice_status(::HU::VoiceSessionRequest_VOICE_STATUS value) {
  _internal_set_voice_status(value);
  // @@protoc_insertion_point(field_set:HU.VoiceSessionRequest.voice_status)
}

// -------------------------------------------------------------------

// AudioFocusRequest

// required .HU.AudioFocusRequest.AUDIO_FOCUS focus_type = 1;
inline bool AudioFocusRequest::_internal_has_focus_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioFocusRequest::has_focus_type() const {
  return _internal_has_focus_type();
}
inline void AudioFocusRequest::clear_focus_type() {
  focus_type_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::AudioFocusRequest_AUDIO_FOCUS AudioFocusRequest::_internal_focus_type() const {
  return static_cast< ::HU::AudioFocusRequest_AUDIO_FOCUS >(focus_type_);
}
inline ::HU::AudioFocusRequest_AUDIO_FOCUS AudioFocusRequest::focus_type() const {
  // @@protoc_insertion_point(field_get:HU.AudioFocusRequest.focus_type)
  return _internal_focus_type();
}
inline void AudioFocusRequest::_internal_set_focus_type(::HU::AudioFocusRequest_AUDIO_FOCUS value) {
  assert(::HU::AudioFocusRequest_AUDIO_FOCUS_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  focus_type_ = value;
}
inline void AudioFocusRequest::set_focus_type(::HU::AudioFocusRequest_AUDIO_FOCUS value) {
  _internal_set_focus_type(value);
  // @@protoc_insertion_point(field_set:HU.AudioFocusRequest.focus_type)
}

// -------------------------------------------------------------------

// AudioFocusResponse

// required .HU.AudioFocusResponse.AUDIO_FOCUS_STATE focus_type = 1;
inline bool AudioFocusResponse::_internal_has_focus_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioFocusResponse::has_focus_type() const {
  return _internal_has_focus_type();
}
inline void AudioFocusResponse::clear_focus_type() {
  focus_type_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE AudioFocusResponse::_internal_focus_type() const {
  return static_cast< ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE >(focus_type_);
}
inline ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE AudioFocusResponse::focus_type() const {
  // @@protoc_insertion_point(field_get:HU.AudioFocusResponse.focus_type)
  return _internal_focus_type();
}
inline void AudioFocusResponse::_internal_set_focus_type(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE value) {
  assert(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  focus_type_ = value;
}
inline void AudioFocusResponse::set_focus_type(::HU::AudioFocusResponse_AUDIO_FOCUS_STATE value) {
  _internal_set_focus_type(value);
  // @@protoc_insertion_point(field_set:HU.AudioFocusResponse.focus_type)
}

// -------------------------------------------------------------------

// AuthCompleteResponse

// required .HU.STATUS status = 1;
inline bool AuthCompleteResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthCompleteResponse::has_status() const {
  return _internal_has_status();
}
inline void AuthCompleteResponse::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::STATUS AuthCompleteResponse::_internal_status() const {
  return static_cast< ::HU::STATUS >(status_);
}
inline ::HU::STATUS AuthCompleteResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.AuthCompleteResponse.status)
  return _internal_status();
}
inline void AuthCompleteResponse::_internal_set_status(::HU::STATUS value) {
  assert(::HU::STATUS_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void AuthCompleteResponse::set_status(::HU::STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.AuthCompleteResponse.status)
}

// -------------------------------------------------------------------

// PhoneStatus_Call

// optional .HU.PhoneStatus.PHONE_STATE state = 1;
inline bool PhoneStatus_Call::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PhoneStatus_Call::has_state() const {
  return _internal_has_state();
}
inline void PhoneStatus_Call::clear_state() {
  state_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::HU::PhoneStatus_PHONE_STATE PhoneStatus_Call::_internal_state() const {
  return static_cast< ::HU::PhoneStatus_PHONE_STATE >(state_);
}
inline ::HU::PhoneStatus_PHONE_STATE PhoneStatus_Call::state() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.state)
  return _internal_state();
}
inline void PhoneStatus_Call::_internal_set_state(::HU::PhoneStatus_PHONE_STATE value) {
  assert(::HU::PhoneStatus_PHONE_STATE_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  state_ = value;
}
inline void PhoneStatus_Call::set_state(::HU::PhoneStatus_PHONE_STATE value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.state)
}

// optional uint32 call_time = 2;
inline bool PhoneStatus_Call::_internal_has_call_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PhoneStatus_Call::has_call_time() const {
  return _internal_has_call_time();
}
inline void PhoneStatus_Call::clear_call_time() {
  call_time_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PhoneStatus_Call::_internal_call_time() const {
  return call_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PhoneStatus_Call::call_time() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.call_time)
  return _internal_call_time();
}
inline void PhoneStatus_Call::_internal_set_call_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  call_time_ = value;
}
inline void PhoneStatus_Call::set_call_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_call_time(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.call_time)
}

// optional string phone_number = 3;
inline bool PhoneStatus_Call::_internal_has_phone_number() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PhoneStatus_Call::has_phone_number() const {
  return _internal_has_phone_number();
}
inline void PhoneStatus_Call::clear_phone_number() {
  phone_number_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhoneStatus_Call::phone_number() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.phone_number)
  return _internal_phone_number();
}
inline void PhoneStatus_Call::set_phone_number(const std::string& value) {
  _internal_set_phone_number(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.phone_number)
}
inline std::string* PhoneStatus_Call::mutable_phone_number() {
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.Call.phone_number)
  return _internal_mutable_phone_number();
}
inline const std::string& PhoneStatus_Call::_internal_phone_number() const {
  return phone_number_.Get();
}
inline void PhoneStatus_Call::_internal_set_phone_number(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  phone_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PhoneStatus_Call::set_phone_number(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  phone_number_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.PhoneStatus.Call.phone_number)
}
inline void PhoneStatus_Call::set_phone_number(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  phone_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.PhoneStatus.Call.phone_number)
}
inline void PhoneStatus_Call::set_phone_number(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  phone_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.PhoneStatus.Call.phone_number)
}
inline std::string* PhoneStatus_Call::_internal_mutable_phone_number() {
  _has_bits_[0] |= 0x00000001u;
  return phone_number_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PhoneStatus_Call::release_phone_number() {
  // @@protoc_insertion_point(field_release:HU.PhoneStatus.Call.phone_number)
  if (!_internal_has_phone_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return phone_number_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PhoneStatus_Call::set_allocated_phone_number(std::string* phone_number) {
  if (phone_number != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  phone_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phone_number,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatus.Call.phone_number)
}
inline std::string* PhoneStatus_Call::unsafe_arena_release_phone_number() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.PhoneStatus.Call.phone_number)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return phone_number_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PhoneStatus_Call::unsafe_arena_set_allocated_phone_number(
    std::string* phone_number) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (phone_number != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  phone_number_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      phone_number, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.PhoneStatus.Call.phone_number)
}

// optional string caller_id = 4;
inline bool PhoneStatus_Call::_internal_has_caller_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PhoneStatus_Call::has_caller_id() const {
  return _internal_has_caller_id();
}
inline void PhoneStatus_Call::clear_caller_id() {
  caller_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PhoneStatus_Call::caller_id() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.caller_id)
  return _internal_caller_id();
}
inline void PhoneStatus_Call::set_caller_id(const std::string& value) {
  _internal_set_caller_id(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.caller_id)
}
inline std::string* PhoneStatus_Call::mutable_caller_id() {
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.Call.caller_id)
  return _internal_mutable_caller_id();
}
inline const std::string& PhoneStatus_Call::_internal_caller_id() const {
  return caller_id_.Get();
}
inline void PhoneStatus_Call::_internal_set_caller_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  caller_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PhoneStatus_Call::set_caller_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  caller_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.PhoneStatus.Call.caller_id)
}
inline void PhoneStatus_Call::set_caller_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  caller_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.PhoneStatus.Call.caller_id)
}
inline void PhoneStatus_Call::set_caller_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  caller_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.PhoneStatus.Call.caller_id)
}
inline std::string* PhoneStatus_Call::_internal_mutable_caller_id() {
  _has_bits_[0] |= 0x00000002u;
  return caller_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PhoneStatus_Call::release_caller_id() {
  // @@protoc_insertion_point(field_release:HU.PhoneStatus.Call.caller_id)
  if (!_internal_has_caller_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return caller_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PhoneStatus_Call::set_allocated_caller_id(std::string* caller_id) {
  if (caller_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  caller_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caller_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatus.Call.caller_id)
}
inline std::string* PhoneStatus_Call::unsafe_arena_release_caller_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.PhoneStatus.Call.caller_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return caller_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PhoneStatus_Call::unsafe_arena_set_allocated_caller_id(
    std::string* caller_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (caller_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  caller_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      caller_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.PhoneStatus.Call.caller_id)
}

// optional string phone_number_type = 5;
inline bool PhoneStatus_Call::_internal_has_phone_number_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PhoneStatus_Call::has_phone_number_type() const {
  return _internal_has_phone_number_type();
}
inline void PhoneStatus_Call::clear_phone_number_type() {
  phone_number_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PhoneStatus_Call::phone_number_type() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.phone_number_type)
  return _internal_phone_number_type();
}
inline void PhoneStatus_Call::set_phone_number_type(const std::string& value) {
  _internal_set_phone_number_type(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.phone_number_type)
}
inline std::string* PhoneStatus_Call::mutable_phone_number_type() {
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.Call.phone_number_type)
  return _internal_mutable_phone_number_type();
}
inline const std::string& PhoneStatus_Call::_internal_phone_number_type() const {
  return phone_number_type_.Get();
}
inline void PhoneStatus_Call::_internal_set_phone_number_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  phone_number_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PhoneStatus_Call::set_phone_number_type(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  phone_number_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.PhoneStatus.Call.phone_number_type)
}
inline void PhoneStatus_Call::set_phone_number_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  phone_number_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.PhoneStatus.Call.phone_number_type)
}
inline void PhoneStatus_Call::set_phone_number_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  phone_number_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.PhoneStatus.Call.phone_number_type)
}
inline std::string* PhoneStatus_Call::_internal_mutable_phone_number_type() {
  _has_bits_[0] |= 0x00000004u;
  return phone_number_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PhoneStatus_Call::release_phone_number_type() {
  // @@protoc_insertion_point(field_release:HU.PhoneStatus.Call.phone_number_type)
  if (!_internal_has_phone_number_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return phone_number_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PhoneStatus_Call::set_allocated_phone_number_type(std::string* phone_number_type) {
  if (phone_number_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  phone_number_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phone_number_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatus.Call.phone_number_type)
}
inline std::string* PhoneStatus_Call::unsafe_arena_release_phone_number_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.PhoneStatus.Call.phone_number_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return phone_number_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PhoneStatus_Call::unsafe_arena_set_allocated_phone_number_type(
    std::string* phone_number_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (phone_number_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  phone_number_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      phone_number_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.PhoneStatus.Call.phone_number_type)
}

// optional bytes thumbnail = 6;
inline bool PhoneStatus_Call::_internal_has_thumbnail() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PhoneStatus_Call::has_thumbnail() const {
  return _internal_has_thumbnail();
}
inline void PhoneStatus_Call::clear_thumbnail() {
  thumbnail_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PhoneStatus_Call::thumbnail() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.Call.thumbnail)
  return _internal_thumbnail();
}
inline void PhoneStatus_Call::set_thumbnail(const std::string& value) {
  _internal_set_thumbnail(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.Call.thumbnail)
}
inline std::string* PhoneStatus_Call::mutable_thumbnail() {
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.Call.thumbnail)
  return _internal_mutable_thumbnail();
}
inline const std::string& PhoneStatus_Call::_internal_thumbnail() const {
  return thumbnail_.Get();
}
inline void PhoneStatus_Call::_internal_set_thumbnail(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  thumbnail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PhoneStatus_Call::set_thumbnail(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  thumbnail_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.PhoneStatus.Call.thumbnail)
}
inline void PhoneStatus_Call::set_thumbnail(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  thumbnail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.PhoneStatus.Call.thumbnail)
}
inline void PhoneStatus_Call::set_thumbnail(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  thumbnail_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.PhoneStatus.Call.thumbnail)
}
inline std::string* PhoneStatus_Call::_internal_mutable_thumbnail() {
  _has_bits_[0] |= 0x00000008u;
  return thumbnail_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PhoneStatus_Call::release_thumbnail() {
  // @@protoc_insertion_point(field_release:HU.PhoneStatus.Call.thumbnail)
  if (!_internal_has_thumbnail()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return thumbnail_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PhoneStatus_Call::set_allocated_thumbnail(std::string* thumbnail) {
  if (thumbnail != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  thumbnail_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), thumbnail,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatus.Call.thumbnail)
}
inline std::string* PhoneStatus_Call::unsafe_arena_release_thumbnail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.PhoneStatus.Call.thumbnail)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return thumbnail_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PhoneStatus_Call::unsafe_arena_set_allocated_thumbnail(
    std::string* thumbnail) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (thumbnail != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  thumbnail_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      thumbnail, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.PhoneStatus.Call.thumbnail)
}

// -------------------------------------------------------------------

// PhoneStatus

// repeated .HU.PhoneStatus.Call calls = 1;
inline int PhoneStatus::_internal_calls_size() const {
  return calls_.size();
}
inline int PhoneStatus::calls_size() const {
  return _internal_calls_size();
}
inline void PhoneStatus::clear_calls() {
  calls_.Clear();
}
inline ::HU::PhoneStatus_Call* PhoneStatus::mutable_calls(int index) {
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatus.calls)
  return calls_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::PhoneStatus_Call >*
PhoneStatus::mutable_calls() {
  // @@protoc_insertion_point(field_mutable_list:HU.PhoneStatus.calls)
  return &calls_;
}
inline const ::HU::PhoneStatus_Call& PhoneStatus::_internal_calls(int index) const {
  return calls_.Get(index);
}
inline const ::HU::PhoneStatus_Call& PhoneStatus::calls(int index) const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.calls)
  return _internal_calls(index);
}
inline ::HU::PhoneStatus_Call* PhoneStatus::_internal_add_calls() {
  return calls_.Add();
}
inline ::HU::PhoneStatus_Call* PhoneStatus::add_calls() {
  // @@protoc_insertion_point(field_add:HU.PhoneStatus.calls)
  return _internal_add_calls();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::HU::PhoneStatus_Call >&
PhoneStatus::calls() const {
  // @@protoc_insertion_point(field_list:HU.PhoneStatus.calls)
  return calls_;
}

// optional uint32 signal_strength = 2;
inline bool PhoneStatus::_internal_has_signal_strength() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PhoneStatus::has_signal_strength() const {
  return _internal_has_signal_strength();
}
inline void PhoneStatus::clear_signal_strength() {
  signal_strength_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PhoneStatus::_internal_signal_strength() const {
  return signal_strength_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PhoneStatus::signal_strength() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatus.signal_strength)
  return _internal_signal_strength();
}
inline void PhoneStatus::_internal_set_signal_strength(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  signal_strength_ = value;
}
inline void PhoneStatus::set_signal_strength(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_signal_strength(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatus.signal_strength)
}

// -------------------------------------------------------------------

// PhoneStatusInput

// optional string caller_number = 1;
inline bool PhoneStatusInput::_internal_has_caller_number() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PhoneStatusInput::has_caller_number() const {
  return _internal_has_caller_number();
}
inline void PhoneStatusInput::clear_caller_number() {
  caller_number_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhoneStatusInput::caller_number() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatusInput.caller_number)
  return _internal_caller_number();
}
inline void PhoneStatusInput::set_caller_number(const std::string& value) {
  _internal_set_caller_number(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatusInput.caller_number)
}
inline std::string* PhoneStatusInput::mutable_caller_number() {
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatusInput.caller_number)
  return _internal_mutable_caller_number();
}
inline const std::string& PhoneStatusInput::_internal_caller_number() const {
  return caller_number_.Get();
}
inline void PhoneStatusInput::_internal_set_caller_number(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  caller_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PhoneStatusInput::set_caller_number(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  caller_number_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.PhoneStatusInput.caller_number)
}
inline void PhoneStatusInput::set_caller_number(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  caller_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.PhoneStatusInput.caller_number)
}
inline void PhoneStatusInput::set_caller_number(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  caller_number_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.PhoneStatusInput.caller_number)
}
inline std::string* PhoneStatusInput::_internal_mutable_caller_number() {
  _has_bits_[0] |= 0x00000001u;
  return caller_number_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PhoneStatusInput::release_caller_number() {
  // @@protoc_insertion_point(field_release:HU.PhoneStatusInput.caller_number)
  if (!_internal_has_caller_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return caller_number_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PhoneStatusInput::set_allocated_caller_number(std::string* caller_number) {
  if (caller_number != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  caller_number_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caller_number,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatusInput.caller_number)
}
inline std::string* PhoneStatusInput::unsafe_arena_release_caller_number() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.PhoneStatusInput.caller_number)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return caller_number_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PhoneStatusInput::unsafe_arena_set_allocated_caller_number(
    std::string* caller_number) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (caller_number != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  caller_number_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      caller_number, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.PhoneStatusInput.caller_number)
}

// optional string caller_id = 2;
inline bool PhoneStatusInput::_internal_has_caller_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PhoneStatusInput::has_caller_id() const {
  return _internal_has_caller_id();
}
inline void PhoneStatusInput::clear_caller_id() {
  caller_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PhoneStatusInput::caller_id() const {
  // @@protoc_insertion_point(field_get:HU.PhoneStatusInput.caller_id)
  return _internal_caller_id();
}
inline void PhoneStatusInput::set_caller_id(const std::string& value) {
  _internal_set_caller_id(value);
  // @@protoc_insertion_point(field_set:HU.PhoneStatusInput.caller_id)
}
inline std::string* PhoneStatusInput::mutable_caller_id() {
  // @@protoc_insertion_point(field_mutable:HU.PhoneStatusInput.caller_id)
  return _internal_mutable_caller_id();
}
inline const std::string& PhoneStatusInput::_internal_caller_id() const {
  return caller_id_.Get();
}
inline void PhoneStatusInput::_internal_set_caller_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  caller_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PhoneStatusInput::set_caller_id(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  caller_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.PhoneStatusInput.caller_id)
}
inline void PhoneStatusInput::set_caller_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  caller_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.PhoneStatusInput.caller_id)
}
inline void PhoneStatusInput::set_caller_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  caller_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.PhoneStatusInput.caller_id)
}
inline std::string* PhoneStatusInput::_internal_mutable_caller_id() {
  _has_bits_[0] |= 0x00000002u;
  return caller_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PhoneStatusInput::release_caller_id() {
  // @@protoc_insertion_point(field_release:HU.PhoneStatusInput.caller_id)
  if (!_internal_has_caller_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return caller_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PhoneStatusInput::set_allocated_caller_id(std::string* caller_id) {
  if (caller_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  caller_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), caller_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.PhoneStatusInput.caller_id)
}
inline std::string* PhoneStatusInput::unsafe_arena_release_caller_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.PhoneStatusInput.caller_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return caller_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void PhoneStatusInput::unsafe_arena_set_allocated_caller_id(
    std::string* caller_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (caller_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  caller_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      caller_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.PhoneStatusInput.caller_id)
}

// -------------------------------------------------------------------

// GenericNotificationRequest

// required string id = 1;
inline bool GenericNotificationRequest::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GenericNotificationRequest::has_id() const {
  return _internal_has_id();
}
inline void GenericNotificationRequest::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericNotificationRequest::id() const {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationRequest.id)
  return _internal_id();
}
inline void GenericNotificationRequest::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:HU.GenericNotificationRequest.id)
}
inline std::string* GenericNotificationRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable:HU.GenericNotificationRequest.id)
  return _internal_mutable_id();
}
inline const std::string& GenericNotificationRequest::_internal_id() const {
  return id_.Get();
}
inline void GenericNotificationRequest::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenericNotificationRequest::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.GenericNotificationRequest.id)
}
inline void GenericNotificationRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.GenericNotificationRequest.id)
}
inline void GenericNotificationRequest::set_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.GenericNotificationRequest.id)
}
inline std::string* GenericNotificationRequest::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenericNotificationRequest::release_id() {
  // @@protoc_insertion_point(field_release:HU.GenericNotificationRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenericNotificationRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.GenericNotificationRequest.id)
}
inline std::string* GenericNotificationRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.GenericNotificationRequest.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenericNotificationRequest::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.GenericNotificationRequest.id)
}

// optional string text = 2;
inline bool GenericNotificationRequest::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GenericNotificationRequest::has_text() const {
  return _internal_has_text();
}
inline void GenericNotificationRequest::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GenericNotificationRequest::text() const {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationRequest.text)
  return _internal_text();
}
inline void GenericNotificationRequest::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:HU.GenericNotificationRequest.text)
}
inline std::string* GenericNotificationRequest::mutable_text() {
  // @@protoc_insertion_point(field_mutable:HU.GenericNotificationRequest.text)
  return _internal_mutable_text();
}
inline const std::string& GenericNotificationRequest::_internal_text() const {
  return text_.Get();
}
inline void GenericNotificationRequest::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenericNotificationRequest::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.GenericNotificationRequest.text)
}
inline void GenericNotificationRequest::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.GenericNotificationRequest.text)
}
inline void GenericNotificationRequest::set_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.GenericNotificationRequest.text)
}
inline std::string* GenericNotificationRequest::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000002u;
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenericNotificationRequest::release_text() {
  // @@protoc_insertion_point(field_release:HU.GenericNotificationRequest.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenericNotificationRequest::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.GenericNotificationRequest.text)
}
inline std::string* GenericNotificationRequest::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.GenericNotificationRequest.text)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return text_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenericNotificationRequest::unsafe_arena_set_allocated_text(
    std::string* text) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      text, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.GenericNotificationRequest.text)
}

// optional string icon = 3;
inline bool GenericNotificationRequest::_internal_has_icon() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GenericNotificationRequest::has_icon() const {
  return _internal_has_icon();
}
inline void GenericNotificationRequest::clear_icon() {
  icon_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GenericNotificationRequest::icon() const {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationRequest.icon)
  return _internal_icon();
}
inline void GenericNotificationRequest::set_icon(const std::string& value) {
  _internal_set_icon(value);
  // @@protoc_insertion_point(field_set:HU.GenericNotificationRequest.icon)
}
inline std::string* GenericNotificationRequest::mutable_icon() {
  // @@protoc_insertion_point(field_mutable:HU.GenericNotificationRequest.icon)
  return _internal_mutable_icon();
}
inline const std::string& GenericNotificationRequest::_internal_icon() const {
  return icon_.Get();
}
inline void GenericNotificationRequest::_internal_set_icon(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenericNotificationRequest::set_icon(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  icon_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.GenericNotificationRequest.icon)
}
inline void GenericNotificationRequest::set_icon(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.GenericNotificationRequest.icon)
}
inline void GenericNotificationRequest::set_icon(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.GenericNotificationRequest.icon)
}
inline std::string* GenericNotificationRequest::_internal_mutable_icon() {
  _has_bits_[0] |= 0x00000004u;
  return icon_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenericNotificationRequest::release_icon() {
  // @@protoc_insertion_point(field_release:HU.GenericNotificationRequest.icon)
  if (!_internal_has_icon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return icon_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenericNotificationRequest::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  icon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icon,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.GenericNotificationRequest.icon)
}
inline std::string* GenericNotificationRequest::unsafe_arena_release_icon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.GenericNotificationRequest.icon)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return icon_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenericNotificationRequest::unsafe_arena_set_allocated_icon(
    std::string* icon) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (icon != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  icon_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      icon, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.GenericNotificationRequest.icon)
}

// -------------------------------------------------------------------

// GenericNotificationResponse

// required string id = 1;
inline bool GenericNotificationResponse::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GenericNotificationResponse::has_id() const {
  return _internal_has_id();
}
inline void GenericNotificationResponse::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GenericNotificationResponse::id() const {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationResponse.id)
  return _internal_id();
}
inline void GenericNotificationResponse::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:HU.GenericNotificationResponse.id)
}
inline std::string* GenericNotificationResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable:HU.GenericNotificationResponse.id)
  return _internal_mutable_id();
}
inline const std::string& GenericNotificationResponse::_internal_id() const {
  return id_.Get();
}
inline void GenericNotificationResponse::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GenericNotificationResponse::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.GenericNotificationResponse.id)
}
inline void GenericNotificationResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.GenericNotificationResponse.id)
}
inline void GenericNotificationResponse::set_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.GenericNotificationResponse.id)
}
inline std::string* GenericNotificationResponse::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GenericNotificationResponse::release_id() {
  // @@protoc_insertion_point(field_release:HU.GenericNotificationResponse.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GenericNotificationResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.GenericNotificationResponse.id)
}
inline std::string* GenericNotificationResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.GenericNotificationResponse.id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GenericNotificationResponse::unsafe_arena_set_allocated_id(
    std::string* id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.GenericNotificationResponse.id)
}

// required bool handled = 2;
inline bool GenericNotificationResponse::_internal_has_handled() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GenericNotificationResponse::has_handled() const {
  return _internal_has_handled();
}
inline void GenericNotificationResponse::clear_handled() {
  handled_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GenericNotificationResponse::_internal_handled() const {
  return handled_;
}
inline bool GenericNotificationResponse::handled() const {
  // @@protoc_insertion_point(field_get:HU.GenericNotificationResponse.handled)
  return _internal_handled();
}
inline void GenericNotificationResponse::_internal_set_handled(bool value) {
  _has_bits_[0] |= 0x00000002u;
  handled_ = value;
}
inline void GenericNotificationResponse::set_handled(bool value) {
  _internal_set_handled(value);
  // @@protoc_insertion_point(field_set:HU.GenericNotificationResponse.handled)
}

// -------------------------------------------------------------------

// StartGenericNotifications

// -------------------------------------------------------------------

// StopGenericNotifications

// -------------------------------------------------------------------

// BluetoothPairingRequest

// required string phone_address = 1;
inline bool BluetoothPairingRequest::_internal_has_phone_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BluetoothPairingRequest::has_phone_address() const {
  return _internal_has_phone_address();
}
inline void BluetoothPairingRequest::clear_phone_address() {
  phone_address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BluetoothPairingRequest::phone_address() const {
  // @@protoc_insertion_point(field_get:HU.BluetoothPairingRequest.phone_address)
  return _internal_phone_address();
}
inline void BluetoothPairingRequest::set_phone_address(const std::string& value) {
  _internal_set_phone_address(value);
  // @@protoc_insertion_point(field_set:HU.BluetoothPairingRequest.phone_address)
}
inline std::string* BluetoothPairingRequest::mutable_phone_address() {
  // @@protoc_insertion_point(field_mutable:HU.BluetoothPairingRequest.phone_address)
  return _internal_mutable_phone_address();
}
inline const std::string& BluetoothPairingRequest::_internal_phone_address() const {
  return phone_address_.Get();
}
inline void BluetoothPairingRequest::_internal_set_phone_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  phone_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BluetoothPairingRequest::set_phone_address(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  phone_address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.BluetoothPairingRequest.phone_address)
}
inline void BluetoothPairingRequest::set_phone_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  phone_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.BluetoothPairingRequest.phone_address)
}
inline void BluetoothPairingRequest::set_phone_address(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  phone_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.BluetoothPairingRequest.phone_address)
}
inline std::string* BluetoothPairingRequest::_internal_mutable_phone_address() {
  _has_bits_[0] |= 0x00000001u;
  return phone_address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BluetoothPairingRequest::release_phone_address() {
  // @@protoc_insertion_point(field_release:HU.BluetoothPairingRequest.phone_address)
  if (!_internal_has_phone_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return phone_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BluetoothPairingRequest::set_allocated_phone_address(std::string* phone_address) {
  if (phone_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  phone_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phone_address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.BluetoothPairingRequest.phone_address)
}
inline std::string* BluetoothPairingRequest::unsafe_arena_release_phone_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.BluetoothPairingRequest.phone_address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return phone_address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BluetoothPairingRequest::unsafe_arena_set_allocated_phone_address(
    std::string* phone_address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (phone_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  phone_address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      phone_address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.BluetoothPairingRequest.phone_address)
}

// optional .HU.BluetoothPairingMethod pairing_method = 2;
inline bool BluetoothPairingRequest::_internal_has_pairing_method() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BluetoothPairingRequest::has_pairing_method() const {
  return _internal_has_pairing_method();
}
inline void BluetoothPairingRequest::clear_pairing_method() {
  pairing_method_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::HU::BluetoothPairingMethod BluetoothPairingRequest::_internal_pairing_method() const {
  return static_cast< ::HU::BluetoothPairingMethod >(pairing_method_);
}
inline ::HU::BluetoothPairingMethod BluetoothPairingRequest::pairing_method() const {
  // @@protoc_insertion_point(field_get:HU.BluetoothPairingRequest.pairing_method)
  return _internal_pairing_method();
}
inline void BluetoothPairingRequest::_internal_set_pairing_method(::HU::BluetoothPairingMethod value) {
  assert(::HU::BluetoothPairingMethod_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  pairing_method_ = value;
}
inline void BluetoothPairingRequest::set_pairing_method(::HU::BluetoothPairingMethod value) {
  _internal_set_pairing_method(value);
  // @@protoc_insertion_point(field_set:HU.BluetoothPairingRequest.pairing_method)
}

// -------------------------------------------------------------------

// BluetoothPairingResponse

// optional bool already_paired = 1;
inline bool BluetoothPairingResponse::_internal_has_already_paired() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BluetoothPairingResponse::has_already_paired() const {
  return _internal_has_already_paired();
}
inline void BluetoothPairingResponse::clear_already_paired() {
  already_paired_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool BluetoothPairingResponse::_internal_already_paired() const {
  return already_paired_;
}
inline bool BluetoothPairingResponse::already_paired() const {
  // @@protoc_insertion_point(field_get:HU.BluetoothPairingResponse.already_paired)
  return _internal_already_paired();
}
inline void BluetoothPairingResponse::_internal_set_already_paired(bool value) {
  _has_bits_[0] |= 0x00000001u;
  already_paired_ = value;
}
inline void BluetoothPairingResponse::set_already_paired(bool value) {
  _internal_set_already_paired(value);
  // @@protoc_insertion_point(field_set:HU.BluetoothPairingResponse.already_paired)
}

// optional .HU.BluetoothPairingResponse.PAIRING_STATUS status = 2;
inline bool BluetoothPairingResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BluetoothPairingResponse::has_status() const {
  return _internal_has_status();
}
inline void BluetoothPairingResponse::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::HU::BluetoothPairingResponse_PAIRING_STATUS BluetoothPairingResponse::_internal_status() const {
  return static_cast< ::HU::BluetoothPairingResponse_PAIRING_STATUS >(status_);
}
inline ::HU::BluetoothPairingResponse_PAIRING_STATUS BluetoothPairingResponse::status() const {
  // @@protoc_insertion_point(field_get:HU.BluetoothPairingResponse.status)
  return _internal_status();
}
inline void BluetoothPairingResponse::_internal_set_status(::HU::BluetoothPairingResponse_PAIRING_STATUS value) {
  assert(::HU::BluetoothPairingResponse_PAIRING_STATUS_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  status_ = value;
}
inline void BluetoothPairingResponse::set_status(::HU::BluetoothPairingResponse_PAIRING_STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.BluetoothPairingResponse.status)
}

// -------------------------------------------------------------------

// BluetoothAuthData

// optional string data = 1;
inline bool BluetoothAuthData::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BluetoothAuthData::has_data() const {
  return _internal_has_data();
}
inline void BluetoothAuthData::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BluetoothAuthData::data() const {
  // @@protoc_insertion_point(field_get:HU.BluetoothAuthData.data)
  return _internal_data();
}
inline void BluetoothAuthData::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:HU.BluetoothAuthData.data)
}
inline std::string* BluetoothAuthData::mutable_data() {
  // @@protoc_insertion_point(field_mutable:HU.BluetoothAuthData.data)
  return _internal_mutable_data();
}
inline const std::string& BluetoothAuthData::_internal_data() const {
  return data_.Get();
}
inline void BluetoothAuthData::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BluetoothAuthData::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.BluetoothAuthData.data)
}
inline void BluetoothAuthData::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.BluetoothAuthData.data)
}
inline void BluetoothAuthData::set_data(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.BluetoothAuthData.data)
}
inline std::string* BluetoothAuthData::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BluetoothAuthData::release_data() {
  // @@protoc_insertion_point(field_release:HU.BluetoothAuthData.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BluetoothAuthData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.BluetoothAuthData.data)
}
inline std::string* BluetoothAuthData::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.BluetoothAuthData.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BluetoothAuthData::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.BluetoothAuthData.data)
}

// -------------------------------------------------------------------

// NAVMessagesStatus

// optional .HU.NAVMessagesStatus.STATUS status = 1;
inline bool NAVMessagesStatus::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NAVMessagesStatus::has_status() const {
  return _internal_has_status();
}
inline void NAVMessagesStatus::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::HU::NAVMessagesStatus_STATUS NAVMessagesStatus::_internal_status() const {
  return static_cast< ::HU::NAVMessagesStatus_STATUS >(status_);
}
inline ::HU::NAVMessagesStatus_STATUS NAVMessagesStatus::status() const {
  // @@protoc_insertion_point(field_get:HU.NAVMessagesStatus.status)
  return _internal_status();
}
inline void NAVMessagesStatus::_internal_set_status(::HU::NAVMessagesStatus_STATUS value) {
  assert(::HU::NAVMessagesStatus_STATUS_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void NAVMessagesStatus::set_status(::HU::NAVMessagesStatus_STATUS value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:HU.NAVMessagesStatus.status)
}

// -------------------------------------------------------------------

// NAVTurnMessage

// optional string event_name = 1;
inline bool NAVTurnMessage::_internal_has_event_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NAVTurnMessage::has_event_name() const {
  return _internal_has_event_name();
}
inline void NAVTurnMessage::clear_event_name() {
  event_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NAVTurnMessage::event_name() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.event_name)
  return _internal_event_name();
}
inline void NAVTurnMessage::set_event_name(const std::string& value) {
  _internal_set_event_name(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.event_name)
}
inline std::string* NAVTurnMessage::mutable_event_name() {
  // @@protoc_insertion_point(field_mutable:HU.NAVTurnMessage.event_name)
  return _internal_mutable_event_name();
}
inline const std::string& NAVTurnMessage::_internal_event_name() const {
  return event_name_.Get();
}
inline void NAVTurnMessage::_internal_set_event_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  event_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NAVTurnMessage::set_event_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  event_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.NAVTurnMessage.event_name)
}
inline void NAVTurnMessage::set_event_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  event_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.NAVTurnMessage.event_name)
}
inline void NAVTurnMessage::set_event_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  event_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.NAVTurnMessage.event_name)
}
inline std::string* NAVTurnMessage::_internal_mutable_event_name() {
  _has_bits_[0] |= 0x00000001u;
  return event_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NAVTurnMessage::release_event_name() {
  // @@protoc_insertion_point(field_release:HU.NAVTurnMessage.event_name)
  if (!_internal_has_event_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return event_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NAVTurnMessage::set_allocated_event_name(std::string* event_name) {
  if (event_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  event_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.NAVTurnMessage.event_name)
}
inline std::string* NAVTurnMessage::unsafe_arena_release_event_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.NAVTurnMessage.event_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return event_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NAVTurnMessage::unsafe_arena_set_allocated_event_name(
    std::string* event_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (event_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  event_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      event_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.NAVTurnMessage.event_name)
}

// optional .HU.NAVTurnMessage.TURN_SIDE turn_side = 2;
inline bool NAVTurnMessage::_internal_has_turn_side() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NAVTurnMessage::has_turn_side() const {
  return _internal_has_turn_side();
}
inline void NAVTurnMessage::clear_turn_side() {
  turn_side_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::HU::NAVTurnMessage_TURN_SIDE NAVTurnMessage::_internal_turn_side() const {
  return static_cast< ::HU::NAVTurnMessage_TURN_SIDE >(turn_side_);
}
inline ::HU::NAVTurnMessage_TURN_SIDE NAVTurnMessage::turn_side() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.turn_side)
  return _internal_turn_side();
}
inline void NAVTurnMessage::_internal_set_turn_side(::HU::NAVTurnMessage_TURN_SIDE value) {
  assert(::HU::NAVTurnMessage_TURN_SIDE_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  turn_side_ = value;
}
inline void NAVTurnMessage::set_turn_side(::HU::NAVTurnMessage_TURN_SIDE value) {
  _internal_set_turn_side(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.turn_side)
}

// optional .HU.NAVTurnMessage.TURN_EVENT turn_event = 3;
inline bool NAVTurnMessage::_internal_has_turn_event() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NAVTurnMessage::has_turn_event() const {
  return _internal_has_turn_event();
}
inline void NAVTurnMessage::clear_turn_event() {
  turn_event_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::HU::NAVTurnMessage_TURN_EVENT NAVTurnMessage::_internal_turn_event() const {
  return static_cast< ::HU::NAVTurnMessage_TURN_EVENT >(turn_event_);
}
inline ::HU::NAVTurnMessage_TURN_EVENT NAVTurnMessage::turn_event() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.turn_event)
  return _internal_turn_event();
}
inline void NAVTurnMessage::_internal_set_turn_event(::HU::NAVTurnMessage_TURN_EVENT value) {
  assert(::HU::NAVTurnMessage_TURN_EVENT_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  turn_event_ = value;
}
inline void NAVTurnMessage::set_turn_event(::HU::NAVTurnMessage_TURN_EVENT value) {
  _internal_set_turn_event(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.turn_event)
}

// optional bytes image = 4;
inline bool NAVTurnMessage::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NAVTurnMessage::has_image() const {
  return _internal_has_image();
}
inline void NAVTurnMessage::clear_image() {
  image_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NAVTurnMessage::image() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.image)
  return _internal_image();
}
inline void NAVTurnMessage::set_image(const std::string& value) {
  _internal_set_image(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.image)
}
inline std::string* NAVTurnMessage::mutable_image() {
  // @@protoc_insertion_point(field_mutable:HU.NAVTurnMessage.image)
  return _internal_mutable_image();
}
inline const std::string& NAVTurnMessage::_internal_image() const {
  return image_.Get();
}
inline void NAVTurnMessage::_internal_set_image(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NAVTurnMessage::set_image(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  image_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:HU.NAVTurnMessage.image)
}
inline void NAVTurnMessage::set_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:HU.NAVTurnMessage.image)
}
inline void NAVTurnMessage::set_image(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:HU.NAVTurnMessage.image)
}
inline std::string* NAVTurnMessage::_internal_mutable_image() {
  _has_bits_[0] |= 0x00000002u;
  return image_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NAVTurnMessage::release_image() {
  // @@protoc_insertion_point(field_release:HU.NAVTurnMessage.image)
  if (!_internal_has_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return image_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NAVTurnMessage::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:HU.NAVTurnMessage.image)
}
inline std::string* NAVTurnMessage::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:HU.NAVTurnMessage.image)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return image_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NAVTurnMessage::unsafe_arena_set_allocated_image(
    std::string* image) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (image != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  image_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      image, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HU.NAVTurnMessage.image)
}

// optional int32 turn_number = 5;
inline bool NAVTurnMessage::_internal_has_turn_number() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NAVTurnMessage::has_turn_number() const {
  return _internal_has_turn_number();
}
inline void NAVTurnMessage::clear_turn_number() {
  turn_number_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NAVTurnMessage::_internal_turn_number() const {
  return turn_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NAVTurnMessage::turn_number() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.turn_number)
  return _internal_turn_number();
}
inline void NAVTurnMessage::_internal_set_turn_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  turn_number_ = value;
}
inline void NAVTurnMessage::set_turn_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_turn_number(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.turn_number)
}

// optional int32 turn_angle = 6;
inline bool NAVTurnMessage::_internal_has_turn_angle() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NAVTurnMessage::has_turn_angle() const {
  return _internal_has_turn_angle();
}
inline void NAVTurnMessage::clear_turn_angle() {
  turn_angle_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NAVTurnMessage::_internal_turn_angle() const {
  return turn_angle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NAVTurnMessage::turn_angle() const {
  // @@protoc_insertion_point(field_get:HU.NAVTurnMessage.turn_angle)
  return _internal_turn_angle();
}
inline void NAVTurnMessage::_internal_set_turn_angle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  turn_angle_ = value;
}
inline void NAVTurnMessage::set_turn_angle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_turn_angle(value);
  // @@protoc_insertion_point(field_set:HU.NAVTurnMessage.turn_angle)
}

// -------------------------------------------------------------------

// NAVDistanceMessage

// optional int32 distance = 1;
inline bool NAVDistanceMessage::_internal_has_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NAVDistanceMessage::has_distance() const {
  return _internal_has_distance();
}
inline void NAVDistanceMessage::clear_distance() {
  distance_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NAVDistanceMessage::_internal_distance() const {
  return distance_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NAVDistanceMessage::distance() const {
  // @@protoc_insertion_point(field_get:HU.NAVDistanceMessage.distance)
  return _internal_distance();
}
inline void NAVDistanceMessage::_internal_set_distance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  distance_ = value;
}
inline void NAVDistanceMessage::set_distance(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:HU.NAVDistanceMessage.distance)
}

// optional int32 time_until = 2;
inline bool NAVDistanceMessage::_internal_has_time_until() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NAVDistanceMessage::has_time_until() const {
  return _internal_has_time_until();
}
inline void NAVDistanceMessage::clear_time_until() {
  time_until_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NAVDistanceMessage::_internal_time_until() const {
  return time_until_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NAVDistanceMessage::time_until() const {
  // @@protoc_insertion_point(field_get:HU.NAVDistanceMessage.time_until)
  return _internal_time_until();
}
inline void NAVDistanceMessage::_internal_set_time_until(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  time_until_ = value;
}
inline void NAVDistanceMessage::set_time_until(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_time_until(value);
  // @@protoc_insertion_point(field_set:HU.NAVDistanceMessage.time_until)
}

// optional uint64 display_distance = 3;
inline bool NAVDistanceMessage::_internal_has_display_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NAVDistanceMessage::has_display_distance() const {
  return _internal_has_display_distance();
}
inline void NAVDistanceMessage::clear_display_distance() {
  display_distance_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NAVDistanceMessage::_internal_display_distance() const {
  return display_distance_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NAVDistanceMessage::display_distance() const {
  // @@protoc_insertion_point(field_get:HU.NAVDistanceMessage.display_distance)
  return _internal_display_distance();
}
inline void NAVDistanceMessage::_internal_set_display_distance(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  display_distance_ = value;
}
inline void NAVDistanceMessage::set_display_distance(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_display_distance(value);
  // @@protoc_insertion_point(field_set:HU.NAVDistanceMessage.display_distance)
}

// optional .HU.NAVDistanceMessage.DISPLAY_DISTANCE_UNIT display_distance_unit = 4;
inline bool NAVDistanceMessage::_internal_has_display_distance_unit() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NAVDistanceMessage::has_display_distance_unit() const {
  return _internal_has_display_distance_unit();
}
inline void NAVDistanceMessage::clear_display_distance_unit() {
  display_distance_unit_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT NAVDistanceMessage::_internal_display_distance_unit() const {
  return static_cast< ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT >(display_distance_unit_);
}
inline ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT NAVDistanceMessage::display_distance_unit() const {
  // @@protoc_insertion_point(field_get:HU.NAVDistanceMessage.display_distance_unit)
  return _internal_display_distance_unit();
}
inline void NAVDistanceMessage::_internal_set_display_distance_unit(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT value) {
  assert(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  display_distance_unit_ = value;
}
inline void NAVDistanceMessage::set_display_distance_unit(::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT value) {
  _internal_set_display_distance_unit(value);
  // @@protoc_insertion_point(field_set:HU.NAVDistanceMessage.display_distance_unit)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace HU

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::HU::TouchInfo_TOUCH_ACTION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::TouchInfo_TOUCH_ACTION>() {
  return ::HU::TouchInfo_TOUCH_ACTION_descriptor();
}
template <> struct is_proto_enum< ::HU::SensorEvent_DrivingStatus_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::SensorEvent_DrivingStatus_STATUS>() {
  return ::HU::SensorEvent_DrivingStatus_STATUS_descriptor();
}
template <> struct is_proto_enum< ::HU::SensorEvent_Light_HEADLIGHT_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::SensorEvent_Light_HEADLIGHT_STATE>() {
  return ::HU::SensorEvent_Light_HEADLIGHT_STATE_descriptor();
}
template <> struct is_proto_enum< ::HU::SensorEvent_Light_TURN_INDICATOR_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::SensorEvent_Light_TURN_INDICATOR_STATE>() {
  return ::HU::SensorEvent_Light_TURN_INDICATOR_STATE_descriptor();
}
template <> struct is_proto_enum< ::HU::SensorEvent_GearData_GEAR> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::SensorEvent_GearData_GEAR>() {
  return ::HU::SensorEvent_GearData_GEAR_descriptor();
}
template <> struct is_proto_enum< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION>() {
  return ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_RESOLUTION_descriptor();
}
template <> struct is_proto_enum< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS>() {
  return ::HU::ChannelDescriptor_OutputStreamChannel_VideoConfig_VIDEO_FPS_descriptor();
}
template <> struct is_proto_enum< ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE>() {
  return ::HU::ChannelDescriptor_NavigationStatusService_CLUSTER_TYPE_descriptor();
}
template <> struct is_proto_enum< ::HU::ShutdownRequest_REASON> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::ShutdownRequest_REASON>() {
  return ::HU::ShutdownRequest_REASON_descriptor();
}
template <> struct is_proto_enum< ::HU::MediaSetupResponse_MEDIA_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::MediaSetupResponse_MEDIA_STATUS>() {
  return ::HU::MediaSetupResponse_MEDIA_STATUS_descriptor();
}
template <> struct is_proto_enum< ::HU::VoiceSessionRequest_VOICE_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::VoiceSessionRequest_VOICE_STATUS>() {
  return ::HU::VoiceSessionRequest_VOICE_STATUS_descriptor();
}
template <> struct is_proto_enum< ::HU::AudioFocusRequest_AUDIO_FOCUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::AudioFocusRequest_AUDIO_FOCUS>() {
  return ::HU::AudioFocusRequest_AUDIO_FOCUS_descriptor();
}
template <> struct is_proto_enum< ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE>() {
  return ::HU::AudioFocusResponse_AUDIO_FOCUS_STATE_descriptor();
}
template <> struct is_proto_enum< ::HU::PhoneStatus_PHONE_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::PhoneStatus_PHONE_STATE>() {
  return ::HU::PhoneStatus_PHONE_STATE_descriptor();
}
template <> struct is_proto_enum< ::HU::BluetoothPairingResponse_PAIRING_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::BluetoothPairingResponse_PAIRING_STATUS>() {
  return ::HU::BluetoothPairingResponse_PAIRING_STATUS_descriptor();
}
template <> struct is_proto_enum< ::HU::NAVMessagesStatus_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::NAVMessagesStatus_STATUS>() {
  return ::HU::NAVMessagesStatus_STATUS_descriptor();
}
template <> struct is_proto_enum< ::HU::NAVTurnMessage_TURN_SIDE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::NAVTurnMessage_TURN_SIDE>() {
  return ::HU::NAVTurnMessage_TURN_SIDE_descriptor();
}
template <> struct is_proto_enum< ::HU::NAVTurnMessage_TURN_EVENT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::NAVTurnMessage_TURN_EVENT>() {
  return ::HU::NAVTurnMessage_TURN_EVENT_descriptor();
}
template <> struct is_proto_enum< ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT>() {
  return ::HU::NAVDistanceMessage_DISPLAY_DISTANCE_UNIT_descriptor();
}
template <> struct is_proto_enum< ::HU::STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::STATUS>() {
  return ::HU::STATUS_descriptor();
}
template <> struct is_proto_enum< ::HU::SENSOR_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::SENSOR_TYPE>() {
  return ::HU::SENSOR_TYPE_descriptor();
}
template <> struct is_proto_enum< ::HU::AUDIO_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::AUDIO_TYPE>() {
  return ::HU::AUDIO_TYPE_descriptor();
}
template <> struct is_proto_enum< ::HU::STREAM_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::STREAM_TYPE>() {
  return ::HU::STREAM_TYPE_descriptor();
}
template <> struct is_proto_enum< ::HU::BluetoothPairingMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::BluetoothPairingMethod>() {
  return ::HU::BluetoothPairingMethod_descriptor();
}
template <> struct is_proto_enum< ::HU::VIDEO_FOCUS_MODE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::VIDEO_FOCUS_MODE>() {
  return ::HU::VIDEO_FOCUS_MODE_descriptor();
}
template <> struct is_proto_enum< ::HU::VIDEO_FOCUS_REASON> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HU::VIDEO_FOCUS_REASON>() {
  return ::HU::VIDEO_FOCUS_REASON_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_hu_2eproto
